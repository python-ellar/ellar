{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ellar - ASGI Python Framework","text":"<p> Ellar - Python ASGI web framework for building fast, efficient, and scalable RESTAPIs and server-side applications. </p> <p> </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Ellar is a lightweight ASGI framework designed to simplify the development of efficient and scalable server-side Python  applications. Whether you're building web services, APIs, or full-fledged web applications,  Ellar offers a high level of abstraction and powerful features to streamline your development process.</p> <p>Ellar allows developers to embrace both Object-Oriented Programming (OOP) and Functional Programming (FP) paradigms.  It is built on top of Starlette, a renowned ASGI toolkit, ensuring robust asynchronous request-handling capabilities.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Easy to Use: With an intuitive API, Ellar makes it easy for developers to get started with building fast and scalable Python web applications.</li> <li>Dependency Injection (DI): Ellar includes a built-in DI system, enabling easy management of dependencies and reducing coupling between components.</li> <li>Pydantic Integration: Integrated with Pydantic for seamless data validation, ensuring that input data is always valid.</li> <li>Templating with Jinja2: Built-in support for Jinja2 templates simplifies the creation of dynamic web pages.</li> <li>OpenAPI Documentation: Ellar has built-in support for generating OpenAPI documentation and facilitating API documentation generation with Swagger or ReDoc.</li> <li>Controller (MVC) Architecture: Ellar follows the Model-View-Controller (MVC) pattern, aiding in organizing code and separating concerns.</li> <li>Guards for Authentication and Authorization: Offers built-in support for guards, making it easy to implement authentication and authorization in applications.</li> <li>Modularity: Inspired by NestJS, Ellar follows a modular architecture, allowing developers to organize code into reusable modules.</li> <li>Asynchronous Programming: Leveraging Python's async/await feature, Ellar enables the development of efficient and high-performance applications capable of handling concurrent requests.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install Ellar using pip:</p> <pre><code>$(venv) pip install ellar\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code># Example code showcasing Ellar usage\n# (Please ensure you have properly installed Ellar first)\n\nimport uvicorn\nfrom ellar.common import Body, Controller, ControllerBase, delete, get, post, put, Serializer, Inject\nfrom ellar.app import AppFactory\nfrom ellar.di import injectable, request_scope\nfrom ellar.openapi import OpenAPIDocumentModule, OpenAPIDocumentBuilder, SwaggerUI\nfrom pydantic import Field\nfrom pathlib import Path\n\n# Define a serializer for creating a car\nclass CreateCarSerializer(Serializer):\n    name: str\n    year: int = Field(..., gt=0)\n    model: str\n\n# Define a service class for car operations\n@injectable(scope=request_scope)\nclass CarService:\n    def __init__(self):\n        self.detail = 'a service'\n\n# Define a controller for car operations\n@Controller\nclass MotoController(ControllerBase):\n    def __init__(self, service: CarService):\n        self._service = service\n\n    @post()\n    async def create(self, payload: Body[CreateCarSerializer]):\n        assert self._service.detail == 'a service'\n        result = payload.dict()\n        result.update(message='This action adds a new car')\n        return result\n\n    @put('/{car_id:str}')\n    async def update(self, car_id: str, payload: Body[CreateCarSerializer]):\n        result = payload.dict()\n        result.update(message=f'This action updated #{car_id} car resource')\n        return result\n\n    @get('/{car_id:str}')\n    async def get_one(self, car_id: str, service: Inject[CarService]):\n        assert self._service == service\n        return f\"This action returns a #{car_id} car\"\n\n    @delete('/{car_id:str}')\n    async def delete(self, car_id: str):\n        return f\"This action removes a #{car_id} car\"\n\n# Create the Ellar application\napp = AppFactory.create_app(\n    controllers=[MotoController],\n    providers=[CarService],\n    base_directory=str(Path(__file__).parent),\n    config_module=dict(REDIRECT_SLASHES=True),\n    template_folder='templates'\n)\n\n# Build OpenAPI documentation\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title('Ellar API') \\\n    .set_version('1.0.2') \\\n    .set_contact(name='Author', url='https://www.yahoo.com', email='author@gmail.com') \\\n    .set_license('MIT Licence', url='https://www.google.com')\ndocument = document_builder.build_document(app)\n\n# Setup OpenAPI documentation module\nOpenAPIDocumentModule.setup(\n    app=app,\n    docs_ui=SwaggerUI(),\n    document=document,\n    guards=[]\n)\n\n# Run the application\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, reload=True)\n</code></pre> <p>Now we can test our API at http://127.0.0.1:5000/docs</p> <p>You can also try the quick-project setup to get a good idea of the library.</p>"},{"location":"#project-documentation-status","title":"Project Documentation Status","text":"<ul> <li>Authorization: In progress</li> </ul>"},{"location":"#dependency-summary","title":"Dependency Summary","text":"<p>Ellar has the following dependencies:</p> <ul> <li>Python &gt;= 3.7</li> <li>Starlette</li> <li>Pydantic</li> <li>Injector</li> </ul>"},{"location":"#try-it-out","title":"Try It Out","text":"<p>You can access the Ellar API documentation at http://127.0.0.1:5000/docs. Additionally, you can try the quick-project setup to get started quickly with Ellar.</p>"},{"location":"contribution/","title":"Contribution Guidelines","text":"<p>Thank you for considering contributing to Ellar! Your contributions help make the project better for everyone.  Please take a moment to review the following guidelines before getting started.</p>"},{"location":"contribution/#setting-up-the-development-environment","title":"Setting up the Development Environment","text":"<ol> <li> <p>Fork the repository: Fork the Ellar repository on GitHub and clone it locally.</p> </li> <li> <p>Virtual Environment: Create and activate a virtual environment for the project.</p> </li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # Linux/macOS\n</code></pre> <pre><code>python -m venv venv\n.\\venv\\Scripts\\activate  # Windows\n</code></pre> <ol> <li>Install <code>flit</code>: Ensure you have <code>flit</code> installed globally.</li> </ol> <pre><code>pip install flit\n</code></pre> <ol> <li>Install Dependencies: Install development libraries and pre-commit hooks.</li> </ol> <pre><code>make install\n</code></pre>"},{"location":"contribution/#code-style-and-formatting","title":"Code Style and Formatting","text":"<ul> <li>Formatting: To format your code and ensure consistency, run:</li> </ul> <pre><code>make fmt\n</code></pre> <ul> <li>Linting: Ellar uses <code>mypy</code> and <code>ruff</code> for linting. Run the following command to check code linting:</li> </ul> <pre><code>make lint\n</code></pre>"},{"location":"contribution/#testing","title":"Testing","text":"<ul> <li>Unit Tests: We use <code>pytest</code> for unit testing. Run the test suite:</li> </ul> <pre><code>make test\n</code></pre> <ul> <li>Test Coverage: To check test coverage:</li> </ul> <pre><code>make test-cov\n</code></pre>"},{"location":"contribution/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Branch: Create a new branch for your feature or bug fix.</li> </ol> <pre><code>git checkout -b feature-branch\n</code></pre> <ol> <li> <p>Commit Messages: Follow the Conventional Commits specification for your commit messages.</p> </li> <li> <p>Push Changes: Push your branch to your forked repository.</p> </li> </ol> <pre><code>git push origin feature-branch\n</code></pre> <ol> <li>Pull Request: Open a pull request against the <code>master</code> branch of the Ellar repository. Provide a clear and descriptive title and description for your changes.</li> </ol> <p>Thank you for contributing to Ellar! \ud83d\ude80</p>"},{"location":"custom-setup/","title":"Custom setup","text":""},{"location":"custom-setup/#installation","title":"Installation","text":"<pre><code>pip install ellar\n</code></pre>"},{"location":"custom-setup/#usage","title":"Usage","text":"<p>Create a file <code>controller.py</code>:</p> <pre><code>from ellar.common import ModuleRouter, Controller, get\n\nrouter = ModuleRouter('')\n\n\n@router.get(\"/add\")\ndef add(request, a: int, b: int):\n    return {\"result\": a + b}\n\n\n@Controller(\"\", tag='Math')\nclass MathAPI:\n\n    @get('/subtract', )\n    def subtract(self, a: int, b: int):\n        \"\"\"Subtracts a from b\"\"\"\n        return {\"result\": a - b}\n\n    @get('/divide', )\n    def divide(self, a: int, b: int):\n        \"\"\"Divides a by b\"\"\"\n        return {\"result\": a / b}\n\n    @get('/multiple', )\n    def multiple(self, a: int, b: int):\n        \"\"\"Multiples a with b\"\"\"\n        return {\"result\": a * b}\n</code></pre> <p>Create another file <code>server.py</code>:</p> <pre><code>from ellar.app import AppFactory\nfrom ellar.openapi import OpenAPIDocumentBuilder, OpenAPIDocumentModule\nfrom .controller import router, MathAPI\n\n\napp = AppFactory.create_app(routers=(router, ), controllers=(MathAPI, ))\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title('Your Title')\\\n    .set_version('1.0.2')\\\n    .set_contact(name='Eadwin', url='https://www.yahoo.com', email='eadwin@gmail.com')\\\n    .set_license('MIT Licence', url='https://www.google.com')\n\ndocument = document_builder.build_document(app)\nmodule = app.install_module(OpenAPIDocumentModule, document=document)\nmodule.setup_swagger_doc()\n</code></pre>"},{"location":"custom-setup/#start-up-server","title":"Start up Server","text":"<pre><code>uvicorn server:app --reload\n</code></pre>"},{"location":"custom-setup/#interactive-api-docs","title":"Interactive API docs","text":"<p>Now go to http://localhost:8000/docs/</p> <p>You will see the automatic interactive API documentation (provided by Swagger UI):</p> <p></p>"},{"location":"quick-project/","title":"Quick Project","text":"<p>This section will guide on how to quickly setup ellar project to just have a glimpse of its features.</p>"},{"location":"quick-project/#ellar-cli","title":"Ellar CLI","text":"<p>Ellar CLI helps in quick project scaffolding. <pre><code>pip install ellar-cli\n</code></pre> or  <pre><code>poetry add ellar-cli\n</code></pre></p>"},{"location":"quick-project/#creating-a-project","title":"Creating a project","text":"<p>To create an ellar project, you need to have a <code>pyproject.toml</code> available on your root directory. This is necessary for ellar to store some <code>metadata</code> about your project. </p> <p>If you are using <code>Poetry</code>, you might have to run <code>poetry init</code> first before running the command below: <pre><code>ellar create-project carsite\n</code></pre></p> <p>For Pip Users <pre><code>ellar new carsite\n</code></pre> This will create the <code>pyproject.toml</code> and add all other necessary files for your ellar project.</p> <p>Also, if you want a plain scaffold without <code>pyproject.toml</code> <pre><code>ellar new carsite --plain\n</code></pre> See this plain projects CLI execution pattern</p> <p>In the scaffolded project, you will see the following:</p> <ul> <li><code>server.py</code>: is the entry point of the application. </li> <li><code>config.py</code>: hold all application configuration</li> <li><code>root_module.py</code>: hold reference to all registered Application Modules</li> <li><code>core</code>: directory to add core business logics</li> <li><code>domain</code>: directory to add domain models</li> </ul>"},{"location":"quick-project/#run-your-project","title":"Run your project","text":"<p>Ellar runs UVICORN - ASGI Server under the hood. <pre><code>ellar runserver --reload\n</code></pre> <code>--reload</code> is to watch for file changes</p> <p>OR, if you want to use a different ASGI server, it's allowed. <pre><code>uvicorn run server:application --reload\n</code></pre></p> <p>Now go to http://127.0.0.1:8000 </p> <p>For more info on Ellar CLI, click here</p>"},{"location":"quick-project/#adding-a-project-module","title":"Adding a project module","text":"<p>A project module is a like project app defining a group of controllers or services including templates and static files. So, we shall be adding a <code>car</code> module to our <code>carsite</code> project just to handle some logic like creating and retrieving car data.</p> <p><pre><code>ellar create-module car carsite\n</code></pre> This will add some files like:</p> <ul> <li><code>controllers.py</code>: where we can add different controllers for car module</li> <li><code>schemas.py</code>: place to define various pydantic schemas for both controller and service use.</li> <li><code>routers.py</code>: an alternative to controller class if you enjoy defining endpoint in functions </li> <li><code>module.py</code>: an export for our car module that will be registered in <code>root_module.py</code> of the project</li> <li><code>services.py</code>: place where we can define services for managing data and others for our car module</li> <li><code>tests</code>: place to add unit test or E2E test for out car module</li> </ul>"},{"location":"quick-project/#add-schema","title":"Add Schema","text":"<p>In <code>car/schema.py</code>, let's add some serializer for car input and output data <pre><code>from ellar.common import Serializer\n\nclass CarSerializer(Serializer):\n    name: str\n    model: str\n    brand: str\n\n\nclass RetrieveCarSerializer(CarSerializer):\n    pk: str\n</code></pre></p>"},{"location":"quick-project/#add-services","title":"Add Services","text":"<p>In <code>car/services.py</code>, 'lets' create a dummy repository <code>CarDummyDB</code> to manage our car data. <pre><code>\"\"\"\nCreate a provider and declare its scope\n\n@injectable\nclass AProvider\n    pass\n\n@injectable(scope=transient_scope)\nclass BProvider\n    pass\n\"\"\"\nimport typing as t\nimport uuid\nfrom ellar.di import injectable, singleton_scope\n\n\nclass DummyDBItem:\n    pk: str\n\n    def __init__(self, **data: t.Dict) -&gt; None:\n        self.__dict__ = data\n\n    def __eq__(self, other):\n        if isinstance(other, DummyDBItem):\n            return self.pk == other.pk\n        return self.pk == str(other)\n\n\n@injectable(scope=singleton_scope)\nclass CarDummyDB:\n    def __init__(self) -&gt; None:\n        self._data: t.List[DummyDBItem] = []\n\n    def add_car(self, data: t.Dict) -&gt; str:\n        pk = uuid.uuid4()\n        _data = dict(data)\n        _data.update(pk=str(pk))\n        item = DummyDBItem(**_data)\n        self._data.append(item)\n        return item.pk\n\n    def list(self) -&gt; t.List[DummyDBItem]:\n        return self._data\n\n    def update(self, car_id: str, data: t.Dict) -&gt; t.Optional[DummyDBItem]:\n        if car_id in self._data:\n            idx = self._data.index(car_id)\n            _data = dict(data)\n            _data.update(pk=str(car_id))\n            self._data[idx] = DummyDBItem(**_data)\n            return self._data[idx]\n\n    def get(self, car_id: str) -&gt; t.Optional[DummyDBItem]:\n        if car_id in self._data:\n            idx = self._data.index(car_id)\n            return self._data[idx]\n\n\n    def remove(self, car_id: str) -&gt; t.Optional[DummyDBItem]:\n        if car_id in self._data:\n            idx = self._data.index(car_id)\n            return self._data.pop(idx)\n</code></pre></p>"},{"location":"quick-project/#add-controller","title":"Add Controller","text":"<p>In <code>car/controllers.py</code>, lets create <code>CarController</code></p> <pre><code>import typing as t\nfrom ellar.common import Controller, delete, get, put, post, ControllerBase\nfrom ellar.common.exceptions import NotFound\nfrom .schemas import CarSerializer, RetrieveCarSerializer\nfrom .services import CarDummyDB\n\n\n@Controller\nclass CarController(ControllerBase):\n    def __init__(self, db: CarDummyDB) -&gt; None:\n        self.car_db = db\n\n    @post(\"/create\", response={200: str})\n    async def create_cat(self, payload: CarSerializer):\n        pk = self.car_db.add_car(payload.dict())\n        return pk\n\n    @put(\"/{car_id:str}\", response={200: RetrieveCarSerializer})\n    async def update_cat(self, car_id: str, payload: CarSerializer):\n        car = self.car_db.update(car_id, payload.dict())\n        if not car:\n            raise NotFound(\"Item not found\")\n        return car\n\n    @get(\"/{car_id:str}\", response={200: RetrieveCarSerializer})\n    async def get_car_by_id(self, car_id: str):\n        car = self.car_db.get(car_id)\n        if not car:\n            raise NotFound('Item not found.')\n        return car\n\n    @delete(\"/{car_id:str}\", response={204: dict})\n    async def deleted_cat(self, car_id: str):\n        car = self.car_db.remove(car_id)\n        if not car:\n            raise NotFound('Item not found.')\n        return 204, {}\n\n    @get(\"/\", response={200: t.List[RetrieveCarSerializer]})\n    async def list(self):\n        return self.car_db.list()\n</code></pre>"},{"location":"quick-project/#register-service-and-controller","title":"Register Service and Controller","text":"<p>In <code>car/module.py</code>, lets register <code>CarController</code> and <code>CarDummyDB</code></p> <pre><code>from ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\n\nfrom .controllers import CarController\nfrom .services import CarDummyDB\n\n\n@Module(\n    controllers=[CarController],\n    providers=[CarDummyDB],\n    routers=[],\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre>"},{"location":"quick-project/#registering-module","title":"Registering Module","text":"<p>Ellar is not aware of <code>CarModule</code> yet, so we need to add it to the <code>modules</code> list of <code>ApplicationModule</code> at the <code>carsite/root_module.py</code>. <pre><code>from ellar.common import Module, exception_handler, JSONResponse, Response, IHostContext\nfrom ellar.core import ModuleBase\n\nfrom ellar.samples.modules import HomeModule\nfrom .car.module import CarModule\n\n\n@Module(modules=[HomeModule, CarModule])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, context: IHostContext, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"))\n</code></pre></p>"},{"location":"quick-project/#enabling-openapi-docs","title":"Enabling OpenAPI Docs","text":"<p>To start up openapi, we need to go back to project folder in the <code>server.py</code> then add the following below. <pre><code>import os\n\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.app import AppFactory\nfrom ellar.openapi import OpenAPIDocumentModule, OpenAPIDocumentBuilder, SwaggerUI\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"carsite.config:DevelopmentConfig\"\n    ),\n)\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title('CarSite API') \\\n    .set_version('1.0.0') \\\n    .set_contact(name='Author', url='https://www.yahoo.com', email='author@gmail.com') \\\n    .set_license('MIT Licence', url='https://www.google.com')\n\ndocument = document_builder.build_document(application)\nmodule = OpenAPIDocumentModule.setup(\n    app=application,\n    document=document,\n    docs_ui=SwaggerUI(),\n    guards=[]\n)\n</code></pre></p> <p>Now we can test our API at http://127.0.0.1:8000/docs Please ensure your server is running </p>"},{"location":"quick-project/#source-code","title":"Source Code","text":"<p>You can find this example source code here</p>"},{"location":"release-notes/","title":"0.8.5","text":""},{"location":"release-notes/#whats-changed","title":"What's Changed","text":"<ul> <li>Bump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.2 by @dependabot in https://github.com/python-ellar/ellar/pull/246</li> <li>fix:Route Resolvers with custom alias and name by @eadwinCode in https://github.com/python-ellar/ellar/pull/247</li> <li>fix: Skip template name with any extension  by @eadwinCode in https://github.com/python-ellar/ellar/pull/248</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.8.4...0.8.5</p>"},{"location":"release-notes/#084","title":"0.8.4","text":""},{"location":"release-notes/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Custom resolver gen by @eadwinCode in https://github.com/python-ellar/ellar/pull/245</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.8.3...0.8.4</p>"},{"location":"release-notes/#083","title":"0.8.3","text":""},{"location":"release-notes/#whats-changed_2","title":"What's Changed","text":"<ul> <li>fix: ForwardRef and Service lookup by @eadwinCode in https://github.com/python-ellar/ellar/pull/235</li> <li>Bump ruff from 0.5.5 to 0.6.3 by @dependabot in https://github.com/python-ellar/ellar/pull/241</li> <li>Bump mypy from 1.11.1 to 1.11.2 by @dependabot in https://github.com/python-ellar/ellar/pull/240</li> <li>Bump aiohttp from 3.10.0 to 3.10.5 by @dependabot in https://github.com/python-ellar/ellar/pull/239</li> <li>Bump types-redis from 4.6.0.20240425 to 4.6.0.20240819 by @dependabot in https://github.com/python-ellar/ellar/pull/238</li> <li>Bump uvicorn[standard] from 0.30.4 to 0.30.6 by @dependabot in https://github.com/python-ellar/ellar/pull/237</li> <li>fix: allOf for latest Pydantic version by @eadwinCode in https://github.com/python-ellar/ellar/pull/244</li> <li>Fix: Moved Passlib and click package as an optional dependency by @eadwinCode in https://github.com/python-ellar/ellar/pull/243</li> <li>Bump types-redis from 4.6.0.20240819 to 4.6.0.20240903 by @dependabot in https://github.com/python-ellar/ellar/pull/242</li> <li>fix: Unified route function resolvers by @eadwinCode in https://github.com/python-ellar/ellar/pull/236</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.8.2...0.8.3</p>"},{"location":"release-notes/#082","title":"0.8.2","text":""},{"location":"release-notes/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Removed jinja validator by @eadwinCode in https://github.com/python-ellar/ellar/pull/234</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.8.1...0.8.2</p>"},{"location":"release-notes/#081","title":"0.8.1","text":""},{"location":"release-notes/#whats-new","title":"What's new","text":"<ul> <li>Module Service/Providers Encapsulation:  Modules has the ability to define services that won't be accessible to other application modules. This provides a proper graph of module dependencies amongst each other and gives a clear information on services exposed and managed by each modules.</li> <li>Module ForwardRef: Modules that depends on another imported module can forward ref the module object to be able to utilize services/providers exposed by that module. </li> <li>ModuleRouter Nesting: ModuleRouter objects can be nested with other ModuleRouter object as necessary for the user</li> </ul>"},{"location":"release-notes/#whats-changed_4","title":"What's Changed","text":"<ul> <li>fix: Application Context Round Usage by @eadwinCode in https://github.com/python-ellar/ellar/pull/217</li> <li>feat: Nested ModuleRouter support by @eadwinCode in https://github.com/python-ellar/ellar/pull/218</li> <li>Module Builder Refactor by @eadwinCode in https://github.com/python-ellar/ellar/pull/219</li> <li>Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0 by @dependabot in https://github.com/python-ellar/ellar/pull/221</li> <li>Bump codecov/codecov-action from 4.4.1 to 4.5.0 by @dependabot in https://github.com/python-ellar/ellar/pull/220</li> <li>Bump mypy from 1.10.0 to 1.10.1 by @dependabot in https://github.com/python-ellar/ellar/pull/223</li> <li>Bump ruff from 0.4.7 to 0.5.0 by @dependabot in https://github.com/python-ellar/ellar/pull/222</li> <li>feat: Module Container Services Encapsulation by @eadwinCode in https://github.com/python-ellar/ellar/pull/224</li> <li>Bump uvicorn[standard] from 0.30.1 to 0.30.4 by @dependabot in https://github.com/python-ellar/ellar/pull/228</li> <li>Bump aiohttp from 3.9.5 to 3.10.0 by @dependabot in https://github.com/python-ellar/ellar/pull/226</li> <li>Bump injector from 0.21.0 to 0.22.0 by @dependabot in https://github.com/python-ellar/ellar/pull/227</li> <li>Bump starlette from 0.37.2 to 0.38.2 by @dependabot in https://github.com/python-ellar/ellar/pull/229</li> <li>Bump ruff from 0.5.0 to 0.5.5 by @dependabot in https://github.com/python-ellar/ellar/pull/225</li> <li>Ft: Module Routes Execution Context by @eadwinCode in https://github.com/python-ellar/ellar/pull/230</li> <li>Added py3.12 support by @eadwinCode in https://github.com/python-ellar/ellar/pull/190</li> <li>Documentation Updates Aug2024 by @eadwinCode in https://github.com/python-ellar/ellar/pull/231</li> <li>fix: Drop Global Guard as Provider by @eadwinCode in https://github.com/python-ellar/ellar/pull/232</li> <li>fixed app ready check by @eadwinCode in https://github.com/python-ellar/ellar/pull/233</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.8...0.8.1</p>"},{"location":"release-notes/#08b1","title":"0.8b1","text":""},{"location":"release-notes/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Bump uvicorn[standard] from 0.30.1 to 0.30.4 by @dependabot in https://github.com/python-ellar/ellar/pull/228</li> <li>Bump aiohttp from 3.9.5 to 3.10.0 by @dependabot in https://github.com/python-ellar/ellar/pull/226</li> <li>Bump injector from 0.21.0 to 0.22.0 by @dependabot in https://github.com/python-ellar/ellar/pull/227</li> <li>Bump starlette from 0.37.2 to 0.38.2 by @dependabot in https://github.com/python-ellar/ellar/pull/229</li> <li>Bump ruff from 0.5.0 to 0.5.5 by @dependabot in https://github.com/python-ellar/ellar/pull/225</li> <li>Ft: Module Routes Execution Context by @eadwinCode in https://github.com/python-ellar/ellar/pull/230</li> <li>Added py3.12 support by @eadwinCode in https://github.com/python-ellar/ellar/pull/190</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.8.0a1...0.8b1</p> <p>#0.8.a1</p>"},{"location":"release-notes/#whats-new_1","title":"What's new","text":"<ul> <li>Module Service/Providers Encapsulation:  Modules has the ability to define services that won't be accessible to other application modules. This provides a proper graph of module dependencies amongst each other and gives a clear information on services exposed and managed by each modules.</li> <li>Module ForwardRef: Modules that depends on another imported module can forward ref the module object to be able to utilize services/providers exposed by that module. </li> <li>ModuleRouter Nesting: ModuleRouter objects can be nested with other ModuleRouter object as necessary for the user</li> </ul>"},{"location":"release-notes/#what-changed","title":"What' changed","text":"<ul> <li>fix: Application Context Round Usage by @eadwinCode in https://github.com/python-ellar/ellar/pull/217</li> <li>Module Builder Refactor by @eadwinCode in https://github.com/python-ellar/ellar/pull/219</li> <li>Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0 by @dependabot in https://github.com/python-ellar/ellar/pull/221</li> <li>Bump codecov/codecov-action from 4.4.1 to 4.5.0 by @dependabot in https://github.com/python-ellar/ellar/pull/220</li> <li>Bump mypy from 1.10.0 to 1.10.1 by @dependabot in https://github.com/python-ellar/ellar/pull/223</li> <li>Bump ruff from 0.4.7 to 0.5.0 by @dependabot in https://github.com/python-ellar/ellar/pull/222</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.8...0.8.0a1</p>"},{"location":"release-notes/#078","title":"0.7.8","text":""},{"location":"release-notes/#whats-changed_6","title":"What's Changed","text":"<ul> <li>Policy Refactor by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/9ebb844d942359645b61412480a0031d3a43d0d7</li> <li>Dropped task execution for module lifespan actions by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/7724b21efbc82d30171d930f6cebab15fcc4eebf</li> <li>feat: Added middleware support to EllarMount and ApplicationContext by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/61ff5c0a97b0e965e6e82e121530de26aea4f528</li> <li>Fixed module template filters and global variables by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/7f883c38e74df54d5b026015420d60ecfb9e4b47</li> <li>Added support for injector to be nested, dropped controller class key and added support for controller inheritance by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/f50cffc3cde44cf868867cff71a712d0358cabf2</li> <li>Added support for gateway controller inheritance by @eadwinCode in https://github.com/python-ellar/ellar/pull/216/commits/aab73fda48c00ac6849d1abbf6b7d4ba67a12449</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.7...0.7.8</p>"},{"location":"release-notes/#077","title":"0.7.7","text":""},{"location":"release-notes/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Bump types-ujson from 5.9.0.0 to 5.10.0.20240515 by @dependabot in https://github.com/python-ellar/ellar/pull/213</li> <li>Bump ruff from 0.4.2 to 0.4.7 by @dependabot in https://github.com/python-ellar/ellar/pull/212</li> <li>Bump uvicorn[standard] from 0.29.0 to 0.30.0 by @dependabot in https://github.com/python-ellar/ellar/pull/211</li> <li>Bump uvicorn[standard] from 0.30.0 to 0.30.1 by @dependabot in https://github.com/python-ellar/ellar/pull/214</li> <li>Bump codecov/codecov-action from 4.3.0 to 4.4.1 by @dependabot in https://github.com/python-ellar/ellar/pull/210</li> <li>Bump mypy from 1.9.0 to 1.10.0 by @dependabot in https://github.com/python-ellar/ellar/pull/202</li> <li>fix: TestingModule metadata sharing during tests by @eadwinCode in https://github.com/python-ellar/ellar/pull/215</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.6...0.7.7</p>"},{"location":"release-notes/#076","title":"0.7.6","text":""},{"location":"release-notes/#whats-changed_8","title":"What's Changed","text":"<ul> <li>Bump codecov/codecov-action from 4.1.1 to 4.3.0 by @dependabot in https://github.com/python-ellar/ellar/pull/207</li> <li>Bump ruff from 0.3.4 to 0.4.2 by @dependabot in https://github.com/python-ellar/ellar/pull/206</li> <li>Update mkdocstrings[python] requirement from &lt;0.25.0,&gt;=0.19.0 to &gt;=0.19.0,&lt;0.26.0 by @dependabot in https://github.com/python-ellar/ellar/pull/205</li> <li>Bump types-redis from 4.6.0.20240218 to 4.6.0.20240425 by @dependabot in https://github.com/python-ellar/ellar/pull/204</li> <li>Bump aiohttp from 3.9.3 to 3.9.5 by @dependabot in https://github.com/python-ellar/ellar/pull/203</li> <li>mypy 1.10.0 upgrade by @eadwinCode in https://github.com/python-ellar/ellar/pull/208</li> <li>May 22/24 patches by @eadwinCode in https://github.com/python-ellar/ellar/pull/209</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.4...0.7.6</p>"},{"location":"release-notes/#074","title":"0.7.4","text":""},{"location":"release-notes/#whats-changed_9","title":"What's Changed","text":"<ul> <li>feat(DI): Service registration with tag by @eadwinCode in https://github.com/python-ellar/ellar/pull/200</li> <li>Bump mypy from 1.8.0 to 1.9.0 by @dependabot in https://github.com/python-ellar/ellar/pull/195</li> <li>feat: Dynamic command by @eadwinCode in https://github.com/python-ellar/ellar/pull/201</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.3...0.7.4</p>"},{"location":"release-notes/#073","title":"0.7.3","text":""},{"location":"release-notes/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Bump codecov/codecov-action from 4.0.0 to 4.1.1 by @dependabot in https://github.com/python-ellar/ellar/pull/198</li> <li>Bump pypa/gh-action-pypi-publish from 1.8.12 to 1.8.14 by @dependabot in https://github.com/python-ellar/ellar/pull/197</li> <li>Bump ruff from 0.3.0 to 0.3.4 by @dependabot in https://github.com/python-ellar/ellar/pull/196</li> <li>Update pytest-cov requirement from &lt;5.0.0,&gt;=2.12.0 to &gt;=2.12.0,&lt;6.0.0 by @dependabot in https://github.com/python-ellar/ellar/pull/193</li> <li>Bump uvicorn[standard] from 0.27.1 to 0.29.0 by @dependabot in https://github.com/python-ellar/ellar/pull/192</li> <li>Minor Fixes by @eadwinCode in https://github.com/python-ellar/ellar/pull/199</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.2...0.7.3</p>"},{"location":"release-notes/#072","title":"0.7.2","text":""},{"location":"release-notes/#whats-changed_11","title":"What's Changed","text":"<ul> <li>Renamed examples to samples by @eadwinCode in https://github.com/python-ellar/ellar/pull/188</li> <li>Update mkdocstrings[python] requirement from &lt;0.24.0,&gt;=0.19.0 to &gt;=0.19.0,&lt;0.25.0 by @dependabot in https://github.com/python-ellar/ellar/pull/187</li> <li>Bump types-redis from 4.6.0.20240106 to 4.6.0.20240218 by @dependabot in https://github.com/python-ellar/ellar/pull/186</li> <li>Bump ruff from 0.1.9 to 0.3.0 by @dependabot in https://github.com/python-ellar/ellar/pull/185</li> <li>Update python-multipart requirement from &lt;0.0.7,&gt;=0.0.5 to &gt;=0.0.5,&lt;0.0.10 by @dependabot in https://github.com/python-ellar/ellar/pull/184</li> <li>Bump pypa/gh-action-pypi-publish from 1.8.11 to 1.8.12 by @dependabot in https://github.com/python-ellar/ellar/pull/183</li> <li>Lib dependency restructure by @eadwinCode in https://github.com/python-ellar/ellar/pull/189</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.1...0.7.2</p>"},{"location":"release-notes/#071","title":"0.7.1","text":""},{"location":"release-notes/#whats-changed_12","title":"What's Changed","text":"<ul> <li>Fixed EmailStr bug by @eadwinCode in https://github.com/python-ellar/ellar/pull/181</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.7.0...0.7.1</p>"},{"location":"release-notes/#070","title":"0.7.0","text":""},{"location":"release-notes/#whats-changed_13","title":"What's Changed","text":"<ul> <li>Bump aiohttp from 3.9.1 to 3.9.3 by @dependabot in https://github.com/python-ellar/ellar/pull/178</li> <li>Bump types-redis from 4.6.0.11 to 4.6.0.20240106 by @dependabot in https://github.com/python-ellar/ellar/pull/175</li> <li>Bump pypa/gh-action-pypi-publish from 1.8.10 to 1.8.11 by @dependabot in https://github.com/python-ellar/ellar/pull/173</li> <li>Bump codecov/codecov-action from 3.1.4 to 4.0.0 by @dependabot in https://github.com/python-ellar/ellar/pull/172</li> <li>Update pytest requirement from &lt;8.0.0,&gt;=6.2.4 to &gt;=6.2.4,&lt;9.0.0 by @dependabot in https://github.com/python-ellar/ellar/pull/174</li> <li>moved <code>ellar.common.routing</code> core implementation to <code>ellar.core.routing</code> by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>dropped <code>application.install_module()</code> by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>Moved Controllers and Routers computation to happen during <code>@Module</code> processing by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>Renamed <code>ellar.openapi.open_info</code> to <code>ellar.openapi.api_info</code> by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>Added Session Documentation by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>Added OpenAPI Documentation by @eadwinCode in https://github.com/python-ellar/ellar/pull/179</li> <li>Starlette 0.37.1 support by @eadwinCode in https://github.com/python-ellar/ellar/pull/180</li> </ul>"},{"location":"release-notes/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>dropped <code>application.install_module()</code> use ModuleSetup for Modules that need application services</li> <li><code>OPENAPIModule.setup</code> requires app as parameter.</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.6.8...0.7.0</p>"},{"location":"release-notes/#068","title":"0.6.8","text":""},{"location":"release-notes/#whats-changed_14","title":"What's Changed","text":"<ul> <li>Drop file storage  by @eadwinCode in https://github.com/python-ellar/ellar/pull/171</li> <li>Updated Ellar CLI documentation by @eadwinCode in https://github.com/python-ellar/ellar/pull/171</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.6.7...0.6.8</p>"},{"location":"release-notes/#067","title":"0.6.7","text":""},{"location":"release-notes/#whats-changed_15","title":"What's Changed","text":"<ul> <li>Bug Fixes: Extra Route Args multiple field grouping by @eadwinCode in https://github.com/python-ellar/ellar/pull/170</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.6.6...0.6.7</p>"},{"location":"release-notes/#066","title":"0.6.6","text":""},{"location":"release-notes/#whats-changed_16","title":"What's Changed","text":"<ul> <li>Update publish.yml by @eadwinCode in https://github.com/python-ellar/ellar/pull/168</li> <li>Feat: Added support for running async context manager with sync_worker by @eadwinCode in https://github.com/python-ellar/ellar/pull/169</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.6.4...0.6.6</p>"},{"location":"release-notes/#064","title":"0.6.4","text":""},{"location":"release-notes/#whats-changed_17","title":"What's Changed","text":"<ul> <li>Bump actions/setup-python from 4 to 5 by @dependabot in https://github.com/python-ellar/ellar/pull/165</li> <li>Bump types-ujson from 5.8.0.1 to 5.9.0.0 by @dependabot in https://github.com/python-ellar/ellar/pull/164</li> <li>Bump uvicorn[standard] from 0.23.2 to 0.25.0 by @dependabot in https://github.com/python-ellar/ellar/pull/163</li> <li>Bump ruff from 0.1.7 to 0.1.9 by @dependabot in https://github.com/python-ellar/ellar/pull/162</li> <li>Async application context by @eadwinCode in https://github.com/python-ellar/ellar/pull/167</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.6.2...0.6.4</p>"},{"location":"release-notes/#062","title":"0.6.2","text":""},{"location":"release-notes/#whats-changed_18","title":"What's Changed","text":"<ul> <li>Files System And File Mounting by @eadwinCode in https://github.com/python-ellar/ellar/pull/147</li> <li>100% test coverage by @eadwinCode in https://github.com/python-ellar/ellar/pull/158</li> <li>App stack build on lifespan by @eadwinCode in https://github.com/python-ellar/ellar/pull/159</li> <li>Added support for Swagger Doc dark theme.</li> </ul>"},{"location":"release-notes/#060","title":"0.6.0","text":""},{"location":"release-notes/#whats-changed_19","title":"What's Changed","text":"<ul> <li>Feat(LazyModuleImport): New feature by @eadwinCode in https://github.com/python-ellar/ellar/pull/155</li> <li>Feat - Lazy Loading ApplicationModule by @eadwinCode in https://github.com/python-ellar/ellar/pull/156</li> <li>code refactoring by @eadwinCode in https://github.com/python-ellar/ellar/pull/157</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.8...0.6.0</p>"},{"location":"release-notes/#058","title":"0.5.8","text":""},{"location":"release-notes/#whats-changed_20","title":"What's Changed","text":"<ul> <li>Bump ruff from 0.1.4 to 0.1.6 by @dependabot in https://github.com/python-ellar/ellar/pull/152</li> <li>Bump types-redis from 4.6.0.8 to 4.6.0.11 by @dependabot in https://github.com/python-ellar/ellar/pull/153</li> <li>Bump black from 23.10.1 to 23.11.0 by @dependabot in https://github.com/python-ellar/ellar/pull/151</li> <li>Bump aiohttp from 3.8.5 to 3.9.1 by @dependabot in https://github.com/python-ellar/ellar/pull/150</li> <li>Pydantic v2 migration by @eadwinCode in https://github.com/python-ellar/ellar/pull/148</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.7...0.5.8</p>"},{"location":"release-notes/#057","title":"0.5.7","text":""},{"location":"release-notes/#whats-changed_21","title":"What's Changed","text":"<ul> <li>Test coverage fix by @eadwinCode in https://github.com/python-ellar/ellar/pull/144</li> <li>Feat: Lazy Object  by @eadwinCode in https://github.com/python-ellar/ellar/pull/146</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.6...0.5.7</p>"},{"location":"release-notes/#056","title":"0.5.6","text":""},{"location":"release-notes/#whats-changed_22","title":"What's Changed","text":"<ul> <li>fixed file data as bytes by @eadwinCode in https://github.com/python-ellar/ellar/pull/143</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.5...0.5.6</p>"},{"location":"release-notes/#055","title":"0.5.5","text":""},{"location":"release-notes/#whats-changed_23","title":"What's Changed","text":"<ul> <li>fix file and form schema route function by @eadwinCode in https://github.com/python-ellar/ellar/pull/142</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.4...0.5.5</p>"},{"location":"release-notes/#054","title":"0.5.4","text":""},{"location":"release-notes/#whats-changed_24","title":"What's Changed","text":"<ul> <li>Route Function Parameter Aliasing Bug Fix by @eadwinCode in https://github.com/python-ellar/ellar/pull/140</li> <li>file upload openapi doc fix by @eadwinCode in https://github.com/python-ellar/ellar/pull/141</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.3...0.5.4</p>"},{"location":"release-notes/#053","title":"0.5.3","text":""},{"location":"release-notes/#whats-changed_25","title":"What's Changed","text":"<ul> <li>Fixed Auth And Core pkg Dependency by @eadwinCode in https://github.com/python-ellar/ellar/pull/139</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.2...0.5.3</p>"},{"location":"release-notes/#052","title":"0.5.2","text":""},{"location":"release-notes/#whats-changed_26","title":"What's Changed","text":"<ul> <li>Bump ruff from 0.0.275 to 0.1.3 by @dependabot in https://github.com/python-ellar/ellar/pull/135</li> <li>Bump black from 23.9.1 to 23.10.1 by @dependabot in https://github.com/python-ellar/ellar/pull/136</li> <li>Bump types-redis from 4.6.0.5 to 4.6.0.8 by @dependabot in https://github.com/python-ellar/ellar/pull/133</li> <li>Bump mypy from 1.5.1 to 1.6.1 by @dependabot in https://github.com/python-ellar/ellar/pull/134</li> <li>Authentication Docs by @eadwinCode in https://github.com/python-ellar/ellar/pull/137</li> </ul>"},{"location":"release-notes/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>OpenAPI module Refactor by @eadwinCode in https://github.com/python-ellar/ellar/pull/138</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.1...0.5.2</p>"},{"location":"release-notes/#051","title":"0.5.1","text":""},{"location":"release-notes/#whats-changed_27","title":"What's Changed","text":"<ul> <li>Fix grammar error in dynamic-modules.md by @artemyfmv in https://github.com/python-ellar/ellar/pull/132</li> <li>Exception Docs Update by @eadwinCode in https://github.com/python-ellar/ellar/pull/131</li> <li>Bump black from 22.12.0 to 23.9.1 by @dependabot in https://github.com/python-ellar/ellar/pull/129</li> <li>Bump aiohttp from 3.8.4 to 3.8.5 by @dependabot in https://github.com/python-ellar/ellar/pull/113</li> </ul>"},{"location":"release-notes/#new-contributors","title":"New Contributors","text":"<ul> <li>@artemyfmv made their first contribution in https://github.com/python-ellar/ellar/pull/132</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.5.0...0.5.1</p>"},{"location":"release-notes/#050","title":"0.5.0","text":""},{"location":"release-notes/#whats-changed_28","title":"What's Changed","text":"<ul> <li>Bump uvicorn[standard] from 0.22.0 to 0.23.2 by @dependabot in https://github.com/python-ellar/ellar/pull/128</li> <li>Bump types-ujson from 5.8.0.0 to 5.8.0.1 by @dependabot in https://github.com/python-ellar/ellar/pull/127</li> <li>Bump actions/checkout from 3 to 4 by @dependabot in https://github.com/python-ellar/ellar/pull/126</li> <li>Route handlers dependencies type annotation support by @eadwinCode in https://github.com/python-ellar/ellar/pull/130</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.4.9...0.5.0</p>"},{"location":"release-notes/#049","title":"0.4.9","text":""},{"location":"release-notes/#whats-changed_29","title":"What's Changed","text":"<ul> <li>fixed 400 error parsing body on windows by @eadwinCode in https://github.com/python-ellar/ellar/pull/125</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.4.8...0.4.9</p>"},{"location":"release-notes/#047","title":"0.4.7","text":""},{"location":"release-notes/#whats-changed_30","title":"What's Changed","text":"<ul> <li>Libraries Bump up by @eadwinCode in https://github.com/python-ellar/ellar/pull/122</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.4.6...0.4.7</p>"},{"location":"release-notes/#046","title":"0.4.6","text":""},{"location":"release-notes/#whats-changed_31","title":"What's Changed","text":"<ul> <li>drop python 3.7 by @eadwinCode in https://github.com/python-ellar/ellar/pull/118</li> <li>Added scope to provider config by @eadwinCode in https://github.com/python-ellar/ellar/pull/121</li> </ul> <p>Full Changelog: https://github.com/python-ellar/ellar/compare/0.4.5...0.4.6</p>"},{"location":"release-notes/#045","title":"0.4.5","text":""},{"location":"release-notes/#whats-changed_32","title":"What's Changed","text":"<ul> <li>Added auth example by @eadwinCode in https://github.com/eadwinCode/ellar/pull/116</li> <li>MyPy Liniting Fix And Embedded Body by @eadwinCode in https://github.com/eadwinCode/ellar/pull/117</li> <li>Moved authorization guard to interceptor by @eadwinCode in https://github.com/eadwinCode/ellar/pull/117</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.4.4...0.4.5</p>"},{"location":"release-notes/#044","title":"0.4.4","text":""},{"location":"release-notes/#whats-changed_33","title":"What's Changed","text":"<ul> <li>Documentation update by @eadwinCode in https://github.com/eadwinCode/ellar/pull/102</li> <li>OPENAPI Refactor by @eadwinCode in https://github.com/eadwinCode/ellar/pull/103</li> <li>Bump starlette from 0.27.0 to 0.28.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/105</li> <li>Expanding Sessions by @eadwinCode in https://github.com/eadwinCode/ellar/pull/109</li> <li>Authentication and Authorization by @eadwinCode in https://github.com/eadwinCode/ellar/pull/104</li> <li>Bump types-ujson from 5.7.0.5 to 5.8.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/107</li> <li>Ruff linting and mypy upgrade by @eadwinCode in https://github.com/eadwinCode/ellar/pull/115</li> <li>Linting, MyPy Upgrade and Example fixes by @eadwinCode in https://github.com/eadwinCode/ellar/pull/111</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.4.2...0.4.4</p>"},{"location":"release-notes/#042","title":"0.4.2","text":""},{"location":"release-notes/#whats-changed_34","title":"What's Changed","text":"<ul> <li>Bump starlette from 0.26.1 to 0.27.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/97</li> <li>Update typer requirement from &lt;0.8.0,&gt;=0.6.1 to &gt;=0.6.1,&lt;0.10.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/96</li> <li>Bump uvicorn[standard] from 0.20.0 to 0.22.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/95</li> <li>Bump codecov/codecov-action from 3.1.3 to 3.1.4 by @dependabot in https://github.com/eadwinCode/ellar/pull/94</li> <li>Config with prefix by @eadwinCode in https://github.com/eadwinCode/ellar/pull/99</li> <li>Extended Lifespan to Module classes by @eadwinCode in https://github.com/eadwinCode/ellar/pull/100</li> <li>Ellar Documentation Redesign by @eadwinCode in https://github.com/eadwinCode/ellar/pull/100/commits/7b5d60b149b6ad786b6bf682278e6d7fac83fd8e</li> <li>Fixed register_services not calling in modules by @eadwinCode in https://github.com/eadwinCode/ellar/pull/101</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.4.0...0.4.2</p>"},{"location":"release-notes/#040","title":"0.4.0","text":""},{"location":"release-notes/#whats-changed_35","title":"What's Changed","text":"<ul> <li>[BREAKING] Renamed Guards decorator to UseGuards decorator by @eadwinCode in https://github.com/eadwinCode/ellar/pull/93</li> </ul>"},{"location":"release-notes/#new-features","title":"New Features","text":"<ul> <li>Background Task Feature by @eadwinCode in https://github.com/eadwinCode/ellar/pull/91 You can inject BackgroundTasks instance to you route handler</li> </ul> <pre><code>async def send_welcome_email(email):\n    print(f'Send Welcome Email Task Called with \"{email}\"')\n\n@router.post('/signup')\ndef sign_up(username: str, password: str, email: str, tasks: BackgroundTasks):\n    tasks.add_task(send_welcome_email, email=email)\n\n    return {'status': 'Signup successful'}\n</code></pre> <ul> <li>EllarInterceptors by @eadwinCode in https://github.com/eadwinCode/ellar/pull/92 Use of interceptors to add more custom implementation to your route handlers and controller as define by Aspect Oriented Programming (AOP) technique <pre><code>@injectable\nclass ResponseModifierInterceptor(EllarInterceptor):\n    async def intercept(\n        self, context: IExecutionContext, next_interceptor: t.Callable[..., t.Coroutine]\n    ) -&gt; t.Any:\n        data = await next_interceptor()\n        if data:\n            data.update(ResponseModifierInterceptor=\"ResponseModifierInterceptor modified returned resulted\")\n        return data\n\n@Controller(\"\")\nclass InterceptorControllerTest(ControllerBase):\n    @UseInterceptors(ResponseModifierInterceptor)\n    @get(\"/interceptor-1\")\n    async def interceptor_1(self):\n        return {\"message\": \"intercepted okay\"}\n</code></pre></li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.3.8...0.4.0</p>"},{"location":"release-notes/#038","title":"0.3.8","text":""},{"location":"release-notes/#whats-changed_36","title":"What's Changed","text":"<ul> <li>Socket IO integration and Websocket documentation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/82</li> <li>Bump codecov/codecov-action from 3.1.1 to 3.1.3 by @dependabot in https://github.com/eadwinCode/ellar/pull/83</li> <li>Update email-validator requirement from &lt;2.0.0,&gt;=1.1.1 to &gt;=1.1.1,&lt;3.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/84</li> <li>Update mkdocs-material requirement from &lt;9.0.0,&gt;=7.1.9 to &gt;=7.1.9,&lt;10.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/86</li> <li>Bump types-ujson from 5.7.0.1 to 5.7.0.5 by @dependabot in https://github.com/eadwinCode/ellar/pull/88</li> <li>ellar package dependency refactor by @eadwinCode in https://github.com/eadwinCode/ellar/pull/89</li> <li>0.3.8 by @eadwinCode in https://github.com/eadwinCode/ellar/pull/90</li> <li>Breaking: any missing import from <code>ellar.core</code> can be found in <code>ellar.common</code></li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.3.6...0.3.8</p>"},{"location":"release-notes/#036","title":"0.3.6","text":""},{"location":"release-notes/#whats-changed_37","title":"What's Changed","text":"<ul> <li>Added doc on rate limiting by @eadwinCode in https://github.com/eadwinCode/ellar/pull/74</li> <li>Guard Documentation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/64</li> <li>Dynamic Setup Fix by @eadwinCode in https://github.com/eadwinCode/ellar/pull/75</li> <li>Versioning Documentation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/79</li> <li>Update python-multipart requirement from &lt;0.0.6,&gt;=0.0.5 to &gt;=0.0.5,&lt;0.0.7 by @dependabot in https://github.com/eadwinCode/ellar/pull/66</li> <li>Bump types-ujson from 5.7.0.0 to 5.7.0.1 by @dependabot in https://github.com/eadwinCode/ellar/pull/68</li> <li>Testing Documentation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/80</li> <li>Starlette Upgrade by @eadwinCode in https://github.com/eadwinCode/ellar/pull/81</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.3.4...0.3.6</p>"},{"location":"release-notes/#034","title":"0.3.4","text":""},{"location":"release-notes/#whats-changed_38","title":"What's Changed","text":"<ul> <li>Caching Featuring by @eadwinCode in https://github.com/eadwinCode/ellar/pull/65</li> <li>Cache attributes update by @eadwinCode in https://github.com/eadwinCode/ellar/pull/71</li> <li>Module Setup Feature  by @eadwinCode in https://github.com/eadwinCode/ellar/pull/73</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.3.2...0.3.4</p>"},{"location":"release-notes/#032","title":"0.3.2","text":""},{"location":"release-notes/#whats-changed_39","title":"What's Changed","text":"<ul> <li>fix itsdangerous bug in session middleware by @eadwinCode in https://github.com/eadwinCode/ellar/pull/63</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.3.0...0.3.2</p>"},{"location":"release-notes/#030","title":"0.3.0","text":""},{"location":"release-notes/#whats-changed_40","title":"What's Changed","text":"<ul> <li>Bump black from 22.8.0 to 22.12.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/50</li> <li>Bump types-ujson from 0.1.1 to 5.6.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/49</li> <li>Update typer requirement from &lt;0.7.0,&gt;=0.6.1 to &gt;=0.6.1,&lt;0.8.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/40</li> <li>Removed ASGI args from contextvar by @eadwinCode in https://github.com/eadwinCode/ellar/pull/53</li> <li>Document updates Jan 2023 by @eadwinCode in https://github.com/eadwinCode/ellar/pull/54</li> <li>Injectable Class should be resolved at runtime without errors by @eadwinCode in https://github.com/eadwinCode/ellar/pull/60</li> <li>More Doc Updates by @eadwinCode in https://github.com/eadwinCode/ellar/pull/55</li> <li>Guards Refactor by @eadwinCode in https://github.com/eadwinCode/ellar/pull/59</li> <li>restored commented tests by @eadwinCode in https://github.com/eadwinCode/ellar/pull/61</li> <li>Bump starlette from 0.21.0 to 0.23.1 by @dependabot in https://github.com/eadwinCode/ellar/pull/48</li> <li>Bump types-ujson from 5.6.0.0 to 5.7.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/58</li> <li>Bump types-dataclasses from 0.1.7 to 0.6.6 by @dependabot in https://github.com/eadwinCode/ellar/pull/57</li> <li>Update flake8 requirement from &lt;4.0.0,&gt;=3.8.3 to &gt;=3.8.3,&lt;7.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/56</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.2.8...0.3.0</p>"},{"location":"release-notes/#028","title":"0.2.8","text":""},{"location":"release-notes/#whats-changed_41","title":"What's Changed","text":"<ul> <li>Separated <code>IHostContext</code> from <code>IExecutionContext</code> and added factory class that manages their creation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/51</li> <li>Made Guards classes Injectable by @eadwinCode in https://github.com/eadwinCode/ellar/pull/52</li> <li>Switched from <code>thread.local</code> to <code>ContextVar</code> to manage <code>request_scopes</code> properly by @eadwinCode in https://github.com/eadwinCode/ellar/pull/52</li> <li>Added Documentation for <code>ExecutionContext</code>.</li> <li>Increased test coverage.</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.2.6...0.2.8</p>"},{"location":"release-notes/#026","title":"0.2.6","text":""},{"location":"release-notes/#whats-changed_42","title":"What's Changed","text":"<ul> <li>Documentation Updates by @eadwinCode in https://github.com/eadwinCode/ellar/pull/43</li> <li>Reverted building routes from a single list to a list of routers with a well-managed route not found cross routes @eadwinCode in https://github.com/eadwinCode/ellar/pull/43</li> <li>Python 3.11 Support by @eadwinCode in https://github.com/eadwinCode/ellar/pull/44</li> <li>Changed ASCII drawing to the image by @eadwinCode in https://github.com/eadwinCode/ellar/pull/45</li> <li>Added an <code>IExceptionHandler</code> contract for defining custom exception handler by @eadwinCode in https://github.com/eadwinCode/ellar/pull/46. Doc</li> <li>Dropped use for <code>BaseHTTPMiddleware</code> from Starlette and added a <code>FunctionBasedMiddleware</code> by @eadwinCode in https://github.com/eadwinCode/ellar/pull/47</li> <li>Added <code>file</code> decorator for <code>FileResponseModel</code> and <code>StreamingResponseModel</code> by @eadwinCode in https://github.com/eadwinCode/ellar/pull/47</li> </ul> <pre><code>import asyncio\nfrom ellar.common import ModuleRouter, file\n\nasync def slow_numbers(minimum: int, maximum: int):\n    yield (\"&lt;html&gt;&lt;body&gt;&lt;ul&gt;\")\n    for number in range(minimum, maximum + 1):\n        yield \"&lt;li&gt;%d&lt;/li&gt;\" % number\n        await asyncio.sleep(0.01)\n    yield (\"&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\")\n\nrouter = ModuleRouter('/file')\n\n@router.get()\n@file(media_type='text/html')\ndef file_download():\n    return {'path': 'path/to/file.html', 'filename': 'code.html', 'content_disposition_type': 'attachment'}\n\n@router.get('/stream')\n@file(media_type='text/html', streaming=True)\ndef file_stream():\n    return slow_numbers(1, 4)\n</code></pre> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.2.4...0.2.6</p>"},{"location":"release-notes/#024","title":"0.2.4","text":""},{"location":"release-notes/#whats-changed_43","title":"What's Changed","text":"<ul> <li>Update mkdocs-material requirement from &lt;8.0.0,&gt;=7.1.9 to &gt;=7.1.9,&lt;9.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/37</li> <li>Update pytest-cov requirement from &lt;4.0.0,&gt;=2.12.0 to &gt;=2.12.0,&lt;5.0.0 by @dependabot in https://github.com/eadwinCode/ellar/pull/35</li> <li>Pydependencies upgrade by @eadwinCode in https://github.com/eadwinCode/ellar/pull/32</li> <li>Bump types-orjson from 3.6.0 to 3.6.2 by @dependabot in https://github.com/eadwinCode/ellar/pull/34</li> <li>Made CLI tool an optional requirement by @eadwinCode in https://github.com/eadwinCode/ellar/pull/38</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.2.2...0.2.4</p>"},{"location":"release-notes/#022","title":"0.2.2","text":""},{"location":"release-notes/#whats-changed_44","title":"What's Changed","text":"<ul> <li>update readme by @areski in https://github.com/eadwinCode/ellar/pull/30</li> <li>Cli help command fix by @eadwinCode in https://github.com/eadwinCode/ellar/pull/31</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.2.0...0.2.2</p>"},{"location":"release-notes/#020","title":"0.2.0","text":""},{"location":"release-notes/#whats-changed_45","title":"What's Changed","text":"<ul> <li>Project dependency fix by @eadwinCode in https://github.com/eadwinCode/ellar/pull/29</li> <li>Python 3.6 support ends here</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.1.8...0.2.0</p>"},{"location":"release-notes/#018","title":"0.1.8","text":""},{"location":"release-notes/#whats-changed_46","title":"What's Changed","text":"<ul> <li>starlette dependencies fix by @eadwinCode in https://github.com/eadwinCode/ellar/pull/28</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.1.6...0.1.8</p>"},{"location":"release-notes/#016","title":"0.1.6","text":""},{"location":"release-notes/#whats-changed_47","title":"What's Changed","text":"<ul> <li>package stats update by @eadwinCode in https://github.com/eadwinCode/ellar/pull/17</li> <li>fixed static package type by @eadwinCode in https://github.com/eadwinCode/ellar/pull/18</li> <li>Doc Preparation by @eadwinCode in https://github.com/eadwinCode/ellar/pull/19</li> <li>Moved Configuration From File To Class Based by @eadwinCode in https://github.com/eadwinCode/ellar/pull/21</li> <li>Bump codecov/codecov-action from 3.1.0 to 3.1.1 by @dependabot in https://github.com/eadwinCode/ellar/pull/25</li> <li>CLI Commands And Basic Project Scaffolding by @eadwinCode in https://github.com/eadwinCode/ellar/pull/20</li> <li>Quick-Start Doc by @eadwinCode in https://github.com/eadwinCode/ellar/pull/27</li> </ul>"},{"location":"release-notes/#cli-commands","title":"CLI Commands","text":"<p>To scaffold ellar project <pre><code>ellar create-project `project-name`\n</code></pre> To scaffold ellar app <pre><code>ellar create-module `app-name`\n</code></pre> To start application server <pre><code>ellar runserver\n</code></pre></p> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.1.4...0.1.6</p>"},{"location":"release-notes/#014","title":"0.1.4","text":""},{"location":"release-notes/#whats-changed_48","title":"What's Changed","text":"<ul> <li>Bump actions/setup-python from 3 to 4 by @dependabot in https://github.com/eadwinCode/ellar/pull/8</li> <li>Starlette Class Renames by @eadwinCode in https://github.com/eadwinCode/ellar/pull/9</li> <li>Common Package Testing by @eadwinCode in https://github.com/eadwinCode/ellar/pull/10</li> <li>Constant Value All Caps by @eadwinCode in https://github.com/eadwinCode/ellar/pull/11</li> <li>Openapi Module Test by @eadwinCode in https://github.com/eadwinCode/ellar/pull/12</li> <li>Guard Module Testing by @eadwinCode in https://github.com/eadwinCode/ellar/pull/13</li> <li>Configuration Module Test by @eadwinCode in https://github.com/eadwinCode/ellar/pull/14</li> <li>App Test by @eadwinCode in https://github.com/eadwinCode/ellar/pull/15</li> <li>AppFactory and TestClientFactory Test by @eadwinCode in https://github.com/eadwinCode/ellar/pull/16</li> </ul> <p>Full Changelog: https://github.com/eadwinCode/ellar/compare/0.1.2...0.1.4</p>"},{"location":"release-notes/#version-012","title":"Version 0.1.2","text":""},{"location":"release-notes/#whats-changed_49","title":"What's Changed","text":"<ul> <li>Refactored route operation functions @eadwinCode in https://github.com/eadwinCode/ellar/pull/7</li> </ul>"},{"location":"release-notes/#version-010","title":"Version 0.1.0","text":""},{"location":"release-notes/#first-release","title":"First Release","text":"<ul> <li>Pydantic integration</li> <li>DI Container</li> <li>Templating with Jinja2</li> <li>OpenAPI Documentation (Swagger and ReDoc)</li> <li>Controller (MVC)</li> <li>Guards (Authentications, roles and permissions)</li> <li>Modularization (eg: flask blueprint)</li> <li>Websocket support</li> <li>Session and Cookie support</li> <li>CORS, GZip, Static Files, Streaming responses</li> <li>Test client built on requests</li> <li>In-process background tasks.</li> <li>Startup and shutdown events.</li> <li>Application Events</li> </ul>"},{"location":"release-notes/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@eadwinCode made their first contribution in https://github.com/eadwinCode/ellar/pull/6</li> </ul>"},{"location":"basics/api-docs/","title":"Api docs","text":""},{"location":"basics/api-docs/#coming-soon","title":"Coming Soon","text":""},{"location":"basics/application-context/","title":"Injector Context","text":"<p>In the complex web of dependencies within Ellar,  accessing the application instance without triggering circular import errors can be a daunting task. </p> <p>To address this challenge, Ellar introduces the concept of an injector context,  a powerful mechanism that facilitates smooth access to the application instance throughout various parts of the codebase.</p>"},{"location":"basics/application-context/#understanding-the-injector-context","title":"Understanding the Injector Context","text":"<p>The Injector context serves as a bridge between different components of the application, making the application object  readily available through the application Dependency Injection (DI) container. This ensures that you can access the  application instance without encountering import issues, whether it's during request handling, execution of CLI commands,  or manual invocation of the context.</p> <p>Two key elements of the application context are:</p> <ul> <li>current_injector: This proxy variable refers to the current application injector, providing access to any service or the application instance itself.</li> <li>current_config: A lazy loader for application configuration, which is based on the <code>ELLAR_CONFIG_MODULE</code> reference or accessed through <code>application.config</code> when the application context is active.</li> </ul>"},{"location":"basics/application-context/#integration-with-click-commands","title":"Integration with Click Commands","text":"<p>By decorating Click commands with <code>click.with_app_context</code>, you can effortlessly incorporate the application context  into their CLI workflows. This allows them to leverage the full power of the application context when executing commands.</p> <p>For instance, consider the following example:</p> <pre><code>import ellar_cli.click as click\nfrom ellar.core import current_injector\nfrom ellar.di import injectable\n\n@injectable\nclass MyService:\n    def do_something(self) -&gt; None:\n        pass\n\n@click.command()\n@click.argument('name')\n@click.with_injector_context\ndef my_command(name: str):\n    my_service = current_injector.get(MyService)\n    my_service.do_something()\n</code></pre> <p>Here, the <code>click.with_app_context</code> decorator ensures that the application context is available within the <code>my_command</code> function,  allowing seamless access to application resources.</p>"},{"location":"basics/application-context/#lifecycle-of-the-application-context","title":"Lifecycle of the Application Context","text":"<p>The application context operates as an asynchronous context manager, automatically created at  the beginning of request handling and gracefully torn down upon completion of the request. </p>"},{"location":"basics/application-context/#handling-application-context-events","title":"Handling Application Context Events","text":"<p>Additionally, the application context offers event hooks that you can leverage to perform custom actions at  specific points in the context's lifecycle. </p> <p>Two such events are <code>app_context_started</code> and <code>app_context_teardown</code>,  which are triggered at the beginning and end of the context, respectively.</p> <p>For example, consider the following event handling setup:</p> <pre><code>from ellar.events import app_context_teardown, app_context_started\nfrom ellar.app import App, AppFactory\nfrom ellar.core import current_injector, injector_context\nfrom ellar.threading import run_as_sync\n\n@app_context_started.connect\nasync def on_context_started():\n    print('=======&gt; Context Started &lt;=======')\n\n@app_context_teardown.connect\ndef on_context_ended():\n    print('=======&gt; Context ended &lt;=========')\n\napp = AppFactory.create_app()\n\n@run_as_sync\nasync def run_app_context():\n    async with injector_context(app.injector) as ctx:\n        print(\"-----&gt; Context is now available &lt;------\")\n\n        app_instance = ctx.injector.get(App)\n        app_instance_2 = current_injector.get(App)\n\n        assert app_instance == app == app_instance_2\n    print(\"-----&gt; Context is now destroyed &lt;------\")\n\nif __name__ == '__main__':\n    run_app_context()\n</code></pre> <p>In this example, event handlers are registered to execute custom logic when the application context starts and ends.  This allows you to perform initialization or cleanup tasks as needed.</p>"},{"location":"basics/dynamic-modules/","title":"Dynamic Modules","text":"<p>We have seen in many examples given on how to statically configure a module.  In this section, we are going to look at different ways to dynamically set up a module.</p> <p>Why is this important? Consider a scenario where a general-purpose module needs to behave differently in different use cases,  it may be useful to use a configuration-based approach to allow customization. This is similar to the concept of a \"plugin\" in many systems,  where a generic facility requires some configuration before it can be used by a consumer.</p>"},{"location":"basics/dynamic-modules/#module-dynamic-setup","title":"Module Dynamic Setup","text":"<p>To dynamically configure a module, the module should inherit from <code>IModuleSetup</code> and provide a <code>setup</code> method or <code>setup_register</code> method that performs the necessary actions for setting up the module and then returns a <code>DynamicModule</code> or <code>ModuleSetup</code> instance.</p> <pre><code>import typing as t\nfrom ellar.core.modules import DynamicModule, ModuleSetup\n\nclass IModuleSetup:\n    \"\"\"Modules that must have a custom setup should inherit from IModuleSetup\"\"\"\n\n    @classmethod\n    def setup(cls, *args: t.Any, **kwargs: t.Any) -&gt; DynamicModule:\n        pass\n\n    @classmethod\n    def register_setup(cls, *args: t.Any, **kwargs: t.Any) -&gt; ModuleSetup:\n        pass\n</code></pre> <p>Note that <code>setup</code> method returns a <code>DynamicModule</code> instance, while <code>register_setup</code> method returns a <code>ModuleSetup</code> instance.  The <code>DynamicModule</code> instance is used when the module requires some configuration before it can be used by a consumer,  while the <code>ModuleSetup</code> instance is used when the module does not require any additional configuration outside the ones provided in the application config.</p>"},{"location":"basics/dynamic-modules/#dynamicmodule","title":"DynamicModule","text":"<p><code>DynamicModule</code> is a dataclass type that is used to override <code>Module</code> decorated attributes without having to modify the module code directly. In other words, it gives you the flexibility to reconfigure module.</p> <p>For example, Let's look at the code below: <pre><code>from ellar.common import Module\nfrom ellar.core import DynamicModule\nfrom ellar.di import ProviderConfig\n\n@Module(providers=[ServiceA, ServiceB])\nclass ModuleA:\n    pass\n\n# we can reconfigure ModuleA dynamically using `DynamicModule` as shown below\n\n@Module(\n    modules=[\n        DynamicModule(\n            ModuleA, \n            providers=[\n                ProviderConfig(ServiceA, use_class=str),\n                ProviderConfig(ServiceB, use_class=dict),\n            ]\n        )\n    ]\n)\nclass ApplicationModule:\n    pass\n</code></pre> <code>ModuleA</code> has been defined with some arbitrary providers (<code>ServiceA</code> and <code>ServiceB</code>), but during registration of <code>ModuleA</code> in <code>ApplicationModule</code>, we used <code>DynamicModule</code> to override its Module attribute <code>providers</code> with a new set of data.</p>"},{"location":"basics/dynamic-modules/#modulesetup","title":"ModuleSetup","text":"<p>ModuleSetup is a dataclass type that used to set up a module based on its dependencies.  It allows you to define the module dependencies and allow a callback factory function for a module dynamic set up.</p> <p><code>ModuleSetup</code> Properties:</p> <ul> <li><code>module</code>: a required property that defines the type of module to be configured. The value must be a subclass of ModuleBase or IModuleSetup.</li> <li><code>inject</code>: a sequence property that holds the types to be injected to the factory method. The order of the types will determine the order at which they are injected.</li> <li><code>factory</code>: a factory function used to configure the module and take <code>Module</code> type as first argument and other services as listed in <code>inject</code> attribute.</li> </ul> <p>Let's look this <code>ModuleSetup</code> example code below with our focus on how we eventually configured <code>DynamicService</code> type,  how we used <code>my_module_configuration_factory</code> to dynamically build <code>MyModule</code> module.</p> <p><pre><code>import typing as t\nfrom ellar.common import Module, IModuleSetup\nfrom ellar.di import ProviderConfig\nfrom ellar.core import DynamicModule, ModuleBase, Config, ModuleSetup\nfrom ellar.app import AppFactory\n\n\nclass Foo:\n    def __init__(self):\n        self.foo = 'foo'\n\n\nclass DynamicService:\n    def __init__(self, param1: t.Any, param2: t.Any, foo: str):\n        self.param1 = param1\n        self.param2 = param2\n        self.foo = foo\n\n\n@Module()\nclass MyModule(ModuleBase, IModuleSetup):\n    @classmethod\n    def setup(cls, param1: t.Any, param2: t.Any, foo: Foo) -&gt; DynamicModule:\n        return DynamicModule(\n            cls,\n            providers=[ProviderConfig(DynamicService, use_value=DynamicService(param1, param2, foo.foo))],\n        )\n\n\ndef my_module_configuration_factory(module: t.Type[MyModule], config: Config, foo: Foo):\n    return module.setup(param1=config.param1, param2=config.param2, foo=foo)\n\n\n@Module(modules=[ModuleSetup(MyModule, inject=[Config, Foo], factory=my_module_configuration_factory),], providers=[Foo])\nclass ApplicationModule(ModuleBase):\n    pass\n\n\napp = AppFactory.create_from_app_module(ApplicationModule, config_module=dict(\n    param1=\"param1\",\n    param2=\"param2\",\n))\n\ndynamic_service = app.injector.get(DynamicService)\n\nassert dynamic_service.param1 == \"param1\"\nassert dynamic_service.param2 == \"param2\"\nassert dynamic_service.foo == \"foo\"\n</code></pre> In the example, we started by defining a service <code>DynamicService</code>, whose parameter depended on some values from application config and from another service <code>Foo</code>. We then set up a <code>MyModule</code> and used as setup method which takes all parameter needed by  <code>DynamicService</code> after that, we created <code>DynamicService</code> as a singleton and registered as a provider in <code>MyModule</code>  for it to be accessible and injectable. </p> <p>At this point, looking at the setup function of <code>MyModule</code>, its clear <code>MyModule</code> depends on <code>Config</code> and <code>Foo</code> service. And this is where <code>ModuleSetup</code> usefulness comes in.</p> <p>During registration in <code>ApplicationModule</code>, we wrapped <code>MyModule</code> around a <code>ModuleSetup</code> and stated its dependencies in the <code>inject</code> property and also provided a <code>my_module_configuration_factory</code> factory that takes in module dependencies and return a <code>DynamicModule</code> configuration of <code>MyModule</code>.  </p> <p>When <code>AppFactory</code> starts module bootstrapping, <code>my_module_configuration_factory</code> will be called with  all the required parameters and returned a <code>DynamicModule</code> of <code>MyModule</code>.</p> <p>For more example, checkout Ellar Throttle Module or Ellar Cache Module</p>"},{"location":"basics/dynamic-modules/#lazy-loading-modules","title":"Lazy Loading Modules","text":"<p>Ellar supports loading module decorated classes through a string reference using <code>LazyModuleImport</code>. For a better application context availability usage in module like, <code>current_config</code>, <code>current_app</code> and <code>current_injector</code>, it's advised to go with lazy module import.</p> <p>For example, we can lazy load <code>CarModule</code> from our example here into <code>ApplicationModule</code></p> project_name/root_module.py<pre><code>from ellar.common import IExecutionContext, Module, exception_handler\nfrom ellar.common.responses import JSONResponse, Response\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\nfrom ellar.samples.modules import HomeModule\n\n\n@Module(modules=[HomeModule, lazyLoad('apps.car.module:CarModule')])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre> <p>In the above illustration, we provided a string reference to <code>CarModule</code> into <code>LazyModuleImport</code> instance. And during <code>AppFactory</code> Module bootstrap, <code>CarModule</code> will be resolved, validated and registered into the application</p>"},{"location":"basics/dynamic-modules/#properties","title":"Properties","text":"<p><code>LazyModuleImport</code> attributes,</p> <ul> <li><code>module</code>: String reference for Module import</li> <li><code>setup</code>: Module setup function name for modules that requires specific function as in case of <code>DynamicModule</code> and <code>ModuleSetup</code>.</li> <li><code>setup_options</code>: Module setup function parameters</li> </ul>"},{"location":"basics/dynamic-modules/#lazy-loading-dynamicmodules","title":"Lazy Loading DynamicModules","text":"<p>Having the understanding of <code>DynamicModule</code> and its registration pattern, to lazy load DynamicModule follows the same pattern.</p> <p>For example, lets lazy load <code>MyModule</code> as a <code>DynamicModule</code>. For that to happen, we need to call <code>MyModule.setup</code> with some parameters and in turn returns a <code>DynamicModule</code></p> project_name/root_module.py<pre><code>from ellar.common import Module, exception_handler, JSONResponse, IExecutionContext, Response\nfrom ellar.core import ModuleBase\nfrom .custom_module import MyModule, Foo\n\n\n@Module(modules=[MyModule.setup(12, 23, Foo())])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre> <p>Let's rewrite this using <code>LazyModuleImport</code>.</p> project_name/root_module.py<pre><code>from ellar.common import Module, exception_handler, JSONResponse, IExecutionContext, Response\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\n\n\n@Module(modules=[\n    lazyLoad('project_name.custom_module:MyModule', 'setup', param1=12, param2=23, foo=Foo()), \n])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre>"},{"location":"basics/dynamic-modules/#lazy-loading-modulesetup","title":"Lazy Loading ModuleSetup","text":"<p>Just as in <code>DynamicModule</code>, <code>ModuleSetup</code> can be lazy loaded the same way.  Let's take CacheModule for example.</p> <p>project_name/root_module.py<pre><code>from ellar.common import Module, exception_handler, JSONResponse, IExecutionContext, Response\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\n\n\n@Module(modules=[\n    lazyLoad('ellar.cache.module:CacheModule', 'register_setup'), \n])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre> In the above illustration, we have registered <code>CacheModule</code> through <code>register_setup</code> function  which returns a <code>ModuleSetup</code> that configures the <code>CacheModule</code> to read its configurations from application config.</p>"},{"location":"basics/execution-context/","title":"Execution Context","text":"<p>Execution context refers to the current context of execution, or the environment in which a specific piece of code is running.  It contains information about the current request, the current response in the case of http connection, and the current state of the application.</p> <p>The execution context is created automatically when a request is received, and it is passed along through the various layers of the application as the request is handled.  This allows different components of the application like exception handlers, functional middlewares and guards to access information about the current request.</p> <p>There are two class <code>HostContext</code> and <code>ExecutionContext</code> which provides set of methods and properties for accessing and manipulating the current context of execution.</p>"},{"location":"basics/execution-context/#hostcontext","title":"HostContext","text":"<p>The <code>HostContext</code> class provides a wrapper around <code>ASGI</code> app parameters (<code>scope</code>, <code>receive</code> and <code>send</code>) and provides some methods that allows you choosing the appropriate context(e.g., HTTP or WebSockets).</p> <p>For example, the <code>catch()</code> method of an exception handlers is called with an IHostContext.</p> <pre><code># project_name/apps/custom_exceptions.py\nimport typing as t\nfrom ellar.common import IExceptionHandler, IHostContext, Response\n\nclass MyCustomException(Exception):\n    pass\n\n\nclass MyCustomExceptionHandler(IExceptionHandler):\n    exception_type_or_code = MyCustomException\n\n    async def catch(\n        self, ctx: IHostContext, exc: MyCustomException\n    ) -&gt; t.Union[Response, t.Any]:\n\n        if ctx.get_type() == 'http':\n            # do something that is only important in the context of regular HTTP requests (REST)\n            pass\n        elif  ctx.get_type() == 'websocket':\n            # do something that is only important in the context of regular Websocket\n            pass\n\n        app_config = ctx.get_app().config\n        return app_config.DEFAULT_JSON_CLASS(\n            {'detail': str(exc)}, status_code=400,\n        )\n</code></pre>"},{"location":"basics/execution-context/#switching-to-other-contexts","title":"Switching to other Contexts","text":"<p>Currently, in Ellar you can only switch between <code>http</code> and <code>websocket</code> context. And each context has <code>get_client</code> method that returns context session.</p> <pre><code>    async def catch(\n        self, ctx: IHostContext, exc: MyCustomException\n    ) -&gt; t.Union[Response, t.Any]:\n\n        if ctx.get_type() == 'http':\n            # do something that is only important in the context of regular HTTP requests (REST)\n            http_context = ctx.switch_to_http_connection()\n            request: Request = http_context.get_request()\n            response: Response = http_context.get_response()\n            http_connection: HTTPConnection = http_context.get_client()\n\n        elif  ctx.get_type() == 'websocket':\n            # do something that is only important in the context of regular Websocket\n            websocket_context = ctx.switch_to_websocket()\n            websocket_session: WebSocket = websocket_context.get_client()\n\n        app_config = ctx.get_app().config\n        return app_config.DEFAULT_JSON_CLASS(\n            {'detail': str(exc)}, status_code=400,\n        )\n</code></pre> <p>Info</p> <p>Its good to note that you can't switch to a context that does not match the current context type.  Always use the <code>.get_type()</code> to verify the type before switching.</p>"},{"location":"basics/execution-context/#ihostcontext-properties","title":"IHostContext Properties","text":"<p>Important properties of <code>HostContext</code></p> <ul> <li><code>get_service_provider</code>: returns current service provider using in handling the request</li> <li><code>get_app</code>: returns current application instance</li> <li><code>get_type</code>: gets scope type <code>http</code>, <code>websocket</code> </li> <li><code>get_args</code>: returns <code>scope</code>, <code>receive</code> and <code>send</code> ASGI parameters</li> <li><code>switch_to_http_connection</code>: returns <code>HTTPConnectionHost</code> instance</li> <li><code>switch_to_websocket</code>: returns <code>WebSocketConnectionHost</code> instance</li> </ul> <pre><code>class IHostContext(ABC):\n    @abstractmethod\n    def get_service_provider(self) -&gt; \"RequestServiceProvider\":\n        \"\"\"Gets  RequestServiceProvider instance\"\"\"\n\n    @abstractmethod\n    def switch_to_http_connection(self) -&gt; IHTTPConnectionHost:\n        \"\"\"Returns HTTPConnection instance\"\"\"\n\n    @abstractmethod\n    def switch_to_websocket(self) -&gt; IWebSocketConnectionHost:\n        \"\"\"Returns WebSocket instance\"\"\"\n\n    @abstractmethod\n    def get_app(self) -&gt; \"App\":\n        \"\"\"Gets application instance\"\"\"\n\n    @abstractmethod\n    def get_type(self) -&gt; str:\n        \"\"\"returns scope type\"\"\"\n\n    @abstractmethod\n    def get_args(self) -&gt; t.Tuple[TScope, TReceive, TSend]:\n        \"\"\"returns all args passed to asgi function\"\"\"\n</code></pre> <p><code>IHTTPConnectionHost</code> and <code>IWebSocketConnectionHost</code> has some methods that maybe of interest.</p> <p>Here are methods for <code>IHTTPConnectionHost</code>:</p> <pre><code>class IHTTPConnectionHost(ABC):\n    @abstractmethod\n    def get_response(self) -&gt; Response:\n        \"\"\"Gets response\"\"\"\n\n    @abstractmethod\n    def get_request(self) -&gt; Request:\n        \"\"\"Returns Request instance\"\"\"\n\n    @abstractmethod\n    def get_client(self) -&gt; HTTPConnection:\n        \"\"\"Returns HTTPConnection instance\"\"\"\n</code></pre> <p>Following are the methods for <code>IWebSocketConnectionHost</code>:</p> <pre><code>class IWebSocketConnectionHost(ABC):\n    @abstractmethod\n    def get_client(self) -&gt; WebSocket:\n        \"\"\"Returns WebSocket instance\"\"\"\n</code></pre>"},{"location":"basics/execution-context/#executioncontext-class","title":"ExecutionContext Class","text":"<p><code>ExecutionContext</code> extends <code>HostContext</code> and provides extra information like <code>Controller</code> class and controller <code>function</code>  that will handler the current request.</p> <pre><code>import typing\nfrom ellar.common import ControllerBase\nfrom ellar.core import HostContext\n\n\nclass ExecutionContext(HostContext):\n    # Returns the type of the controller class which the current handler belongs to.\n    def get_class(self) -&gt; typing.Type[ControllerBase]:\n        pass\n\n    # Returns a reference to the handler (method) that will be handler the current request.\n    def get_handler(self) -&gt; typing.Callable:\n        pass\n</code></pre> <p>These extra information are necessary for reading <code>metadata</code> properties set on controllers or the route handler function.</p>"},{"location":"basics/execution-context/#how-to-access-the-current-execution-context","title":"How to access the current execution context","text":"<p>You can access the current execution context using the <code>Inject[ExecutionContext]</code> annotation.  This decorator can be applied to a parameter of a controller or service method,  and it will inject the current <code>ExecutionContext</code> object into the method.</p> <p>For example, consider the following controller method: <pre><code>from ellar.common import get, Controller, IExecutionContext, Inject\n\n@Controller('/users')\nclass UserController:\n    @get('/{user_id}')\n    async def get_user(self, user_id: str, ctx:Inject[IExecutionContext]):\n        # Use the ctx object to access the current execution context\n        res = ctx.switch_to_http_connection().get_response()\n        res.status_code = 200\n        res.body = f\"Request to get user with id={user_id}\".encode(\"utf-8\")\n        scope, receive, send = ctx.get_args()\n        await res(scope, receive, send) # sends response\n</code></pre></p> <p>In this example, the <code>get_user</code> method is decorated with the <code>@get</code> decorator to handle a GET request to the /users/:id route.  The <code>Inject[ExecutionContext]</code> annotation is applied to the second parameter of the method, which will inject the current <code>ExecutionContext</code> object into the method.</p> <p>Once you have access to the <code>ExecutionContext</code> object, you can use its methods and properties to access information about the current request.</p>"},{"location":"basics/execution-context/#reflector-and-metadata","title":"Reflector and Metadata","text":"<p>Ellar provides the ability to attach custom metadata to route handlers through the <code>@set_metadata()</code> decorator.  We can then access this metadata from within our class to make certain decisions.</p> <pre><code># project_name/apps/cars/controllers.py\n\nfrom ellar.common import Body, Controller, post, set_metadata, ControllerBase\nfrom .schemas import CreateCarSerializer\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @post()\n    @set_metadata('role', ['admin'])\n    async def create(self, payload: CreateCarSerializer = Body()):\n        result = payload.dict()\n        result.update(message='This action adds a new car')\n        return result\n</code></pre> <p>With the construction above, we attached the <code>roles</code> metadata (roles is a metadata key and ['admin'] is the associated value)  to the <code>create()</code> method. While this works, it's not good practice to use <code>@set_metadata()</code> directly in your routes.  Instead, create your own decorators, as shown below:</p> <pre><code># project_name/apps/cars/controllers.py\nimport typing\nfrom ellar.common import Body, Controller, post, set_metadata, ControllerBase\nfrom .schemas import CreateCarSerializer\n\n\ndef roles(*_roles: str) -&gt; typing.Callable:\n    return set_metadata('roles', list(_roles))\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @post()\n    @roles('admin', 'is_staff')\n    async def create(self, payload: CreateCarSerializer = Body()):\n        result = payload.dict()\n        result.update(message='This action adds a new car')\n        return result\n</code></pre> <p>Info</p> <p>It's important to note that <code>ExecutionContext</code> becomes available when there is route handler found to handle the current request.</p> <p>To access the route's role(s) (custom metadata), we'll use the <code>Reflector</code> helper class, which is provided out of the box by the framework.  <code>Reflector</code> can be injected into a class in the normal way:</p> <pre><code># project_name/apps/cars/guards.py\nfrom ellar.di import injectable\nfrom ellar.common import GuardCanActivate, IExecutionContext\nfrom ellar.core.services import Reflector\n\n\n@injectable()\nclass RoleGuard(GuardCanActivate):\n    def __init__(self, reflector: Reflector):\n        self.reflector = reflector\n\n    async def can_activate(self, context: IExecutionContext) -&gt; bool:\n        roles = self.reflector.get('roles', context.get_handler())\n        # request = context.switch_to_http_connection().get_request()\n        # check if user in request object has role\n        if not roles:\n            return True\n        return 'user' in roles\n</code></pre> <p>Next, we apply the <code>RoleGuard</code> to <code>CarController</code></p> <pre><code># project_name/apps/cars/controllers.py\nimport typing\nfrom ellar.common import Body, Controller, post, set_metadata, UseGuards, ControllerBase\nfrom .schemas import CreateCarSerializer\nfrom .guards import RoleGuard\n\ndef roles(*_roles: str) -&gt; typing.Callable:\n    return set_metadata('roles', list(_roles))\n\n\n@Controller('/car')\n@UseGuards(RoleGuard)\nclass CarController(ControllerBase):\n    @post()\n    @roles('admin', 'is_staff')\n    async def create(self, payload: CreateCarSerializer = Body()):\n        result = payload.dict()\n        result.update(message='This action adds a new car')\n        return result\n</code></pre> <p>Also, since <code>RoleGuard</code> is marked as <code>injectable</code>, EllarInjector service will be able to resolve <code>RoleGuard</code> without <code>RoleGuard</code> registered as a provider.</p>"},{"location":"basics/injector-scopes/","title":"Injector Scopes","text":"<p>There are 3 different scopes which defines ways a service/provider is instantiated.</p> <ul> <li>TRANSIENT SCOPE</li> <li>SINGLETON SCOPE</li> <li>REQUEST SCOPE</li> </ul>"},{"location":"basics/injector-scopes/#transient_scope","title":"<code>transient_scope</code>:","text":"<p>Whenever a transient scoped provider is required, a new instance of the provider is created</p> <pre><code># main.py\n\nfrom ellar.di import EllarInjector, transient_scope, injectable\n\ninjector = EllarInjector(auto_bind=False)\n\n\n@injectable(scope=transient_scope)\nclass ATransientClass:\n    pass\n\ninjector.container.register(ATransientClass)\n# OR\n# injector.container.register_transient(ATransientClass)\n\ndef validate_transient_scope():\n    a_transient_instance_1 = injector.get(ATransientClass)\n    a_transient_instance_2 = injector.get(ATransientClass)\n\n    assert a_transient_instance_2 != a_transient_instance_1 # True\n\n\nif __name__ == \"__main__\":\n    validate_transient_scope()\n</code></pre>"},{"location":"basics/injector-scopes/#singleton_scope","title":"<code>singleton_scope</code>:","text":"<p>A singleton scoped provider is created once throughout the lifespan of the Container instance.</p> <p>For example: <pre><code># main.py\n\nfrom ellar.di import EllarInjector, singleton_scope, injectable\n\ninjector = EllarInjector(auto_bind=False)\n# OR\n\n@injectable(scope=singleton_scope)\nclass ASingletonClass:\n    pass\n\ninjector.container.register(ASingletonClass)\n# OR\n# injector.container.register_singleton(ASingletonClass)\n\ndef validate_singleton_scope():\n    a_singleton_instance_1 = injector.get(ASingletonClass)\n    a_singleton_instance_2 = injector.get(ASingletonClass)\n\n    assert a_singleton_instance_2 == a_singleton_instance_1 # True\n\nif __name__ == \"__main__\":\n    validate_singleton_scope()\n</code></pre></p>"},{"location":"basics/injector-scopes/#request_scope","title":"<code>request_scope</code>:","text":"<p>A request scoped provider is instantiated once during the scope of the request. And it's destroyed once the request is complete. It is important to note that <code>request_scope</code> behaves like a <code>singleton_scope</code> during HTTPConnection mode and behaves like a <code>transient_scope</code> outside HTTPConnection mode.</p> <pre><code># main.py\n\nimport uvicorn\nfrom ellar.di import EllarInjector, request_scope, injectable\n\ninjector = EllarInjector(auto_bind=False)\n\n\n@injectable(scope=request_scope)\nclass ARequestScopeClass:\n    pass\n\n\ninjector.container.register(ARequestScopeClass)\n\n\nasync def scoped_request(scope, receive, send):\n    async with injector.create_asgi_args(scope, receive, send) as request_injector:\n        request_instance_1 = request_injector.get(ARequestScopeClass)\n        request_instance_2 = request_injector.get(ARequestScopeClass)\n        assert request_instance_2 == request_instance_1\n\n    request_instance_1 = injector.get(ARequestScopeClass)\n    request_instance_2 = injector.get(ARequestScopeClass)\n\n    assert request_instance_2 != request_instance_1\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:scoped_request\", port=5000, log_level=\"info\")\n</code></pre>"},{"location":"basics/lifespan/","title":"Lifespan","text":"<p>Ellar applications registers a lifespan manager. The manager handles lifespan handler registered in the configuration under the variable name <code>DEFAULT_LIFESPAN_HANDLER</code> and also executes code that needs to run before the application starts up, or when the application is shutting down.  The lifespan manager must be run before ellar starts serving incoming request.</p> <p><pre><code>import uvicorn\nimport contextlib\nfrom ellar.app import App, AppFactory\n\n@contextlib.asynccontextmanager\nasync def some_async_resource():\n    print(\"running some-async-resource function\")\n    yield \n    print(\"existing some-async-resource function\")\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(app: App):\n    async with some_async_resource():\n        print(\"Run at startup!\")\n        yield\n        print(\"Run on shutdown!\")\n\n\napplication = AppFactory.create_app(config_module=dict(\n    DEFAULT_LIFESPAN_HANDLER=lifespan\n))\n\nif __name__ == \"__main__\":\n    uvicorn.run(application, port=5000, log_level=\"info\")\n</code></pre> The construct above will generate the output below: <pre><code>INFO:     Started server process [11772]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:5000 (Press CTRL+C to quit)\n\nrunning some-async-resource function\nRun at startup!\n\nINFO:     Shutting down\nINFO:     Waiting for application shutdown.\nINFO:     Application shutdown complete.\nINFO:     Finished server process [11772]\n\nRun on shutdown!\nexisting some-async-resource function\n</code></pre></p>"},{"location":"basics/lifespan/#modules-and-lifespan","title":"Modules and Lifespan","text":"<p>Any module that wants to engage in application lifespan must inherit <code>IApplicationStartup</code> for startup actions or <code>IApplicationShutdown</code> for shutdown actions  or inherit both for startup and shutdown actions. </p> <p><code>IApplicationStartup</code> has an abstractmethod <code>on_startup</code> function and <code>IApplicationShutdown</code> has an abstractmethod <code>on_shutdown</code> function.</p> <p><pre><code>from abc import abstractmethod\n\n\nclass IApplicationStartup:\n    @abstractmethod\n    async def on_startup(self, app: \"App\") -&gt; None:\n        ...\n\n\nclass IApplicationShutdown:\n    @abstractmethod\n    async def on_shutdown(self) -&gt; None:\n        ...\n</code></pre> Let's assume we have a module that extends both <code>IApplicationStartup</code> and <code>IApplicationShutdown</code> to execute some actions on startup and on shutdown as shown below:</p> <pre><code>from ellar.common import IApplicationShutdown, IApplicationStartup, Module\n\n@Module()\nclass SampleModule(IApplicationShutdown, IApplicationStartup):\n\n    async def on_startup(self, app) -&gt; None:\n        print(\"Run at startup! in SampleModule\")\n\n    async def on_shutdown(self) -&gt; None:\n        print(\"Run on shutdown! in SampleModule\")\n</code></pre>"},{"location":"basics/lifespan/#running-lifespan-in-tests","title":"Running lifespan in tests","text":"<p>You should use <code>TestClient</code> as a context manager, to ensure that the lifespan is called.</p> <pre><code>from ellar.testing import Test\nfrom .main import SampleModule\n\ntest_module = Test.create_test_module(modules=[SampleModule])\n\ndef test_lifespan():\n    with test_module.get_test_client() as client:\n        # Application's lifespan is called on entering the block.\n        response = client.get(\"/\")\n        assert response.status_code == 200\n\n    # And the lifespan's teardown is run when exiting the block.\n</code></pre>"},{"location":"basics/testing/","title":"Testing","text":"<p>Automated testing is the practice of using software tools to automatically run tests on a software application or system,  rather than relying on manual testing by humans. It is considered an essential part of software development as it  helps increase productivity, ensure quality and performance goals are met, and provide faster feedback loops to developers.  Automated tests can include various types such as unit tests, integration tests, end-to-end tests, and more. </p> <p>While setting up automated tests can be tedious, the benefits of increased test coverage and productivity make it an important aspect of software development. Ellar aims to encourage the use of development best practices, including effective testing, by providing various features to assist developers and teams in creating and automating tests.  These features include:</p> <ul> <li>automatically generated default unit tests files for components testing</li> <li>offering a util, <code>Test</code> Factory class, that constructs an isolated module/application setup</li> <li>making the Ellar dependency injection system accessible in the testing environment for convenient component mocking.</li> </ul> <p>Ellar is compatible with <code>unittest</code> and <code>pytest</code> testing frameworks in python but in this documentation, we will be using <code>pytest</code>.</p>"},{"location":"basics/testing/#getting-started","title":"Getting started","text":"<p>You will need to install <code>pytest</code></p> <pre><code>pip install pytest\n</code></pre>"},{"location":"basics/testing/#unit-testing","title":"Unit testing","text":"<p>In the following example, we test two classes: <code>CarController</code> and <code>CarRepository</code>. For this we need to use <code>TestClientFactory</code> to build them in isolation from the application since we are writing unit test.</p> <p>Looking at the <code>car</code> module we scaffolded earlier, there is a <code>tests</code> folder provided and inside that folder there is <code>test_controllers.py</code> module.  We are going to be writing unit test for <code>CarController</code> in there.</p> <p><pre><code># project_name/car/tests/test_controllers.py\nfrom project_name.apps.car.controllers import CarController\nfrom project_name.apps.car.schemas import CreateCarSerializer, CarListFilter\nfrom project_name.apps.car.services import CarRepository\n\n\nclass TestCarController:\n    def setup(self):\n        self.controller: CarController = CarController(repo=CarRepository())\n\n    async def test_create_action(self, anyio_backend):\n        result = await self.controller.create(\n            CreateCarSerializer(name=\"Mercedes\", year=2022, model=\"CLS\")\n        )\n\n        assert result == {\n            \"id\": \"1\",\n            \"message\": \"This action adds a new car\",\n            \"model\": \"CLS\",\n            \"name\": \"Mercedes\",\n            \"year\": 2022,\n        }\n</code></pre> In example above, we aren't really testing anything Ellar-specific. Notice that we are not using dependency injection; rather,  we pass an instance of <code>CarController</code> to our <code>CarRepository</code>.  This type of testing, where we manually instantiate the classes being tested, is commonly referred to as isolated testing because it is framework-independent</p>"},{"location":"basics/testing/#using-test-factory","title":"Using Test Factory","text":"<p>Test factory function in <code>ellar.testing</code> package, is a great tool employ for a quick and better test setup.  Let's rewrite the previous example using the built-in <code>Test</code> class:</p> <p><pre><code># project_name/car/tests/test_controllers.py\nfrom unittest.mock import patch\nfrom ellar.di import ProviderConfig\nfrom ellar.testing import Test\nfrom project_name.apps.car.controllers import CarController\nfrom project_name.apps.car.schemas import CreateCarSerializer, CarListFilter\nfrom project_name.apps.car.services import CarRepository\n\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,], \n            providers=[ProviderConfig(CarRepository, use_class=CarRepository)]\n        )\n        self.controller: CarController = test_module.get(CarController)\n\n    async def test_create_action(self, anyio_backend):\n        result = await self.controller.create(\n            CreateCarSerializer(name=\"Mercedes\", year=2022, model=\"CLS\")\n        )\n\n        assert result == {\n            \"id\": \"1\",\n            \"message\": \"This action adds a new car\",\n            \"model\": \"CLS\",\n            \"name\": \"Mercedes\",\n            \"year\": 2022,\n        }\n\n    @patch.object(CarRepository, 'get_all', return_value=[dict(id=2, model='CLS',name='Mercedes', year=2023)])\n    async def test_get_all_action(self, mock_get_all, anyio_backend):\n        result = await self.controller.get_all(query=CarListFilter(offset=0, limit=10))\n\n        assert result == {\n            'cars': [\n                {\n                    'id': 2, \n                    'model': 'CLS', \n                    'name': 'Mercedes', \n                    'year': 2023\n                }\n            ], \n            'message': 'This action returns all cars at limit=10, offset=0'\n        }\n</code></pre> With the <code>Test</code> class, you can create an application execution context that simulates the entire Ellar runtime,  providing hooks to easily manage class instances by allowing for mocking and overriding.</p> <p>The <code>Test</code> class has a <code>create_test_module()</code> method that takes a module metadata object as its argument (the same object you pass to the <code>@Module()</code> decorator). This method returns a <code>TestingModule</code> instance which in turn provides a few methods:</p> <ul> <li><code>override_provider</code>: Essential for overriding <code>providers</code> or <code>guards</code> with a mocked type.</li> <li><code>create_application</code>: This method will return an application instance for the isolated testing module.</li> <li><code>get_test_client</code>: creates and return a <code>TestClient</code> for the application which will allow you to make requests against your application, using the <code>httpx</code> library.</li> </ul>"},{"location":"basics/testing/#overriding-providers","title":"Overriding Providers","text":"<p><code>TestingModule</code> <code>override_provider</code> method allows you to provide an alternative for a provider type or a guard type. For example:</p> <p><pre><code>from ellar.testing import Test\n\nclass MockCarRepository(CarRepository):\n    pass\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,]\n        ).override_provider(\n            CarRepository, use_class=MockCarRepository\n        )\n</code></pre> <code>override_provider</code> takes the same arguments as <code>ellar.di.ProviderConfig</code> and in fact, it builds to <code>ProvideConfig</code> behind the scenes. In example above, we created a <code>MockCarRepository</code> for <code>CarRepository</code> and applied it as shown above.  We can also create an instance of <code>MockCarRepository</code> and have it behave as a singleton within the scope of <code>test_module</code> instance.</p> <p><pre><code>from ellar.testing import Test\n\nclass MockCarRepository(CarRepository):\n    pass\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,]\n        ).override_provider(CarRepository, use_value=MockCarRepository())\n</code></pre> We this, anywhere <code>CarRepository</code> is needed, a <code>MockCarRepository()</code> instance will be applied.</p> <p>In same way, we can override <code>UseGuards</code> used in controllers during testing. For example, lets assume <code>CarController</code> has a guard <code>JWTGuard</code></p> <p><pre><code>import typing\nfrom ellar.common.compatible import AttributeDict\nfrom ellar.common import UseGuards, Controller, ControllerBase\nfrom ellar.core.guard import HttpBearerAuth\nfrom ellar.di import injectable\n\n\n@injectable()\nclass JWTGuard(HttpBearerAuth):\n    async def authenticate(self, connection, credentials) -&gt; typing.Any:\n        # JWT verification goes here\n        return AttributeDict(is_authenticated=True, first_name='Ellar', last_name='ASGI Framework') \n\n\n@UseGuards(JWTGuard)\n@Controller('/car')\nclass CarController(ControllerBase):\n    ...\n</code></pre> During testing, we can replace <code>JWTGuard</code> with a <code>MockAuthGuard</code> as shown below.</p> <pre><code>from ellar.testing import Test\nfrom .controllers import CarController, JWTGuard\n\nclass MockAuthGuard(JWTGuard):\n    async def authenticate(self, connection, credentials) -&gt; typing.Any:\n        # Jwt verification goes here.\n        return dict(first_name='Ellar', last_name='ASGI Framework')\n\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,]\n        ).override_provider(JWTGuard, use_class=MockAuthGuard)\n</code></pre>"},{"location":"basics/testing/#create-application","title":"Create Application","text":"<p>We can access the application instance after setting up the <code>TestingModule</code>. You simply need to call <code>create_application</code> method of the <code>TestingModule</code>. </p> <p>For example: <pre><code>from ellar.di import ProviderConfig\nfrom ellar.testing import Test\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,], \n            providers=[ProviderConfig(CarRepository, use_class=CarRepository)]\n        )\n        app = test_module.create_application()\n        car_repo = app.injector.get(CarRepository)\n        assert isinstance(car_repo, CarRepository)\n</code></pre></p>"},{"location":"basics/testing/#overriding-application-conf-during-testing","title":"Overriding Application Conf During Testing","text":"<p>Having different application configurations for different environments is a best practice in software development.  It involves creating different sets of configuration variables, such as database connection details, API keys, and environment-specific settings,  for different environments such as development, staging, and production.</p> <p>During testing, there two ways to apply or modify configuration.</p> In a fileInline <p>In <code>config.py</code> file, we can define another configuration for testing eg, <code>class TestConfiguration</code> and then we can apply it to <code>config_module</code> when creating <code>TestingModule</code>.</p> <p>For example:</p> <p><pre><code># project_name/config.py\n\n...\n\nclass BaseConfig(ConfigDefaultTypesMixin):\n    DEBUG: bool = False\n\nclass TestingConfiguration(BaseConfig):\n    DEBUG = True\n    ANOTHER_CONFIG_VAR = 'Ellar'\n</code></pre> We have created <code>TestingConfiguration</code> inside <code>project_name.config</code> python module. Lets apply this to TestingModule.</p> <p><pre><code># project_name/car/tests/test_controllers.py\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,], \n            providers=[ProviderConfig(CarRepository, use_class=CarRepository)],\n            config_module='project_name.config:TestingConfiguration'\n        )\n        self.controller: CarController = test_module.get(CarController)\n</code></pre> Also, we can expose the testing config to environment for more global scope, for example:</p> <pre><code># project_name/tests/conftest.py\nimport os\nfrom ellar.constants import ELLAR_CONFIG_MODULE\nos.environ.setdefault(ELLAR_CONFIG_MODULE, 'project_name.config:TestingConfiguration')\n</code></pre> <p>This method doesn't require configuration file, we simply go ahead and define the configuration variables in a dictionary type set to <code>config_module</code>. </p> <p>For instance:</p> <pre><code># project_name/car/tests/test_controllers.py\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,], \n            providers=[ProviderConfig(CarRepository, use_class=CarRepository)],\n            config_module=dict(DEBUG=True, ANOTHER_CONFIG_VAR='Ellar')\n        )\n        self.controller: CarController = test_module.get(CarController)\n</code></pre>"},{"location":"basics/testing/#end-to-end-test","title":"End-to-End Test","text":"<p>End-to-end (e2e) testing operates on a higher level of abstraction than unit testing, assessing the interaction between  classes and modules in a way that approximates user behavior with the production system. </p> <p>As an application expands, manual e2e testing of every API endpoint becomes increasingly difficult,  which is where automated e2e testing becomes essential in validating that the system's overall behavior is correct and  aligned with project requirements. </p> <p>To execute e2e tests, we adopt a similar configuration to that of unit testing,  and Ellar's use of TestClient, a tool provided by Starlette, to facilitates the simulation of HTTP requests</p>"},{"location":"basics/testing/#testclient","title":"TestClient","text":"<p>Starlette provides a TestClient for making requests ASGI Applications, and it's based on httpx library similar to requests. <pre><code>from starlette.responses import HTMLResponse\nfrom starlette.testclient import TestClient\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = HTMLResponse('&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;')\n    await response(scope, receive, send)\n\n\ndef test_app():\n    client = TestClient(app)\n    response = client.get('/')\n    assert response.status_code == 200\n</code></pre> In example above, <code>TestClient</code> needs an <code>ASGI</code> Callable. It exposes the same interface as any other <code>httpx</code> session.  In particular, note that the calls to make a request are just standard function calls, not awaitable.</p> <p>Let's see how we can use <code>TestClient</code> in writing e2e testing for <code>CarController</code> and <code>CarRepository</code>.</p> <pre><code># project_name/car/tests/test_controllers.py\nfrom ellar.di import ProviderConfig\nfrom ellar.testing import Test, TestClient\nfrom project_name.apps.car.controllers import CarController\nfrom project_name.apps.car.services import CarRepository\n\n\nclass MockCarRepository(CarRepository):\n    def get_all(self):\n        return [dict(id=2, model='CLS',name='Mercedes', year=2023)]\n\n\nclass TestCarControllerE2E:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,],\n            providers=[ProviderConfig(CarRepository, use_class=MockCarRepository)],\n            config_module=dict(\n                REDIRECT_SLASHES=True\n            )\n        )\n        self.client: TestClient = test_module.get_test_client()\n\n    def test_create_action(self):\n        res = self.client.post('/car', json=dict(\n            name=\"Mercedes\", year=2022, model=\"CLS\"\n        ))\n        assert res.status_code == 200\n        assert res.json() == {\n            \"id\": \"1\",\n            \"message\": \"This action adds a new car\",\n            \"model\": \"CLS\",\n            \"name\": \"Mercedes\",\n            \"year\": 2022,\n        }\n\n    def test_get_all_action(self):\n        res = self.client.get('/car?offset=0&amp;limit=10')\n        assert res.status_code == 200\n        assert res.json() == {\n            'cars': [\n                {\n                    'id': 2,\n                    'model': 'CLS',\n                    'name': 'Mercedes',\n                    'year': 2023\n                }\n            ],\n            'message': 'This action returns all cars at limit=10, offset=0'\n        }\n</code></pre> <p>In the construct above, <code>test_module.get_test_client()</code> created an isolated application instance and used it to instantiate a <code>TestClient</code>. And with we are able to simulate request behaviour on <code>CarController</code>.</p>"},{"location":"cli/create-module-command/","title":"Create Module Command","text":"<p>This command helps you create an Ellar project module, like a small app within a project. It depends on the existence of an Ellar project.</p> <p><pre><code>ellar create-module my_project_module directory\n</code></pre> for example: <pre><code>ellar create-module my_project_module apps/\n</code></pre> will create a folder as follows: <pre><code>john_doe/\n\u251c\u2500 apps/\n\u2502  \u251c\u2500 my_project_module/\n\u2502  \u2502  \u251c\u2500 tests/\n\u2502  \u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u2502  \u251c\u2500 controllers.py\n\u2502  \u2502  \u251c\u2500 module.py\n\u2502  \u2502  \u251c\u2500 routers.py\n\u2502  \u2502  \u251c\u2500 services.py\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 core/\n\u251c\u2500 domain/\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 __init__.py/\n\u251c\u2500 config.py\n\u251c\u2500 root_module.py                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         dsssss                                                                                                                                                                                                                                                        cxccccccxxcxxnew_file\n\u251c\u2500 server.py\n</code></pre></p>"},{"location":"cli/create-module-command/#new-command-cli-arguments","title":"New Command CLI Arguments","text":"<ul> <li><code>module-name</code> Set the resulting module name.</li> <li><code>directory</code> Path to dump the scaffolded files. <code>.</code> can be used to select current directory.</li> </ul>"},{"location":"cli/create-project-command/","title":"Create Project Command","text":"<p>This command helps you create just an Ellar project provided the <code>\"pyproject.toml\"</code> file exists in the working directory(<code>CWD</code>)</p> <pre><code>ellar create-project my_new_project directory\n</code></pre> <p>for example: <pre><code>ellar create-project my_new_project \n</code></pre></p> <p>will create a folder as follows: <pre><code>my_new_project/\n\u251c\u2500 apps/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 core/\n\u251c\u2500 config.py\n\u251c\u2500 domain\n\u251c\u2500 root_module.py\n\u251c\u2500 server.py\n\u251c\u2500 __init__.py\n</code></pre></p>"},{"location":"cli/create-project-command/#create-project-command-arguments","title":"Create Project Command Arguments","text":"<ul> <li><code>project-name</code> Set the resulting project module name.</li> <li><code>directory</code> Path to dump the scaffolded files. <code>.</code> can be used to select current directory.</li> </ul>"},{"location":"cli/custom-commands/","title":"Custom Commands","text":"<p>In this section, we will guide you through the process of creating a command and explain why you  should utilize <code>ellar_cli.click</code> as your primary Click package when working with Ellar.</p>"},{"location":"cli/custom-commands/#command-options-arguments","title":"Command Options Arguments","text":"<p>The <code>ellar_cli.click</code> package offers comprehensive help messages and documentation for command options and arguments  without compromising the fundamental functionality of the command.  For instance:</p> <pre><code>import ellar_cli.click as click\n\n@click.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\n@click.argument(\"arg2\", required=False, help=\"Arg2 description\")\n@click.option(\"-op1\", required=False, help=\"option1 description\")\n@click.option(\"-op2\", required=False, help=\"option2 description\")\ndef my_command(arg1, arg2, op1, op2):\n    print(f\"ARG1={arg1} ARG2={arg2}; op1={op1} op2={op2}\")\n</code></pre> <p>When you register <code>my_command</code> to a <code>@Module</code> class, you can then execute it in your terminal with the following command: <pre><code>ellar my-command --help \n\n## OUTPUT\n\nUsage: ellar my-command &lt;arg1&gt; [&lt;arg2&gt;] [OPTIONS]\n\nARGUMENTS:\n  arg1: &lt;arg1&gt;    Arg1 description  [required]\n  arg2: [&lt;arg2&gt;]  Arg2 description\n\n[OPTIONS]:\n  -op1 TEXT  option1 description\n  -op2 TEXT  option2 description\n  --help     Show this message and exit.\n</code></pre></p>"},{"location":"cli/custom-commands/#with-injector-context-decorator","title":"With Injector Context Decorator","text":"<p>The <code>ellar_cli.click</code> module includes a command decorator function called <code>with_injector_context</code>.  This decorator ensures that a click command is executed within the application context,  allowing <code>current_injector</code>, and <code>current_config</code> to have values.</p> <p>For instance:</p> <pre><code>import ellar_cli.click as click\nfrom ellar.core import Config, current_injector\n\n@click.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\n@click.with_injector_context\ndef command_context(arg1):\n    config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:\", config.ALLOWED_HOSTS, \";ELLAR_CONFIG_MODULE:\", config.config_module)\n\n@click.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\ndef command_woc(arg1):\n    config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:\", config.ALLOWED_HOSTS, \";ELLAR_CONFIG_MODULE:\", config.config_module)\n</code></pre> <p>In this example, <code>command_context</code> is wrapped with <code>with_injector_context</code>, while <code>command_woc</code> is not.  When executing both commands, <code>command_context</code> will run successfully, and <code>command_wc</code> will raise a RuntimeError  because it attempts to access a value outside the context.</p>"},{"location":"cli/custom-commands/#appcontextgroup","title":"AppContextGroup","text":"<p><code>AppContextGroup</code> extended from <code>click.Group</code> to wrap all its commands with <code>with_injector_context</code> decorator.</p> <p><pre><code>import ellar_cli.click as click\nfrom ellar.core import Config, current_injector\n\ncm = click.AppContextGroup(name='cm')\n\n@cm.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\ndef command_context(arg1):\n    config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:\", config.ALLOWED_HOSTS, \";ELLAR_CONFIG_MODULE:\", config.config_module)\n\n\n@cm.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\ndef command_wc(arg1):\n    config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:\", config.ALLOWED_HOSTS, \";ELLAR_CONFIG_MODULE:\", config.config_module)\n</code></pre> All commands registered under <code>cm</code> will be executed under within the context of the application. </p>"},{"location":"cli/custom-commands/#disabling-with_injector_context-in-appcontextgroup","title":"Disabling <code>with_injector_context</code> in AppContextGroup","text":"<p>There are some cases where you may want to execute a command under <code>AppContextGroup</code> outside application context. This can be done by setting <code>with_injector_context=False</code> as command parameter.</p> <pre><code>import ellar_cli.click as click\n\ncm = click.AppContextGroup(name='cm')\n\n@cm.command(with_injector_context=False)\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\ndef command_wc(arg1):\n    # config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:Unavailable;ELLAR_CONFIG_MODULE:Unavailable\")\n</code></pre>"},{"location":"cli/custom-commands/#async-command","title":"Async Command","text":"<p>The <code>ellar_cli.click</code> package provides a utility decorator function, <code>run_as_sync</code>,  specifically designed to execute coroutine commands.  This is useful when you want to define asynchronous commands using the <code>click</code> package.  Here's an example:</p> <pre><code>import ellar_cli.click as click\nfrom ellar.core import Config,current_injector\n\n@click.command()\n@click.argument(\"arg1\", required=True, help=\"Arg1 description\")\n@click.with_injector_context\n@click.run_as_sync\nasync def command_context(arg1):\n    config = current_injector.get(Config) \n    print(\"ALLOWED_HOSTS:\", config.ALLOWED_HOSTS, \";ELLAR_CONFIG_MODULE:\", config.config_module)\n</code></pre> <p>In this example, the <code>run_as_async</code> decorator enables the <code>command_context</code> coroutine  command to be executed appropriately during execution.</p>"},{"location":"cli/custom-commands/#custom-command-with-ellar","title":"Custom Command With Ellar","text":"<p>Let's create a command group <code>db</code> which contains sub-commands such as <code>makemigrations</code>, <code>migrate</code>, <code>reset-db</code>, and so on.</p> <p>To implement this scenario, let's create a file <code>commands.py</code> at the root level of the project and add the code below. <pre><code>from ellar_cli.click import AppContextGroup\n\ndb = AppContextGroup(name=\"db\")\n\n\n@db.command(name=\"make-migrations\")\ndef makemigrations():\n    \"\"\"Create DB Migration \"\"\"\n\n@db.command()\nasync def migrate():\n    \"\"\"Applies Migrations\"\"\"\n</code></pre></p>"},{"location":"cli/custom-commands/#registering-command","title":"Registering Command","text":"<p>To make the <code>db</code> command visible on the CLI, it must be registered within a <code>@Module</code> class.  This ensures that the Ellar CLI can recognize and identify custom commands.</p> <p><pre><code>from ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom .commands import db\n\n@Module(commands=[db])\nclass ApplicationModule(ModuleBase):\n    pass\n</code></pre> Open your terminal and navigate to the project directory and run the command below <pre><code>ellar db --help\n</code></pre></p> <p>command output <pre><code>Usage: Ellar, Python Web framework db [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  make-migrations  Create DB Migration\n  migrate          Applies Migrations\n</code></pre></p> <p>Having explored various methods for crafting commands and understanding the roles of <code>with_injector_context</code> and <code>run_as_sync</code> decorators,  you now possess the knowledge to create diverse commands for your Ellar application. </p> <p>It's crucial to keep in mind that any custom command you develop needs to be registered within a <code>@Module</code> class, which,  in turn, should be registered with the <code>ApplicationModule</code>. This ensures that your commands are recognized and integrated into the Ellar application's command-line interface. </p>"},{"location":"cli/introduction/","title":"Ellar CLI","text":"<p>Ellar CLI is an abstracted tool for the Ellar web framework that helps in the standard project scaffold of the  framework, module project scaffold, running the project local server using UVICORN, and running custom commands registered in the application module or any Ellar module.</p>"},{"location":"cli/introduction/#installation","title":"Installation","text":"<p>if you have ellar install ready <pre><code>pip install ellar-cli\n</code></pre></p>"},{"location":"cli/introduction/#usage","title":"Usage","text":"<p>To verify ellar-cli is working, run the command belove <pre><code>ellar --help\n</code></pre> Above command should output this: <pre><code>Usage: Ellar, Python Web framework [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -p, --project TEXT              Run Specific Command on a specific project\n  --install-completion [bash|zsh|fish|powershell|pwsh]\n                                  Install completion for the specified shell.\n  --show-completion [bash|zsh|fish|powershell|pwsh]\n                                  Show completion for the specified shell, to\n                                  copy it or customize the installation.\n  --help                          Show this message and exit.\n\nCommands:\n  create-module   - Scaffolds Ellar Application Module -\n  create-project  - Scaffolds Ellar Application -\n  new             - Runs a complete Ellar project scaffold and creates...\n  runserver       - Starts Uvicorn Server -\n  say-hi\n</code></pre></p>"},{"location":"cli/new-command/","title":"Create New Project Command","text":"<p>This command will help you kickstart your new Ellar project. </p> <p>It creates a new project for you with a directory structure and adds all required files for Ellar CLI to properly manage your project.</p> <pre><code>ellar new my-project\n</code></pre> <p>will create a folder as follows: <pre><code>my-project/\n\u251c\u2500 my_project/\n\u2502  \u251c\u2500 apps/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 core/\n\u2502  \u251c\u2500 config.py\n\u2502  \u251c\u2500 domain\n\u2502  \u251c\u2500 root_module.py\n\u2502  \u251c\u2500 server.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 pyproject.toml\n\u251c\u2500 README.md\n</code></pre> If you want to name your project differently than the folder, you can pass the <code>--project-name</code> option.</p> <p><pre><code>ellar new my-project path/to/scaffold-the-new-project\n</code></pre> will create a folder as follows: <pre><code>path/to/scaffold-the-new-project/\n\u251c\u2500 my_project/\n\u2502  \u251c\u2500 apps/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 core/\n\u2502  \u251c\u2500 config.py\n\u2502  \u251c\u2500 domain\n\u2502  \u251c\u2500 root_module.py\n\u2502  \u251c\u2500 server.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 pyproject.toml\n\u251c\u2500 README.md\n</code></pre></p>"},{"location":"cli/new-command/#new-command-cli-arguments","title":"New Command CLI Arguments","text":"<ul> <li><code>project-name</code> Set the resulting project module name.</li> <li><code>directory</code> Path to dump the scaffolded files. <code>.</code> can be used to select the current directory.</li> </ul>"},{"location":"cli/new-command/#new-project-without-pyproject-requirement","title":"New Project without pyproject requirement","text":"<p>To scaffold a new project without <code>pyproject.toml</code>, add <code>--plain</code> to the <code>ellar new command</code>. For example,</p> <pre><code>ellar new my-project --plain\n</code></pre> <p>This will create a folder as follows: <pre><code>my-project/\n\u251c\u2500 my_project/\n\u2502  \u251c\u2500 apps/\n\u2502  \u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 core/\n\u2502  \u251c\u2500 config.py\n\u2502  \u251c\u2500 domain\n\u2502  \u251c\u2500 root_module.py\n\u2502  \u251c\u2500 server.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 manage.py\n\u251c\u2500 README.md\n</code></pre> Inside the scaffolded project, the <code>manage.py</code> python file is not the entry point for the application. It creates a new CLI interface and uses that as the new CLI command to interact with the project.</p> <p><pre><code>python manage.py\n\n### OUTPUT\n\nUsage: manage.py [OPTIONS] COMMAND [ARGS]...\n\n  Ellar, ASGI Python Web framework\n\nOptions:\n  --project TEXT  Run Specific Command on a specific project  [default:\n                  default]\n  -v, --version   Show the version and exit.\n  --help          Show this message and exit.\n\nCommands:\n  create-module  - Scaffolds Ellar Application Module -\n  runserver      - Starts Uvicorn Server -\n</code></pre> Other ellar commands and will be executed through <code>manage.py</code> python file. Eg: <pre><code>python manage.py runserver\n</code></pre></p>"},{"location":"cli/runserver-command/","title":"Runserver Command","text":"<p>This is command is a wrapper around the <code>UVICORN</code> ASGI server. It helps to create a link necessary for <code>UVICORN</code> to run your Ellar application properly.</p> <p><pre><code>ellar runserver --reload\n</code></pre> will product the following output: <pre><code>INFO:     Will watch for changes in these directories: ['/home/user/working-directory']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [2934815] using WatchFiles\nINFO:     APP SETTINGS MODULE: john_doe.config:DevelopmentConfig\nINFO:     Started server process [2934818]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre></p>"},{"location":"cli/runserver-command/#runserver-cli-options","title":"Runserver CLI Options","text":"<p><pre><code>ellar runserver --help\n</code></pre> OR</p> <p>Please check <code>Uvicorn</code> CLI Options</p>"},{"location":"openapi/","title":"OPENAPI","text":"<p>The OpenAPI specification serves as a language-agnostic format for defining RESTful APIs.  In this section, we'll explore how to generate an OpenAPI schema from controllers and routers that aligns with  the OpenAPI specification using the OpenAPIDocumentBuilder and OpenAPIDocumentModule provided in Ellar.</p>"},{"location":"openapi/#openapidocumentbuilder","title":"OpenAPIDocumentBuilder","text":"<p>The <code>OpenAPIDocumentBuilder</code> helps to structure a base document that conforms to the OpenAPI Specification.  It provides several methods that allow setting such properties as title, description, servers, version, etc. </p> <p>In order to create a full OPENAPI document (with all HTTP routes defined) we use the <code>build_document()</code> method of the OpenAPIDocumentBuilder class.  The method takes an application instance to generate an OPENAPI schema based on OpenAPI Specification. </p> <p>For example, In the carapp project, we have the following code below: <pre><code>import os\n\nfrom ellar.app import AppFactory\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core import LazyModuleImport as lazyLoad\nfrom ellar.openapi import (\n    OpenAPIDocumentBuilder,\n)\n\napplication = AppFactory.create_from_app_module(\n    lazyLoad(\"carapp.root_module:ApplicationModule\"),\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"carapp.config:DevelopmentConfig\"\n    ),\n)\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title(\"Ellar API\") \\\n    .set_version(\"1.0.2\") \\\n    .set_contact(name=\"John Doe\", url=\"https://www.yahoo.com\", email=\"johnDoe@gmail.com\") \\\n    .set_license(\"MIT Licence\", url=\"https://www.google.com\") \\\n    .add_server('/', description='Development Server')\n\ndocument = document_builder.build_document(application)\n</code></pre></p>"},{"location":"openapi/#openapidocumentmodule","title":"OpenAPIDocumentModule","text":"<p>Once we create a document, we can call the <code>OpenAPIDocumentModule</code>.setup() method. It accepts:</p> <ol> <li>The path to mount the DocumentationUI</li> <li>An application instance</li> <li>The document object instantiated above</li> <li>Optional guards list </li> </ol> <p><pre><code>import os\n\nfrom ellar.app import AppFactory\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core import LazyModuleImport as lazyLoad\nfrom ellar.openapi import (\n    OpenAPIDocumentBuilder,\n    OpenAPIDocumentModule,\n    SwaggerUI\n)\n\napplication = AppFactory.create_from_app_module(\n    lazyLoad(\"carapp.root_module:ApplicationModule\"),\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"carapp.config:DevelopmentConfig\"\n    ),\n)\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title(\"Ellar API\") \\\n    .set_version(\"1.0.2\") \\\n    .set_contact(name=\"John Doe\", url=\"https://www.yahoo.com\", email=\"johnDoe@gmail.com\") \\\n    .set_license(\"MIT Licence\", url=\"https://www.google.com\") \\\n    .add_server('/', description='Development Server')\n\ndocument = document_builder.build_document(application)\n\nOpenAPIDocumentModule.setup(\n    app=application,\n    docs_ui=SwaggerUI(),\n    document=document,\n    guards=[],\n)\n</code></pre> In the above illustration, we passed application instance, generated document and <code>SwaggerUI</code> as the document renderer.</p> <p>Now you can run the following command to start the HTTP server: <pre><code>ellar runserver --reload\n</code></pre></p> <p>Since we are using <code>SwaggerUI</code>, visit http://localhost:8000/docs</p> <p></p>"},{"location":"openapi/#operations-in-openapi","title":"Operations in OpenAPI","text":"<p>In the context of OpenAPI, operations refer to the HTTP methods used to manipulate endpoints (resources)  exposed by your API, such as <code>GET</code>, <code>POST</code>, or <code>DELETE</code>.</p> <p>We have previously explored in detail how route definitions, input schemas, and response schemas work here.</p> <p>In this section, we will delve into adding additional OpenAPI context to <code>Route Functions</code>, <code>Controllers</code>, and <code>ModuleRouters</code>.</p>"},{"location":"openapi/#api-info-api_info","title":"API Info (<code>api_info</code>)","text":"<p>This metadata is attached to a <code>Route Function</code> to define specific OpenAPI operation details.</p> <p>For instance:</p> <pre><code>from ellar.common import ModuleRouter\nfrom ellar.openapi import api_info\n\nrouter = ModuleRouter()\n\n@router.get()\n@api_info(\n    operation_id=\"unique_id_for_this_operation\",\n    summary=\"This is a summary for this operation\",\n    description=\"This is a description for this operation\",\n    tags=['my_tag1', 'my_tag2'],\n    deprecated=False,\n    extra_operation_property1=\"extra_operation_property1\",\n    extra_operation_property2=\"extra_operation_property2\",\n)\ndef index():\n    pass\n</code></pre> <p>This configuration generates the following operation schema:</p> <pre><code>{\n  \"paths\": {\n    \"/\": {\n      \"get\": {\n        \"tags\": [\n          \"my_tag1\",\n          \"my_tag2\"\n        ],\n        \"summary\": \"This is a summary for this operation\",\n        \"description\": \"This is a description for this operation\",\n        \"operationId\": \"unique_id_for_this_operation\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successful Response\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"title\": \"Response Model\"\n                }\n              }\n            }\n          }\n        },\n        \"extra_operation_property1\": \"extra_operation_property1\",\n        \"extra_operation_property2\": \"extra_operation_property2\"\n      }\n    }\n  }\n}\n</code></pre> <p>Attributes like <code>extra_operation_property1</code> and <code>extra_operation_property2</code> are custom properties added to the operation schema, extending beyond the standard OpenAPI specification. These can be useful for defining additional attributes specific to the operation.</p> <p></p>"},{"location":"openapi/#api-tags-apitags","title":"API Tags (<code>ApiTags</code>)","text":"<p>This metadata is attached to <code>Controllers</code> and <code>ModuleRouter</code> to specify tag information.</p> <p>For example:</p> <pre><code>from ellar.common import Controller, ModuleRouter\nfrom ellar.openapi import ApiTags\n\n@Controller\n@ApiTags(\n    name='ControllerSample', \n    description='SampleController Description', \n    external_doc_description='SampleController Description',\n    external_doc_url='https://google.com'\n)\nclass SampleController:\n    pass\n\nrouter = ModuleRouter()\nApiTags(\n    name='RouterSample', \n    description='RouterSample Description', \n    external_doc_description='RouterSample Description',\n    external_doc_url='https://google.com'\n)(router)\n</code></pre> <p>This setup adds tag information to the overall OpenAPI specification under the <code>tags</code> section:</p> <pre><code>{\n  \"tags\": [\n    {\n      \"name\": \"RouterSample\",\n      \"description\": \"RouterSample Description\",\n      \"externalDocs\": {\n        \"description\": \"RouterSample Description\",\n        \"url\": \"https://google.com/\"\n      }\n    },\n    {\n      \"name\": \"ControllerSample\",\n      \"description\": \"SampleController Description\",\n      \"externalDocs\": {\n        \"description\": \"SampleController Description\",\n        \"url\": \"https://google.com/\"\n      }\n    }\n  ]\n}\n</code></pre> <p></p> <p>You can define OpenAPI tags directly on the <code>Controller</code> and <code>ModuleRouter</code> without using <code>ApiTags</code>.</p>"},{"location":"openapi/document-ui/","title":"Documentation UserInterface","text":"<p>The <code>IDocumentationUI</code> interface serves as a fundamental abstraction within Ellar,  enabling seamless integration with various openapi documentation rendering libraries such as <code>Swagger</code>, <code>ReDocs</code>, and others.</p> <pre><code>import typing as t\nfrom abc import ABC, abstractmethod\n\nclass IDocumentationUI(ABC):\n    \"\"\"\n    Defines the contract for integrating openapi documentation rendering libraries within Ellar.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"The name of the documentation UI, e.g., Swagger, ReDocs, Stoplight.\"\"\"\n\n    @property\n    @abstractmethod\n    def path(self) -&gt; str:\n        \"\"\"The preferred URL path for accessing the documentation.\"\"\"\n\n    @property\n    @abstractmethod\n    def template_name(self) -&gt; t.Optional[str]:\n        \"\"\"\n        The name of the HTML template used for rendering the documentation UI.\n        If None, the `template_string` attribute will be used for inline template rendering.\n        \"\"\"\n\n    @property\n    def template_string(self) -&gt; t.Optional[str]:\n        \"\"\"\n        The templated HTML string for rendering the documentation UI.\n        If a template file is used (`template_name` is not None), this attribute should be None.\n        \"\"\"\n        return None\n\n    @property\n    @abstractmethod\n    def template_context(self) -&gt; dict:\n        \"\"\"\n        Additional settings and context data to be passed to the documentation template.\n        \"\"\"\n</code></pre> <p>By implementing the <code>IDocumentationUI</code> interface, developers can extend  Ellar's capabilities to support additional documentation rendering libraries  beyond the default support for <code>Swagger</code> and <code>ReDocs</code>.</p>"},{"location":"openapi/document-ui/#swaggerui-integration","title":"SwaggerUI Integration","text":"<p>Ellar provides built-in support for rendering Swagger UI, enabling interaction with API resources. It offers flexibility through various initialization parameters.</p> <pre><code>from ellar.openapi import SwaggerUI\n\nswagger_ui = SwaggerUI(\n    path= \"docs\",\n    title=\"EllarSwagger Doc\",\n    swagger_js_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\",\n    swagger_css_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui.css\",\n    favicon_url=\"https://eadwincode.github.io/ellar/img/Icon.svg\",\n    dark_theme=False,\n)\n</code></pre>"},{"location":"openapi/document-ui/#properties","title":"Properties","text":"<ul> <li>path: The URL path used to access the Swagger UI page.</li> <li>title: The title displayed in the HTML header.</li> <li>swagger_js_url: The CDN URL for Swagger JS.</li> <li>swagger_css_url: The CDN URL for Swagger CSS.</li> <li>favicon_url: The URL for the HTML favicon.</li> <li>dark_theme: Indicates whether to apply a dark theme to Swagger CSS.</li> </ul>"},{"location":"openapi/document-ui/#redocui-integration","title":"ReDocUI Integration","text":"<p>Ellar also supports rendering ReDoc UI, providing another option for interacting with API resources.</p> <pre><code>from ellar.openapi import ReDocUI\n\nredoc_ui = ReDocUI(\n    path= \"redoc\",\n    title= \"Ellar Redoc\",\n    redoc_js_url= \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    favicon_url= \"https://eadwincode.github.io/ellar/img/Icon.svg\",\n    with_google_fonts= True,\n)\n</code></pre>"},{"location":"openapi/document-ui/#properties_1","title":"Properties","text":"<ul> <li>path: The URL path for accessing the ReDoc UI page.</li> <li>title: The title displayed in the HTML header.</li> <li>redoc_js_url: The CDN URL for ReDoc JS.</li> <li>favicon_url: The URL for the HTML favicon.</li> <li>with_google_fonts: Indicates whether to include Google Fonts.</li> </ul>"},{"location":"openapi/document-ui/#stoplightui-integration","title":"StopLightUI Integration","text":"<p>For rendering StopLight UI, Ellar offers built-in integration, enhancing interaction with API resources.</p> <pre><code>from ellar.openapi import StopLightUI\n\nstoplight_ui = StopLightUI(\n    path= \"elements\",\n    title= \"Ellar Stoplight\",\n    stoplight_js_url= \"https://unpkg.com/@stoplight/elements/web-components.min.js\",\n    stoplight_css_url= \"https://unpkg.com/@stoplight/elements/styles.min.css\",\n    favicon_url= \"https://eadwincode.github.io/ellar/img/Icon.svg\",\n    config=dict(router=\"hash\", layout=\"sidebar\", hideExport=True)\n)\n</code></pre>"},{"location":"openapi/document-ui/#properties_2","title":"Properties","text":"<ul> <li>path: The URL path for accessing the Stoplight UI page.</li> <li>title: The title displayed in the HTML header.</li> <li>stoplight_js_url: The CDN URL for StopLight JS.</li> <li>stoplight_css_url: The CDN URL for StopLight CSS.</li> <li>config: Configuration options for Stoplight elements as documented here.</li> <li>favicon_url: The URL for the HTML favicon.</li> </ul>"},{"location":"openapi/document-ui/#custom-documentation-ui","title":"Custom Documentation UI","text":"<p>You can easily create custom documentation UIs tailored to their specific needs within Ellar.  This involves defining a custom class that implements the <code>IDocumentationUI</code> interface.</p> <pre><code>import typing as t\nfrom ellar.openapi import IDocumentationUI\n\nclass MyDocUI(IDocumentationUI):\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of the custom documentation UI.\"\"\"\n        return \"my_custom_doc\"\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"The URL path for accessing the custom documentation UI.\"\"\"\n        return \"my_doc\"\n\n    @property\n    def template_name(self) -&gt; t.Optional[str]:\n        \"\"\"The name of the HTML template file used for rendering.\"\"\"\n        return \"my_custom.html\"\n\n    @property\n    def template_string(self) -&gt; t.Optional[str]:\n        \"\"\"The templated HTML string for rendering the documentation UI.\"\"\"\n        return None\n\n    @property\n    def template_context(self) -&gt; dict:\n        \"\"\"Additional context data to be passed to the documentation template.\"\"\"\n        return {\n            # Add any necessary context data here\n        }\n</code></pre> <p>After defining the custom <code>MyDocUI</code> class, it can be integrated into  Ellar's OpenAPI module setup by specifying it in the <code>doc_ui</code> parameter.</p> <p>It's important to note that <code>openapi_url</code> will be passed alongside with <code>template_context</code> provided in <code>MyDocUI</code>.</p> <pre><code>import os\n\nfrom ellar.app import AppFactory\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core import LazyModuleImport as lazyLoad\nfrom ellar.openapi import (\n    OpenAPIDocumentBuilder,\n    OpenAPIDocumentModule,\n)\nfrom .my_doc_ui import MyDocUI\n\napplication = AppFactory.create_from_app_module(\n    lazyLoad(\"carapp.root_module:ApplicationModule\"),\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"carapp.config:DevelopmentConfig\"\n    ),\n)\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title(\"Ellar API\") \\\n    .set_version(\"1.0.2\") \\\n    .set_contact(name=\"John Doe\", url=\"https://www.yahoo.com\", email=\"johnDoe@gmail.com\") \\\n    .set_license(\"MIT Licence\", url=\"https://www.google.com\") \\\n    .add_server('/', description='Development Server')\n\ndocument = document_builder.build_document(application)\n\nOpenAPIDocumentModule.setup(\n    app=application,\n    docs_ui=MyDocUI(),\n    document=document,\n    guards=[],\n)\n</code></pre>"},{"location":"openapi/security/","title":"Security Schemes in OpenAPI","text":"<p>Ellar's OpenAPI security is governed by specialized <code>GuardCanActivate</code> classes and <code>AuthenticationHandler</code> classes.</p> <p>Reference for more information:</p> <ul> <li>Guards.</li> <li>Authentication Handlers.</li> </ul>"},{"location":"openapi/security/#cookie-authentication","title":"Cookie Authentication","text":"<p>Enables cookie-based authentication mechanisms for an operation. Here's an example:</p> Using Cookie GuardUsing Cookie Authentication Handler <p><pre><code>import typing as t\nfrom ellar.common import ModuleRouter, IExecutionContext, UseGuards\nfrom ellar.auth.guards import GuardAPIKeyCookie\nfrom ellar.auth import UserIdentity\nfrom ellar.di import injectable\n\n@injectable\nclass MyGuardAPIKeyCookie(GuardAPIKeyCookie):\n    parameter_name = 'optional-session-id'\n    openapi_name = 'cookie'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n        return False\n\nrouter = ModuleRouter()\n\n@router.get()\n@UseGuards(MyGuardAPIKeyCookie)\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\napp = AppFactory.create_app(routers=[router], controllers=[])\n</code></pre> <code>GuardAPIKeyCookie</code> is an abstract class requiring implementation of the <code>authentication_handler</code>,  which is called after retrieving the key from the request <code>cookie</code> using <code>parameter_name</code>.</p> <p><pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext\nfrom ellar.auth.handlers import CookieAPIKeyAuthenticationHandler\nfrom ellar.auth import UserIdentity, AuthenticationRequired\nfrom ellar.di import injectable\n\n@injectable\nclass MyCookieAPIKeyAuthenticationHandler(CookieAPIKeyAuthenticationHandler):\n    parameter_name = 'api_key'\n    openapi_name = 'cookie'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n\n\nrouter = ModuleRouter()\n\n@router.get()\n@AuthenticationRequired('cookie')\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\napp.add_authentication_schemes(MyCookieAPIKeyAuthenticationHandler)\n</code></pre> <code>CookieAPIKeyAuthenticationHandler</code> is an abstract class requiring implementation of the <code>authentication_handler</code>,  which is called after retrieving the key from the request <code>cookie</code> using <code>parameter_name</code>.</p> <p>When using authentication handlers, <code>AuthenticationRequired</code> should to used to protect any endpoint and by passing <code>openapi_name</code> as a parameter will create necessary OPENAPI security scheme around the decorated Controller or endpoint.</p> <p></p>"},{"location":"openapi/security/#header-authentication","title":"Header Authentication","text":"<p>Enables header-based authentication mechanisms for an operation. Example:</p> Using Header GuardUsing Header Authentication Handler <pre><code>import typing as t\nfrom ellar.common import ModuleRouter, IExecutionContext, UseGuards\nfrom ellar.auth.guards import GuardAPIKeyHeader\nfrom ellar.auth import UserIdentity\nfrom ellar.di import injectable\n\n@injectable\nclass MyGuardAPIKeyHeader(GuardAPIKeyHeader):\n    parameter_name = 'X-API-Key'\n    openapi_name = 'header'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n        return False\n\nrouter = ModuleRouter()\n\n@router.get()\n@UseGuards(MyGuardAPIKeyHeader)\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\n</code></pre> <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext\nfrom ellar.auth.handlers import HeaderAPIKeyAuthenticationHandler\nfrom ellar.auth import UserIdentity, AuthenticationRequired\nfrom ellar.di import injectable\n\n@injectable\nclass MyHeaderAPIKeyAuthenticationHandler(HeaderAPIKeyAuthenticationHandler):\n    parameter_name = 'X-API-Key'\n    openapi_name = 'header'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n\n\nrouter = ModuleRouter()\n\n@router.get()\n@AuthenticationRequired('header')\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\napp.add_authentication_schemes(MyHeaderAPIKeyAuthenticationHandler)\n</code></pre> <p></p>"},{"location":"openapi/security/#query-authentication","title":"Query Authentication","text":"<p>Enables query-based authentication mechanisms for an operation. Example:</p> Using Query GuardUsing Query Authentication Handler <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext, UseGuards\nfrom ellar.auth.guards import GuardAPIKeyQuery\nfrom ellar.auth import UserIdentity\nfrom ellar.di import injectable\n\n@injectable\nclass MyGuardAPIKeyQuery(GuardAPIKeyQuery):\n    parameter_name = 'api_key'\n    openapi_name = 'query'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n        return False\n\nrouter = ModuleRouter()\n\n@router.get()\n@UseGuards(MyGuardAPIKeyQuery)\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\napp = AppFactory.create_app(routers=[router], controllers=[])\n</code></pre> <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext\nfrom ellar.auth.handlers import QueryAPIKeyAuthenticationHandler\nfrom ellar.auth import UserIdentity, AuthenticationRequired\nfrom ellar.di import injectable\n\n@injectable\nclass MyQueryAPIKeyAuthenticationHandler(QueryAPIKeyAuthenticationHandler):\n    parameter_name = 'api_key'\n    openapi_name = 'query'\n\n    async def authentication_handler(self, context:IExecutionContext, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == \"secret\":\n            return UserIdentity(id=1, first_name='John', last_name='Doe')\n\n\nrouter = ModuleRouter()\n\n@router.get()\n@AuthenticationRequired('query')\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\napp.add_authentication_schemes(MyQueryAPIKeyAuthenticationHandler)\n</code></pre> <p></p>"},{"location":"openapi/security/#basic-authentication","title":"Basic Authentication","text":"<p>Enables basic authentication mechanisms for an operation. Example:</p> Using HttpBasic GuardUsing HttpBasic Authentication Handler <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext, UseGuards\nfrom ellar.auth.guards import GuardHttpBasicAuth\nfrom ellar.auth import UserIdentity\nfrom ellar.di import injectable\n\n@injectable\nclass MyGuardHttpBasicAuth(GuardHttpBasicAuth):\n    openapi_name = 'basic'\n\n    async def authentication_handler(self, context:IExecutionContext, credentials: t.Any) -&gt; t.Optional[t.Any]:\n        if credentials.username == \"admin\" and credentials.password == \"secret\":\n            return UserIdentity(id=1, username='admin', first_name='John', last_name='Doe')\n        return False\n\nrouter = ModuleRouter()\n\n@router.get()\n@UseGuards(MyGuardHttpBasicAuth)\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\n</code></pre> <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IHostContext, IExecutionContext\nfrom ellar.auth.handlers import HttpBasicAuthenticationHandler\nfrom ellar.auth import UserIdentity, AuthenticationRequired\nfrom ellar.di import injectable\n\n\n@injectable\nclass MyHttpBasicAuthenticationHandler(HttpBasicAuthenticationHandler):\n    openapi_name = 'basic'\n\n    async def authentication_handler(self, context: IHostContext, credentials: t.Any) -&gt; t.Optional[t.Any]:\n        if credentials.username == \"admin\" and credentials.password == \"secret\":\n            return UserIdentity(id=1, username='admin', first_name='John', last_name='Doe')\n\n\nrouter = ModuleRouter()\n\n@router.get()\n@AuthenticationRequired('basic')\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\napp.add_authentication_schemes(MyHttpBasicAuthenticationHandler)\n</code></pre> <p></p>"},{"location":"openapi/security/#bearer-authentication","title":"Bearer Authentication","text":"<p>Enables bearer authentication mechanisms for an operation. Example:</p> Using HttpBearer GuardUsing HttpBearer Authentication Handler <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.auth.guards import GuardHttpBearerAuth\nfrom ellar.auth import UserIdentity\nfrom ellar.common import ModuleRouter, IExecutionContext, UseGuards\nfrom ellar.di import injectable\n\n@injectable\nclass MyGuardHttpBearerAuth(GuardHttpBearerAuth):\n    openapi_name = 'bearer'\n\n    async def authentication_handler(self, context:IExecutionContext, credentials: t.Any) -&gt; t.Optional[t.Any]:\n        if credentials.credentials == \"secret\":\n            return UserIdentity(id=1, username='admin', first_name='John', last_name='Doe')\n        return False\n\nrouter = ModuleRouter()\n\n@router.get()\n@UseGuards(MyGuardHttpBearerAuth)\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\napp = AppFactory.create_app(routers=[router], controllers=[])\n</code></pre> <pre><code>import typing as t\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter, IExecutionContext\nfrom ellar.auth.handlers import HttpBearerAuthenticationHandler\nfrom ellar.auth import UserIdentity, AuthenticationRequired\nfrom ellar.di import injectable\n\n\n@injectable\nclass MyHeaderAPIKeyAuthenticationHandler(HttpBearerAuthenticationHandler):\n    openapi_name = 'bearer'\n\n    async def authentication_handler(self, context:IExecutionContext, credentials: t.Any) -&gt; t.Optional[t.Any]:\n        if credentials.credentials == \"secret\":\n            return UserIdentity(id=1, username='admin', first_name='John', last_name='Doe')\n\n\nrouter = ModuleRouter()\n\n@router.get()\n@AuthenticationRequired('bearer')\ndef index(ctx: IExecutionContext):\n    return ctx.user\n\n\napp = AppFactory.create_app(routers=[router], controllers=[])\napp.add_authentication_schemes(MyHeaderAPIKeyAuthenticationHandler)\n</code></pre> <p></p>"},{"location":"overview/controllers/","title":"Controllers","text":"<p>The Controller plays a crucial role in managing incoming requests and providing responses to clients.  Its primary function is to handle specific requests directed to an application's <code>ApplicationRouter</code>.  In turn, the <code>ApplicationRouter</code> determines the appropriate <code>controller</code> to manage the incoming request.</p> <p></p> <p>Conceptually, controllers can be likened to routers with multiple registered routes within them.</p>"},{"location":"overview/controllers/#creating-a-controller","title":"Creating a Controller","text":"<p>To create a controller, we use classes and decorators. The <code>Controller</code> decorator associates classes with a required <code>metadata</code> needed for Ellar to create a routing table</p> <pre><code>from ellar.common import Controller, ControllerBase\n\n@Controller()\nclass UserController(ControllerBase):\n    \"\"\"We have created a controller that will manage our Users\"\"\"\n</code></pre>"},{"location":"overview/controllers/#routing","title":"Routing","text":"<p>In this section, we will outline the key features of <code>@Controller()</code>, a <code>class decorator</code> designed for defining a controller.  By default, when applied, <code>@Controller()</code> generates a path prefix based on the class name, such as <code>/car</code>  for a controller named <code>CarController</code>. This feature aims to organize and group related routes, reducing redundancy in route definitions.</p> <p>For instance, if we want to group a collection of routes managing interactions with a customer entity under the route <code>/user</code>,  we can specify the path prefix <code>/user</code> in the <code>@Controller()</code> decorator.  This ensures that we don't need to repeat this portion of the path for each route within the controller. <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, get, ControllerBase\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get()\n    def get_all(self):\n        return 'This action returns all car'\n\n    @get(\"/welcome\")\n    def index(self):\n        return {\"detail\": \"Welcome to Car Resource\"}\n</code></pre></p> <p>Hint</p> <p>Class decorators are conventionally named with capital letters, while function/method decorator names typically use lowercase letters.</p> <p>The <code>@get()</code> HTTP method decorator preceding the <code>get_all(self)</code> method designates <code>get_all(self)</code> as the HTTP request  handler responsible for handling a specific endpoint matching the route path and HTTP method of <code>GET</code>.</p> <p>But what exactly is the route path for <code>get_all(self)</code>? The route path is determined by combining the controller's  <code>path prefix</code> and the path specified in the HTTP method function decorator <code>@get()</code>.</p> <p>For instance, if we've set a prefix for every route <code>(car)</code> and haven't added any path information in the decorator, it means the path defaults to <code>/</code>. In this case, Ellar will associate <code>GET /car/</code> requests with the <code>get_all(self)</code> handler.</p> <p>To illustrate further, if we have a path prefix of <code>/users</code> and include the decorator <code>@get('/profile')</code>,  it would result in a route mapping for requests like <code>GET /users/profile</code>.</p>"},{"location":"overview/controllers/#overview-of-http-function-decorator-parameters","title":"Overview of HTTP function decorator parameters:","text":"<p><code>@get(path: str, name: str, include_in_schema: bool, response: t.Union[t.Dict[int, t.Type], t.List[t.Tuple[int, t.Type]], t.Type])</code></p> <ul> <li><code>path</code>: defines the path for route mapping. <code>default='/'</code></li> <li><code>name</code>: defines a <code>name</code> that will be used to identify this route during URL reversing. default is function name eg: <code>get_all</code></li> <li><code>include_in_schema</code>: indicates if an endpoint should be available in OPENAPI docs</li> <li><code>response</code>: defines different response <code>schema</code>, <code>status code</code>, and <code>Response</code> type that is available on the endpoint. This is only necessary for OPENAPI documentation. default: <code>None</code></li> </ul> <p>Ellar serializes all route handler returned data to <code>JSON</code> unless the data returned is a <code>Response</code> object. For the above example, <code>get_all</code> returned a string. This will be serialized to JSON with a status code 200.</p>"},{"location":"overview/controllers/#request-object","title":"Request Object","text":"<p>There are different ways handlers can access client request details:</p>"},{"location":"overview/controllers/#annotation-parameter_namerequest","title":"Annotation (<code>parameter_name:Request</code>)","text":"<p>Ellar will resolve any parameter annotated as <code>Request</code> in the request handler signature as a <code>Request</code> object. <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, get, ControllerBase\nfrom ellar.core import Request\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get()\n    def get_all(self, request: Request):\n        assert isinstance(request, Request) # True\n        return 'This action returns all cars'\n\n    ...\n</code></pre></p>"},{"location":"overview/controllers/#injection-parameter_nameinjectrequest","title":"injection (<code>parameter_name=Inject[Request]</code>)","text":"<p>We can also inject request object to any handler by using <code>Inject[Request]</code> decorator in handler signature. <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, ControllerBase, get, Inject\nfrom ellar.core import Request\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get()\n    def get_all(self, req_data: Request, req_data_2: Inject[Request]):\n        assert isinstance(req_data, Request) # True\n        assert isinstance(req_data_2, Request)\n        assert req_data == req_data_2\n        return 'This action returns all cars'\n    ...\n</code></pre></p>"},{"location":"overview/controllers/#controllers-context","title":"Controllers Context","text":"<p>During request handler execution, <code>Execution Context</code> is available on the Controller instance and the <code>request</code> object can be gotten from the context. <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, ControllerBase, get\nfrom ellar.core import Request\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get()\n    def get_all(self):\n        assert isinstance(self.context.switch_to_http_connection().get_request(), Request) # True\n        return 'This action returns all cars'\n    ...\n</code></pre></p> <p>Other request <code>handler</code> signature injectors</p> <code>Inject[Request]</code> for <code>Request</code> object <code>Inject[Response]</code> for <code>Response</code> object <code>Path()</code> pydantic field - resolves path parameters <code>Body()</code> pydantic field - resolves required Request <code>body</code> parameters <code>Form()</code> pydantic field - resolves required Request <code>body</code> parameters with content-type=<code>x-www-form-urlencoded</code> <code>Header()</code> pydantic field - resolves required Request <code>header</code> parameters <code>Query()</code> pydantic field - resolves required Request <code>query</code> parameters <code>File()</code> pydantic field - resolves required Request <code>body</code> parameters with content-type=<code>x-www-form-urlencoded</code> <code>Inject[ExecutionContext]</code> Injects <code>ExecutionContext</code>. <code>Cookie()</code> pydantic field - resolves required Request <code>cookie</code> parameters <code>Inject[dict, Inject.Key('Session')]</code> injects Request session data <code>Inject[str, Inject.Key('Host')]</code> injects Request clients host <code>Inject[Type]</code> injects services"},{"location":"overview/controllers/#resource","title":"Resource","text":"<p>Let add create endpoint to our <code>CarController</code> resource. <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, ControllerBase, get, post\nfrom ellar.core import Request\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @post()\n    def create(self):\n        return 'This action adds a new car'\n\n    @get()\n    def get_all(self):\n        assert isinstance(self.context.switch_to_http_connection().get_request(), Request) # True\n        return 'This action returns all cars'\n    ...\n</code></pre></p>"},{"location":"overview/controllers/#http-methods","title":"HTTP Methods","text":"<p>Ellar provides decorators for all the standard HTTP methods:</p> <ul> <li><code>@get</code>  - <code>GET</code> HTTP method</li> <li><code>@post</code> - <code>POST</code> HTTP method</li> <li><code>@put</code> - <code>PUT</code> HTTP method</li> <li><code>@patch</code> - <code>PATCH</code> HTTP method</li> <li><code>@delete</code> - <code>DELETE</code> HTTP method</li> <li><code>@trace</code> - <code>TRACE</code> HTTP method</li> <li><code>@options</code> - <code>OPTIONS</code> HTTP method</li> <li><code>@head</code> - <code>HEAD</code> HTTP method</li> <li><code>@http_route</code> - allows one or more HTTP methods combination, eg: <code>@http_route(methods=['PUT', 'PATCH'])</code></li> </ul>"},{"location":"overview/controllers/#asynchronicity","title":"Asynchronicity","text":"<p>Ellar supports modern asynchronous programming in python using <code>async</code> and <code>await</code> syntax.</p> <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Controller, ControllerBase, get, post\nfrom ellar.core import Request\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @post()\n    async def create(self):\n        return 'This action adds a new car'\n\n    @get()\n    async def get_all(self):\n        assert isinstance(self.context.switch_to_http_connection().get_request(), Request) # True\n        return 'This action returns all cars'\n    ...\n</code></pre>"},{"location":"overview/controllers/#request-payload","title":"Request Payload","text":"<p>Let's use <code>@Body()</code> to define the required data to create a car in our previous <code>create</code>(POST) endpoint. Before that, we need to define our data input/output serializers</p> <pre><code># project_name/apps/car/schema.py\nfrom ellar.common import Serializer\nfrom pydantic import Field\n\n\nclass CreateCarSerializer(Serializer):\n    name: str\n    year: int = Field(..., gt=0)\n    model: str\n\n\nclass CarListFilter(Serializer):\n    offset: int = 1\n    limit: int = 10\n\n\nclass CarSerializer(Serializer):\n    id: str\n    name: str\n    year: int\n    model: str\n</code></pre> <p>Let's add the <code>CreateCarSerializer</code> to <code>create</code> endpoint, <pre><code># project_name/apps/car/controllers.py\n...\nfrom ellar.common import Body, post\nfrom .schemas import CreateCarSerializer\n\n\n@post()\nasync def create(self, payload: Body[CreateCarSerializer]):\n    return 'This action adds a new car'\n</code></pre></p> <p><code>CreateCarSerializer</code> is a Pydantic type, which implies that the <code>name</code>, <code>year</code>, and <code>model</code> fields undergo automatic type validation.</p> <p>It's crucial to observe how we utilized <code>CreateCarSerializer</code> as a type annotation for the <code>payload</code> parameter in the <code>create</code>  route handler method. Ellar will calculate values for all route handler parameters and validate them according to  the annotated types before executing the handler.</p> <p>Info</p> <p>if a parameter is not annotated, it will be assumed as a <code>string</code> type</p> <p></p> <p>Let's add other endpoints</p> <pre><code># project_name/apps/car/controllers.py\n\nfrom ellar.common import Body, Controller, ControllerBase, delete, get, post, put, Query\nfrom ellar.core import Request\nfrom .schemas import CreateCarSerializer, CarListFilter\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @post()\n    async def create(self, payload:Body[CreateCarSerializer]):\n        result = payload.dict()\n        result.update(message='This action adds a new car')\n        return result\n\n    @put('/{car_id:str}')\n    async def update(self, car_id: str, payload:Body[CreateCarSerializer]):\n        result = payload.dict()\n        result.update(message=f'This action updated #{car_id} car resource')\n        return result\n\n    @get('/{car_id:str}')\n    async def get_one(self, car_id: str):\n        return f\"This action returns a #{car_id} car\"\n\n    @delete('/{car_id:str}')\n    async def delete(self, car_id: str):\n        return f\"This action removes a #{car_id} car\"\n\n    @get()\n    async def get_all(self, query:Query[CarListFilter]):\n        assert isinstance(self.context.switch_to_http_connection().get_request(), Request)  # True\n        return f'This action returns all cars at limit={query.limit}, offset={query.offset}'\n</code></pre>"},{"location":"overview/controllers/#linking-controller","title":"Linking Controller","text":"<p>On the preceding page, we successfully connected our <code>car</code> module (<code>CarModule</code>) to the <code>ApplicationModule</code> in <code>project_name/root_module</code>.  However, this time, we will be introducing modifications to the <code>CarModule</code> to keep things simple, organized and modular.</p> <p>To achieve this, let's include the registration of <code>CarController</code> within the <code>CarModule</code>.  The <code>@Module()</code> decorator accepts a <code>controllers</code> parameter, which is an array of the <code>ControllerBase</code> type.</p> <p>In the <code>car/module.py</code>,</p> <pre><code># project_name/apps/car/module.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\n\nfrom .controllers import CarController\n\n\n@Module(\n    controllers=[CarController],\n    providers=[],\n    routers=[],\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre> <p></p>"},{"location":"overview/custom_decorators/","title":"Custom Decorators","text":"<p>Ellar provides a variety of function decorators in the <code>ellar.common</code> python module that can be used to modify the behavior of route functions. </p> <p>These decorators can be used to change the response type of a route function, add filters to the response schema, define the OPENAPI context, and more.  In general, these decorators can help to simplify and streamline the process of creating routes.</p>"},{"location":"overview/custom_decorators/#http-method-decorator","title":"HTTP Method Decorator","text":"<p><code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@patch</code>, <code>@delete</code>, <code>@trace</code>, <code>@options</code>, <code>@head</code> are decorators that define the standard HTTP methods for a route function.  They indicate the type of HTTP request that the route function can handle, such as a <code>GET</code> request or a <code>POST</code> request. </p> <p><code>@http_route</code> is a decorator that can be used to define a route that can handle multiple HTTP methods at once. </p> <p><code>@ws_route</code> is a decorator that is used to define a route that can handle WebSocket connections. </p> <p>These decorators help to specify which type of request a route function can handle.</p>"},{"location":"overview/custom_decorators/#route-function-parameters","title":"Route Function Parameters","text":"<p>These are Pydantic Models that defines and validates user input dependencies as a route function parameters.  They are used to ensure that the specified parameters are present in the request and are of the correct type. </p> <p>If any of the specified parameters are missing or are of an invalid type, the decorators will raise a <code>422</code> error code and also provide a clear error message if the input validation fails. This helps to ensure that your application is receiving valid input and can process the request correctly.</p> <ul> <li><code>Body[T, Body.P(..., embed=False)]</code>: marks a parameter as a field to be available in a request body of <code>application/json</code> content-type.</li> <li><code>Form[T, Form.P(..., embed=True)]</code>: marks a parameter as a field to be available in a request body of <code>x-www-form-urlencoded or multipart/form-data</code> content-type.</li> <li><code>Query[T, Query.P(...)]</code>: marks a parameter as a field to be available in request query object</li> <li><code>File[T, File.P(...)]</code>: marks a parameter as a field to be available in a request body of <code>multipart/form-data</code> content-type.</li> <li><code>Path[T, Path.P(...)]</code>: marks a parameter as a request path variable.</li> <li><code>Header[T, Header.P(...)]</code>: marks a parameter as a request header variable.</li> <li><code>Cookie[T, Cookie.P(...)]</code>: marks a parameter as a request cookie variable.</li> <li><code>WsBody[T, WsBody.P(...)]</code>: defines the message format that should be transmitted from the client in a <code>WebSocket</code> when there is a successful connection. See websocket advance doc</li> </ul> <p>Please refer to the \"How-to-Guide\" on parsing inputs here to see how this input decorators work. </p>"},{"location":"overview/custom_decorators/#non-route-function-parameters","title":"Non Route Function Parameters","text":"<p>We discussed decorators that are used to define route function parameter dependencies in Ellar.  These decorators, such as <code>Query</code>, <code>Form</code>, and <code>Body</code>, etc. are pydantic models used to specify the expected parameters for a route function. </p> <p>However, there are also some route parameters that are system dependent, such as the <code>request</code> or <code>websocket</code> object, and the <code>response</code> object.  These parameters are resolved by the application and supplied to the route function when needed, and are not specified with pydantic models or user input.</p>"},{"location":"overview/custom_decorators/#injecttype","title":"Inject[Type]","text":"<p>The Inject[Type] annotation is used to inject a service registered in Ellar DI container and also inject system services into a route function parameter.</p> <p>For example: <pre><code>from ellar.app import App\nfrom ellar.common import ModuleRouter, Inject\nfrom ellar.core import Config\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nrouter = ModuleRouter('/test-provide')\n\n@router.get('/app')\ndef example_endpoint(app: Inject[App], config: Inject[Config], async_session: Inject[AsyncSession]):\n    assert isinstance(app, App)\n    assert app.config == config\n    assert isinstance(config, Config)\n    return {'message': 'injected App and Configuration object to route function'}\n</code></pre> In the example above, <code>example_endpoint</code> function has two parameters <code>app</code> and <code>config</code> which are annotated with <code>Inject[Type]</code>. This annotation tells the application to resolve the <code>App</code> and <code>Config</code> service providers and inject them as the <code>app</code> and <code>config</code> parameters when the endpoint is called.</p> <p>This allows for easy access to the objects without having to manually import and instantiate them.  It also makes the code more modular and easier to test.</p> <p>Info</p> <p>Only types registered in the application can be resolved, but you can set <code>INJECTOR_AUTO_BIND = True</code> in configuration for the injector to register automatically that are not found.  please note that this automatic registration will be scoped to <code>singleton</code> by the <code>EllarInjector</code>.</p>"},{"location":"overview/custom_decorators/#injecting-executioncontext","title":"Injecting ExecutionContext","text":"<p>We inject <code>ExecutionContext</code> by simply annotating a parameter with Inject and IExecutionContext interface or ExecutionContext class. See ExecutionContext for more understanding of <code>ExecutionContext</code></p> <p>For example: <pre><code>from ellar.common import ModuleRouter, IExecutionContext, Inject\n\nrouter = ModuleRouter('/test-context')\n\n@router.get('/')\ndef example_endpoint(ctx: Inject[IExecutionContext]):\n    http_connection_instance = ctx.switch_to_http_connection().get_client()\n    query_params = http_connection_instance.query_params\n    return {'message': 'inject execution context', 'query_params': query_params}\n</code></pre></p>"},{"location":"overview/custom_decorators/#injecting-request-object","title":"Injecting Request Object","text":"<p>We inject <code>Request</code> by simply annotating a parameter with Inject and Request class.</p> <p>For example: <pre><code>from ellar.common import ModuleRouter, Inject\nfrom ellar.core import Request\n\nrouter = ModuleRouter('/test-req')\n\n@router.get('/')\ndef example_endpoint(req: Inject[Request]):\n    headers = req.headers\n    query_params = req.query_params\n    return {'message': 'injected request object', 'headers': headers, 'query_params': query_params}\n</code></pre></p> <p>In this example, the <code>example_endpoint</code> function has a parameter annotated with <code>Inject[Request]</code>, which will be automatically populated with the current <code>Request</code> object at runtime.  The <code>headers</code> and <code>query_params</code> attributes of the <code>req</code> object can then be accessed and used within the function.</p>"},{"location":"overview/custom_decorators/#injecting-response-object","title":"Injecting Response Object","text":"<p>We inject <code>Response</code> by simply annotating a parameter with Inject and Response class.</p> <p>For example: <pre><code>from ellar.common import ModuleRouter, Inject, Response\n\nrouter = ModuleRouter('/test-response')\n\n@router.get('/')\ndef example_endpoint(res: Inject[Response]):\n    res.headers['x-custom-header'] = 'hello'\n    return {'message': 'inject response object'}\n</code></pre></p> <p>In this example, the <code>Inject[Response]</code> annotation injects the current <code>Response</code> object to the <code>res</code> parameter of the <code>example_endpoint</code> function.  This will allow you to manipulate the headers of the response before it is sent back to the client.</p>"},{"location":"overview/custom_decorators/#injecting-websocket-object","title":"Injecting Websocket Object","text":"<p>We inject <code>Websocket</code> by simply annotating a parameter with Inject and Websocket class.</p> <p>For example: <pre><code>from ellar.common import ModuleRouter, Inject\nfrom ellar.core import WebSocket\n\nrouter = ModuleRouter('/test-ws')\n\n@router.ws_route('/')\nasync def example_endpoint(ws: Inject[WebSocket]):\n    await ws.accept()\n    await ws.send_json({'message': 'injected WebSocket object to route function'})\n</code></pre> The above code creates a WebSocket route '/test-ws' and when a client connects to this route,  the <code>example_endpoint</code> function is executed. The <code>Ws</code> decorator injects the current <code>WebSocket</code> object to the <code>ws</code> parameter of the function, which can then be used to interact with the WebSocket connection, such as accepting the connection and sending data to the client.</p> <p>The same conditions and examples applies for:</p> <ul> <li>Host <code>Inject[str, Inject.Key(\"Host\")]</code> injects current client host address to route function parameter. see example below</li> <li>Session <code>Inject[dict, Inject.Key(\"Session\")]</code> injects current Session object to route function parameter. This requires SessionMiddleware module from Starlette added in application middleware and also <code>SessionMiddleware</code> module depends on itsdangerous package.</li> <li>Http <code>Inject[dict, Inject.Key(\"Session\")]</code> injects current HTTP connection object to route function parameter. see example below</li> </ul> <p>For example: <pre><code>from ellar.common import Inject, ModuleRouter\nfrom starlette.requests import HTTPConnection\n\nrouter = ModuleRouter()\n\n@router.get(\"/others\")\ndef get_requests_case_2(\n    session: Inject[dict, Inject.Key(\"Session\")], # injects requests session\n    host: Inject[str, Inject.Key(\"Host\")], # injects requests host\n    connection: Inject[HTTPConnection], # injects connection\n) -&gt; bool:\n    assert isinstance(connection, HTTPConnection)  # True\n    assert host == \"testclient\"\n    assert isinstance(session, dict) and len(session) == 0\n    return True\n</code></pre></p>"},{"location":"overview/custom_decorators/#custom-parameter-decorators","title":"Custom Parameter Decorators","text":"<p>You can create your own route parameter decorators whenever necessary. You simply need to follow a contract, <code>NonParameterResolver</code>, and override the resolve function.</p> <p>The <code>NonParameterResolver</code> has two attributes, <code>type_annotation</code> and <code>parameter_name</code>, that are provided automatically when computing route function parameter dependencies. The <code>type_annotation</code> and <code>parameter_name</code> are determined from the parameter declaration like so - <code>def route_function(parameter_name:type_annotation = NonParameterResolver())</code>.</p> <p>All <code>NonParameterResolver</code> receives current <code>IExecutionContext</code> during route function execution, and it must return a tuple of dict object of the resulting resolve data with <code>parameter_name</code> and list of errors if any.  As shown in the return statements in the example below.</p> <p>For example: <pre><code>import typing as t\nfrom ellar.common.params import SystemParameterResolver\nfrom ellar.common import IExecutionContext\nfrom pydantic.error_wrappers import ErrorWrapper\n\n\nclass UserParam(SystemParameterResolver):\n    async def resolve(self, ctx: IExecutionContext, **kwargs: t.Any) -&gt; t.Any:\n        request = ctx.switch_to_http_connection().get_request()\n        user = request.get('user', None)\n        if user:\n            return {self.parameter_name: user}, []\n        return {}, [ErrorWrapper('Authenticated Users Only', loc='system')]\n</code></pre></p> <p>This example defines a custom decorator called <code>UserParam</code> that inherits from <code>NonParameterResolver</code>.  The <code>resolve</code> method is overridden to extract the user from the current <code>IExecutionContext</code>'s request. </p> <p>If the user is found, it is returned as a dict with the key as the <code>parameter_name</code> of the decorator, along with an empty list of errors.  If no user is found, an empty dict and a list of errors containing an ErrorWrapper object is returned. </p> <p>This <code>UserParam</code> decorator can then be used to inject the user object to a route function parameter like so: <pre><code>from typing_extensions import Annotated\nfrom .custom_decorator import UserParam\nfrom .schema import UserType\n\n@router.get('/user')\ndef example_endpoint(user = UserParam(), user2: Annotated[UserType, UserParam()]):\n    assert user2 == user # True\n    return {'message': 'injected user object to route function', 'user': user}\n</code></pre></p>"},{"location":"overview/custom_decorators/#route-function-decorators","title":"Route Function Decorators","text":"<p>These decorators are used to modify the output data of a route function, add filtering to the output schema, or add extra OPENAPI information about the route function.</p> <p>They include:</p>"},{"location":"overview/custom_decorators/#render","title":"RENDER","text":"<p>@render() decorator converts a route function response to HTML template response. </p> <p>for example:  <pre><code>from ellar.common import get, render\n...\n@get('/index-template')\n@render(template_name='my_template')\ndef index(self):\n    return {'name': 'Ellar Template'}\n</code></pre></p> <p>In the example, the index function is decorated with the <code>render</code> decorator,  which will return a 200 status code and HTML content from my_template. </p> <p>The return object from the index function will be used as the templating context for <code>my_template</code> during the template rendering process.  This allows the function to pass data to the template and have it rendered with the provided context, the rendered template will be the response body.</p> <p>See HTML Templating for more information on <code>render</code> and HTML templating with Ellar.</p>"},{"location":"overview/custom_decorators/#file","title":"FILE","text":"<p>@file() decorator converts a route function response to file or streaming response type.  Based on the value of <code>streaming</code> parameter, file decorator creates <code>FileResponseModel</code> or <code>StreamingResponseModel</code>.</p>"},{"location":"overview/custom_decorators/#fileresponsemodel-as-filestreamingfalse","title":"FileResponseModel as file(streaming=False)","text":"<p>When <code>streaming</code> parameter in <code>@file(streaming=False)</code> decorator is set to <code>False</code>, a <code>FileResponseModel</code> is created as the response model for the decorated route function.  And the route function is required to return a dictionary object that follows a <code>FileResponseModelSchema</code> format:</p> <pre><code>import typing as t\nfrom enum import Enum\nfrom ellar.common import Serializer\n\n\nclass ContentDispositionType(str, Enum):\n    inline = \"inline\"\n    attachment = \"attachment\"\n\n\nclass FileResponseModelSchema(Serializer):\n    path: str\n    media_type: t.Optional[str] = None\n    filename: t.Optional[str] = None\n    method: t.Optional[str] = None\n    content_disposition_type: ContentDispositionType = ContentDispositionType.attachment\n</code></pre> <ul> <li><code>path</code>: This is a required key whose value defines the path to the file to attach to the response.</li> <li><code>filename</code>: when specified, it will be used as the attached file's filename. The default value is computed from the file referenced.</li> <li><code>content_disposition_type</code>: defines the content disposition type, can be either inline or attachment. The default is attachment.</li> <li><code>media_type</code>: states the <code>MIME</code> type of the file to be attached. The default value is computed from the file referenced.</li> <li><code>method</code>: HTTP method, defaults: <code>HEAD</code></li> </ul> <p>for example: <pre><code>from ellar.common import get, file\n...\n@get()\n@file(media_type='text/html', streaming=False)\ndef file_download(self):\n    return {'path': 'path/to/file.html', 'filename': 'code.html', 'content_disposition_type': 'attachment'}\n</code></pre> In the example, an additional parameter media_type is added to the @file(streaming=False) decorator to define the content-type of the file returned. This is helpful for creating the route function's OPENAPI documentation, as it allows the content-type to be defined upfront. Without this parameter, the content-type will be computed during runtime when returning a response for a request. It is a way to explicitly define the content-type of the file which will be returned.</p>"},{"location":"overview/custom_decorators/#streamingresponsemodel-as-filestreamingtrue","title":"StreamingResponseModel as file(streaming=True)","text":"<p>On the other hand, when <code>streaming</code> parameter in <code>@file(streaming=True)</code> decorator is set to <code>True</code>, a <code>StreamingResponseModel</code> is created as the response model for the decorated route function.  And the route function is required to return an <code>ContentStream</code>. <code>ContentStream</code> is an synchronous or asynchronous iterator of string or bytes.  Type definition is shown below.</p> <pre><code>import typing\nimport asyncio\nfrom ellar.common import get, file\n\nContent = typing.Union[str, bytes]\nSyncContentStream = typing.Iterator[Content]\nAsyncContentStream = typing.AsyncIterable[Content]\nContentStream = typing.Union[AsyncContentStream, SyncContentStream]\n\nasync def slow_numbers(minimum: int, maximum: int):\n    yield (\"&lt;html&gt;&lt;body&gt;&lt;ul&gt;\")\n    for number in range(minimum, maximum + 1):\n        yield \"&lt;li&gt;%d&lt;/li&gt;\" % number\n        await asyncio.sleep(0.01)\n    yield (\"&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\")\n\n...\n@get('/stream')\n@file(media_type='text/html', streaming=True)\ndef file_stream(self):\n    # file_stream function must return ContentStream\n    # return {\"content\": slow_numbers(1, 4), \"media_type\": \"text/html\"} Controls media_type\n    # return {\"content\": slow_numbers(1, 4)} Controls sets media_type='text/html' set in @file decorator\n    return slow_numbers(1, 4) # This will be converted to {\"content\": slow_numbers(1, 4), media_type: 'text/html'} media_type set from @file decorator\n</code></pre>"},{"location":"overview/custom_decorators/#openapi-info","title":"OPENAPI-INFO","text":"<p>@api_info() decorator adds extra route function OPENAPI properties to route function OPENAPI documentation. They include:</p> <p>Parameters:</p> <ul> <li><code>tags</code>: adds more OPENAPI tags to route function OPENAPI docs.</li> <li><code>deprecated</code>: marks route function as deprecated. Default is false</li> <li><code>descriptions</code>: adds description to route function OPENAPI docs</li> <li><code>operation_id</code>: modifies operationid for the route function OPENAPI docs</li> <li><code>summary</code>: adds summary to route function OPENAPI docs</li> </ul> <p>For example: <pre><code>from ellar.common import get\nfrom ellar.openapi import api_info\n\n...\n@get(\"/open-api-info\")\n@api_info(\n    tags=['query'], \n    deprecated=False, \n    description='open api info testing', \n    operation_id='some-operation-id', \n    summary='some summary'\n)\ndef api_info_function(self, query: str):\n    return f\"foo bar {query}\"\n</code></pre></p>"},{"location":"overview/custom_decorators/#serializer-filter","title":"SERIALIZER FILTER","text":"<p>@serializer_filter() decorator provides Pydantic filtering options to decorated route function output schema.</p> <p>Parameters:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary</li> <li><code>exclude</code>: fields to exclude from the returned dictionary</li> <li><code>by_alias</code>: whether field aliases should be used as keys in the returned dictionary; default <code>False</code></li> <li><code>exclude_unset</code>: whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary; default <code>False</code>.</li> <li><code>exclude_defaults</code>: whether fields which are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary; default <code>False</code></li> <li><code>exclude_none</code>: whether fields which are equal to None should be excluded from the returned dictionary; default <code>False</code></li> </ul> <p>For example: <pre><code>import typing as t\nfrom ellar.common import serializer_filter, get, Serializer\n\nclass UserSchema(Serializer):\n    username: str\n    password: str\n    first_name: t.Optional[str]\n    last_name: t.Optional[str]\n\n...\n@get(\"/serialize-filter-1\", response=UserSchema)\n@serializer_filter(exclude_none=True, exclude={'password'})\ndef serialized_output_1(self):\n    return dict(username='python', password='secret', first_name='ellar')\n</code></pre> In example, <code>serializer_filter</code> to filter values that are <code>None</code> and also excluded <code>password</code> property from been returned. See Pydantic Model Export for more examples.</p>"},{"location":"overview/custom_decorators/#version","title":"VERSION","text":"<p>@version()  is a decorator that provides endpoint versioning for a route function.  This decorator allows you to specify the version of the endpoint that the function is associated with. </p> <p>Based on the versioning scheme configuration in the application, versioned route functions are called. This can be useful for maintaining backward compatibility, or for rolling out new features to different versions of an application.  More information on how to use this decorator can be found in the Versioning documentation</p> <p>A quick example on how to use <code>version</code> decorator: <pre><code>from ellar.common import post, Version\n\n@post(\"/create\", name='v2_v3_list')\n@Version('2', '3')\nasync def get_item_v2_v3(self):\n    return {'message': 'for v2 and v3 request'}\n</code></pre></p> <p>The <code>version</code> decorator takes a list of values as an argument, for example <code>@version('2', '3')</code>.  This indicates that the <code>get_item_v2_v3</code> route function will handle version 2 and version 3 requests of the /create endpoint.  This allows for multiple versions of the same endpoint to be handled by different route functions, each with their own logic and implementation.</p>"},{"location":"overview/custom_decorators/#useguards","title":"UseGuards","text":"<p>@UseGuards()  is a decorator that applies a protection class of type <code>GuardCanActivate</code> to a route function.  These protection classes have a <code>can_execute</code> function that is called to determine whether a route function should be executed. </p> <p>This decorator allows you to apply certain conditions or checks before a route function is executed, such as <code>authentication</code> or <code>authorization</code> checks.  This can help to ensure that only authorized users can access certain resources. </p> <p>More information on how to use this decorator can be found in the Guard Documentation</p> <p>A quick example on how to use <code>UseGuards</code> decorator: <pre><code>import typing as t\nfrom ellar.common import get, UseGuards\nfrom ellar.core import APIKeyQuery, HTTPConnection\n\n\nclass MyAPIKeyQuery(APIKeyQuery):\n    async def authenticate(self, connection: HTTPConnection, key: t.Optional[t.Any]) -&gt; t.Optional[t.Any]:\n        if key == 'supersecret':\n            return True\n        return False\n\n\n@get(\"/\")\n@UseGuards(MyAPIKeyQuery(), )\nasync def get_guarded_items(self):\n    return {'message': 'worked fine with `key`=`supersecret`'}\n</code></pre> The <code>UseGuards</code> decorator, like the <code>version</code> decorator, takes a list of values as an argument.  During a request, the provided guards are called in the order in which they are provided. </p> <p>This allows you to apply multiple guards to a single route function and have them executed in a specific order.  This is useful for applying multiple levels of security or access control to a single endpoint. </p> <p>Each guard class has a <code>can_execute</code> function that is called in the order specified by the decorator, if any of the guard's <code>can_execute</code> function returns False, the route function will not be executed.</p>"},{"location":"overview/custom_decorators/#command-decorators","title":"Command Decorators","text":"<p>The <code>command</code> decorator is used to convert a decorated function into a command that can be executed through the Ellar command-line interface (CLI) actions.  This allows you to define custom commands that can be run from the command-line, which can be useful for tasks such as running database migrations, generating code, or other tasks that can be automated.</p> <p>See Ellar-CLI Custom Commands</p>"},{"location":"overview/custom_decorators/#module-function-decorators","title":"Module Function Decorators","text":"<ul> <li> <p><code>@exception_handler</code>: This decorator is used to register a function as an exception handler. This function will be called when an unhandled exception occurs during a request. It should take the exception instance as its only argument and return a response object.</p> </li> <li> <p><code>@middleware</code>: This decorator is used to register a function as middleware. Middlewares are called for each incoming request and can be used to modify the request or response, or perform any other actions before or after the request is handled.</p> </li> <li> <p><code>@template_filter</code>: This decorator is used to register a function as a Jinja2 template filter. </p> </li> <li> <p><code>@template_global</code>: This decorator is used to register a function as a global variable available in all Jinja2 templates.</p> </li> <li> <p><code>@template_context</code>: This decorator is used to register a function as a global template context for dynamic template context processing.</p> </li> </ul> <p>These decorators can be used to define functions that will be executed at specific points in the application's lifecycle.  They provide a way to separate and organize the different parts of an application. See Module Additional Configuration for examples on how these decorator functions are used.</p>"},{"location":"overview/exception_handling/","title":"Exceptions &amp; Exception Handling","text":"<p>Ellar includes a built-in exceptions middleware, known as <code>ExceptionMiddleware</code>, responsible for processing all exceptions  that occur within an application. When an exception goes unhandled by your application code,  it is intercepted by this middleware, which then automatically sends an appropriate, user-friendly response.</p> <p><pre><code>{\n  \"status_code\": 403,\n  \"detail\": \"Forbidden\"\n}\n</code></pre> Depending on the application's configuration and the value of <code>DEBUG</code>, the exception handling behavior differs.  When <code>current_config.DEBUG</code> is True, the exception that is raised is shown to the client for easy error debugging.  However, when <code>current_config.DEBUG</code> is False, a 500 error is returned to the client, as illustrated below:</p> <pre><code>{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}\n</code></pre> <p>Ellar manages various types of exceptions by default:</p> <ul> <li><code>HTTPException</code>: Provided by <code>Starlette</code> to handle HTTP errors.eg. <code>HTTPException(status_code, detail=None, headers=None)</code></li> <li><code>WebSocketException</code>: Provided by <code>Starlette</code> to manage websocket errors. eg <code>WebSocketException(code=1008, reason=None)</code></li> <li><code>RequestValidationException</code>: Provided by <code>Pydantic</code> for validation of request data</li> <li> <p><code>APIException</code>: It is a type of exception designed for REST API-based applications. It offers a more conceptual approach to handling errors and provides a simple interface for creating other custom exceptions in your application without requiring an additional exception handler.</p> <p>For example,</p> <pre><code>from ellar.common import APIException\nfrom starlette import status\n\nclass ServiceUnavailableException(APIException):\n    status_code = status.HTTP_503_SERVICE_UNAVAILABLE\n    code = 'service_unavailable'\n</code></pre> </li> </ul>"},{"location":"overview/exception_handling/#built-in-apiexceptions","title":"Built-in APIExceptions","text":"<p>Ellar offers a set of standard exceptions that inherit from the base <code>APIException</code>.  These exceptions are available within the <code>ellar.common</code> package and represent many of the most common HTTP exceptions:</p> <ul> <li><code>AuthenticationFailed</code></li> <li><code>ImproperConfiguration</code></li> <li><code>MethodNotAllowed</code></li> <li><code>NotAcceptable</code></li> <li><code>NotAuthenticated</code></li> <li><code>NotFound</code></li> <li><code>PermissionDenied</code></li> <li><code>UnsupportedMediaType</code></li> </ul>"},{"location":"overview/exception_handling/#throwing-standard-exceptions","title":"Throwing standard exceptions","text":"<p>Let's use the <code>ServiceUnavailableException</code> in our previous project.</p> <p>For example, in the <code>CarController</code>, we have a <code>get_all()</code> method (a <code>GET</code> route handler).  Let's assume that this route handler throws an exception for some reason.  To demonstrate this, we'll hard-code it as follows:</p> <p><pre><code># project_name/apps/car/controllers.py\n\n@get()\ndef get_all(self):\n    raise ServiceUnavailableException()\n</code></pre> Now, when you visit http://127.0.0.1/car/, you will get a JSON response. <pre><code>{\n  \"detail\": \"Service Unavailable\"\n}\n</code></pre> When we raise the <code>ServiceUnavailableException</code>, it produces a <code>JSON</code> response because <code>Ellar</code> has implemented  an exception handler for any <code>APIException</code> exception type. We will see how to change the default exception handler later.</p> <p>Another error presentation is available on the APIException instance:</p> <ul> <li><code>.detail</code>: returns the textual description of the error.</li> <li><code>get_full_details()</code>: returns both the textual description and other information about the error.</li> </ul> <pre><code>&gt;&gt;&gt; print(exc.detail)\nService Unavailable\n&gt;&gt;&gt; print(exc.get_full_details())\n{'detail':'Service Unavailable','code':'service_unavailable', 'description': 'The server cannot process the request due to a high load'}\n</code></pre>"},{"location":"overview/exception_handling/#exception-handlers","title":"Exception Handlers","text":"<p>Exception Handlers are classes or functions that handle what response that is returned to the client for specific exception types.</p> <p>Here is an example of an ExceptionHandler that handles <code>HTTPException</code> in the application:</p> <p><pre><code>import typing as t\n\nfrom ellar.common.interfaces import IExceptionHandler, IHostContext\nfrom starlette.exceptions import (\n    HTTPException as StarletteHTTPException,\n)\nfrom starlette.responses import Response\n\n\nclass HTTPExceptionHandler(IExceptionHandler):\n    exception_type_or_code = StarletteHTTPException\n\n    async def catch(\n        self, ctx: IHostContext, exc: StarletteHTTPException\n    ) -&gt; t.Union[Response, t.Any]:\n        assert isinstance(exc, StarletteHTTPException)\n        config = ctx.get_app().config\n\n        if exc.status_code in {204, 304}:\n            return Response(status_code=exc.status_code, headers=exc.headers)\n\n        if isinstance(exc.detail, (list, dict)):\n            data = exc.detail\n        else:\n            data = {\"detail\": exc.detail, \"status_code\": exc.status_code}  # type: ignore[assignment]\n\n        return config.DEFAULT_JSON_CLASS(\n            data, status_code=exc.status_code, headers=exc.headers\n        )\n</code></pre> In the example above, <code>HTTPExceptionHandler</code> will be registered in a key-value data structure of exception handlers. Where <code>exception_type_or_code</code> is the key and the <code>HTTPExceptionHandler</code> class is the value. </p> <p>During exception handling, <code>HTTPExceptionHandler.catch</code> method will be called when <code>ExceptionMiddleware</code> detect an exception of type <code>HTTPException</code>. And then, a JSON response is created and returned to the client.</p>"},{"location":"overview/exception_handling/#creating-custom-exception-handler","title":"Creating Custom Exception Handler","text":"<p>To create an exception handler for your custom exception, you need to create a class that follows the <code>IExceptionHandler</code> contract.</p> <p>At the root project folder, create a file named <code>custom_exceptions.py</code>:</p> <pre><code># project_name/custom_exceptions.py\nimport typing as t\nfrom ellar.common import IExceptionHandler, IHostContext\nfrom starlette.responses import Response\n\n\nclass MyCustomException(Exception):\n    pass\n\n\nclass MyCustomExceptionHandler(IExceptionHandler):\n    exception_type_or_code = MyCustomException\n\n    async def catch(\n        self, ctx: IHostContext, exc: MyCustomException\n    ) -&gt; t.Union[Response, t.Any]:\n        app_config = ctx.get_app().config\n        return app_config.DEFAULT_JSON_CLASS(\n            {'detail': str(exc)}, status_code=400,\n        )\n</code></pre> <p>IExceptionHandler Overview:</p> <ul> <li><code>exception_type_or_code</code>: defines the <code>exception class</code> OR <code>status code</code> as a key to identify an exception handler.</li> <li><code>catch()</code>: define the exception handling code and response a <code>Response</code> object to be returned to the client.</li> </ul>"},{"location":"overview/exception_handling/#creating-exception-handler-for-status-code","title":"Creating Exception Handler for status code","text":"<p>Let's create a handler for the <code>MethodNotAllowedException</code>, which corresponds to the HTTP status code <code>405</code>.</p> <p><pre><code># project_name/apps/custom_exceptions.py\nimport typing as t\nfrom ellar.common import IExceptionHandler, IHostContext, render_template\nfrom starlette.responses import Response\nfrom starlette.exceptions import HTTPException\n\nclass MyCustomException(Exception):\n    pass\n\n\nclass MyCustomExceptionHandler(IExceptionHandler):\n    exception_type_or_code = MyCustomException\n\n    async def catch(\n        self, ctx: IHostContext, exc: MyCustomException\n    ) -&gt; t.Union[Response, t.Any]:\n        app_config = ctx.get_app().config\n        return app_config.DEFAULT_JSON_CLASS(\n            {'detail': str(exc)}, status_code=400,\n        )\n\n\nclass ExceptionHandlerAction405(IExceptionHandler):\n    exception_type_or_code = 405\n\n    async def catch(\n        self, ctx: IHostContext, exc: HTTPException\n    ) -&gt; t.Union[Response, t.Any]:\n        context_kwargs = {}\n        return render_template('405.html', **context_kwargs)\n</code></pre> In this code snippet, we've registered a handler for any <code>HTTP</code> exception with a <code>405</code> status code, and we return a template, <code>405.html</code>, as a response.  Similarly, you can create an exception handler for the <code>500</code> status code that returns an HTML template.</p> <p>Info</p> <p>Ellar will search for <code>405.html</code> in all registered modules. So, within the <code>car</code> folder, create a templates folder and add <code>405.html</code>.</p>"},{"location":"overview/exception_handling/#registering-exception-handlers","title":"Registering Exception Handlers","text":"<p>We have successfully created two exception handlers <code>ExceptionHandlerAction405</code> and <code>MyCustomExceptionHandler</code> but they are not yet visible to the application.</p> Using config.pyUsing Application Instance <p>In the <code>config.py</code> file, which holds application settings, you can define custom exception handlers to be registered with the <code>ExceptionMiddlewareService</code> during the application's bootstrapping process.</p> <pre><code># project_name/config.py\nimport typing as t\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.common import IExceptionHandler\nfrom .apps.custom_exceptions import MyCustomExceptionHandler, ExceptionHandlerAction405\n\nclass BaseConfig(ConfigDefaultTypesMixin):\n    EXCEPTION_HANDLERS: t.List[IExceptionHandler] = [\n        MyCustomExceptionHandler(),\n        ExceptionHandlerAction405()\n    ]\n</code></pre> <p>Alternatively, you can add exception handlers directly through the app instance in your application:</p> <pre><code># project_name/server.py\n\nimport os\n\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom .root_module import ApplicationModule\nfrom .apps.custom_exceptions import MyCustomExceptionHandler, ExceptionHandlerAction405\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"project_name.config:DevelopmentConfig\"\n    ),\n)\n\napplication.add_exception_handler(\n    MyCustomExceptionHandler(), \n    ExceptionHandlerAction405()\n)\n</code></pre>"},{"location":"overview/exception_handling/#override-default-exception-handler","title":"Override Default Exception Handler","text":"<p>We have seen how to create an exception handler for status codes or for a specific exception type.  The same applies to when we want to override an existing exception handler in Ellar project.</p> <p>For example:</p> <p><pre><code># project_name/apps/custom_exceptions.py\nimport typing as t\nfrom ellar.common import IHostContext, IExceptionHandler, APIException\nfrom starlette.responses import Response\n\n\nclass OverrideAPIExceptionHandler(IExceptionHandler):\n    exception_type_or_code = APIException\n\n    async def catch(\n        self, ctx: IHostContext, exc: APIException\n    ) -&gt; t.Union[Response, t.Any]:\n        app_config = ctx.get_app().config\n        return app_config.DEFAULT_JSON_CLASS(\n            {'message': exc.detail}, status_code=exc.status_code,\n        )\n</code></pre> Once you register the <code>OverrideAPIExceptionHandler</code> exception handler, it will become the default <code>handler</code> for the <code>APIException</code> exception type.</p>"},{"location":"overview/exception_handling/#declaring-exception-handler-as-a-function","title":"Declaring Exception Handler as a function","text":"<p>In the previous section, we saw how to create a custom ExceptionHandler from <code>IExceptionHandler</code>. In this section, we'll achieve the same result using a plain function.</p> <p>For example, let's say we have a function <code>exception_handler_fun</code> as shown below:</p> <p><pre><code>from starlette.responses import PlainTextResponse\nfrom ellar.common import IExecutionContext\n\n\ndef exception_handler_fun(ctx: IExecutionContext, exc: Exception):\n    return PlainTextResponse('Bad Request', status_code=400)\n</code></pre> To make the <code>exception_handler_fun</code> work as an ExceptionHandler, you will need to use <code>CallableExceptionHandler</code> from the <code>ellar.common.exceptions</code> package:</p> <p><pre><code>from starlette.responses import PlainTextResponse\nfrom ellar.common import IExecutionContext\nfrom ellar.core.exceptions import CallableExceptionHandler, as_exception_handler\n\n\n@as_exception_handler\ndef exception_400_handler(ctx: IExecutionContext, exc: Exception):\n    return PlainTextResponse('Bad Request', status_code=400)\n</code></pre> In the example above, you have created an <code>exception_400_handler</code> Exception Handler to handle HTTP exceptions with a status code of 400.  You can then register it as an exception handler in your configuration, as we did in the previous section:</p> <p>Additionally, We can create a handler to handle custom exception types, as shown below:</p> <p><pre><code>from starlette.responses import PlainTextResponse\nfrom ellar.common import IExecutionContext\nfrom ellar.core.exceptions import as_exception_handler\n\n\nclass CustomException(Exception):\n    pass\n\n\n@as_exception_handler(CustomException)\ndef exception_custom_handler(ctx: IExecutionContext, exc: Exception):\n    return PlainTextResponse('Bad Request', status_code=400)\n</code></pre> In this example, <code>exception_custom_handler</code> is configured to handle a custom exception type, CustomException.</p>"},{"location":"overview/guards/","title":"Guards","text":"<p>A Guard in Ellar is a way to add authentication and authorization checks to your application.  It acts as middleware and runs before executing the route handler.  If the guard returns false, the request is rejected and the execution is stopped. </p> <p>Guards can be used to check for specific roles, permissions, or any other arbitrary condition.  They can be easily applied to individual routes or groups of routes using <code>@guard</code> decorator.</p> <p>Unlike middleware, a guard have access to the <code>ExecutionContext</code> which provides information for the route function to be executed and its controller.</p> <p>Note</p> <p>Guards are executed after all middleware</p>"},{"location":"overview/guards/#authorization-guard","title":"Authorization guard","text":"<p>Authorization is a great example of a guard because some routes should be available only to specific authenticated user and or users that sufficient permissions.  Let's assume we have a <code>AuthGard</code> which checks if a making a request is authenticated.</p> <p><pre><code>from ellar.common import GuardCanActivate, IExecutionContext\nfrom ellar.di import injectable\n\n@injectable()\nclass AuthGuard(GuardCanActivate):\n  async def can_activate(self,context: IExecutionContext) -&gt; bool: \n    request = context.switch_to_http_connection().get_request()\n    return self.validate_request(request)\n\n  def validate_request(self, request) -&gt; bool:\n    ...\n</code></pre> The implementation of the <code>validate_request()</code> function, in the example above, can be simple or complex depending on the use case.  The primary objective is to demonstrate the integration of guards into the request/response cycle.</p> <p>Every guard must inherit from <code>GuardCanActivate</code> and override <code>can_activate()</code> function.  The <code>can_activate()</code> function is required to return a <code>boolean</code> value. The return value determines the next action:</p> <ul> <li>If the function returns <code>true</code>, the request will be processed.</li> <li>If the function returns <code>false</code>, Ellar will reject the request.</li> </ul>"},{"location":"overview/guards/#role-based-authentication","title":"Role-based authentication","text":"<p>Let's build a more functional guard that permits access only to users with a specific role.  We'll start with a basic guard template, and build on it in the coming sections.  For now, it allows all requests to proceed:</p> <pre><code># project_name/cars/guards.py\n\nfrom ellar.common import GuardCanActivate, IExecutionContext\nfrom ellar.di import injectable\n\n@injectable()\nclass RoleGuard(GuardCanActivate):\n  async def can_activate(self,context: IExecutionContext) -&gt; bool: \n    return True\n</code></pre>"},{"location":"overview/guards/#applying-guards","title":"Applying guards","text":"<p>Guards can be <code>controller-scoped</code>, <code>method-scoped</code>, or <code>global-scoped</code>. We apply guards to controllers or route function by using <code>@Guards</code>. The <code>@UseGuards</code> takes a single argument, or a comma-separated list of arguments of <code>GuardCanActivate</code> types or instances.</p> <pre><code>import typing as t\n\ndef UseGuards(\n    *_guards: t.Type[\"GuardCanActivate\"] | \"GuardCanActivate\"\n) -&gt; t.Callable:\n    ...\n</code></pre>"},{"location":"overview/guards/#controller-scoped","title":"Controller-scoped","text":"<p>We set up controller scoped guards on controller by using <code>@UseGuards</code> decorator. For example: <pre><code># project_name/cars/controllers.py\nfrom ellar.common import Controller, UseGuards\nfrom .guards import RoleGuard\n\n@Controller()\n@UseGuards(RoleGuard)\nclass CarsController:\n    ...\n</code></pre> The above example attaches the guard to every handler declared by this controller.  If we wish the guard to apply only to a single method, we apply the <code>@UseGuards()</code> decorator at the method level.</p>"},{"location":"overview/guards/#method-scoped","title":"Method-scoped","text":"<p>We can also use <code>@UseGuards()</code> on route-function when necessary. <pre><code># project_name/cars/controllers.py\nfrom ellar.common import Controller, UseGuards, get\nfrom .guards import RoleGuard\n\n@Controller()\n@UseGuards(RoleGuard)\nclass CarsController:\n    @UseGuards(RoleGuard())\n    @get('/guarded-route')\n    def guarded_route(self):\n        return \"Passed Guard\"\n</code></pre> In the example, we decorated <code>guarded_route</code> with <code>@UseGuards(RoleGuard())</code> with an instance of <code>RoleGuard</code>.  When request execution for <code>/guarded-route</code>, <code>guarded_route</code> guard definition will be precedence over <code>CarsController</code> guard definitions.</p>"},{"location":"overview/guards/#global-scope","title":"Global-scope","text":"<p>Global guards are used across the whole application, for every controller and every route function but individual controller or route function <code>@UseGuards</code> definition can override <code>global</code> scoped guards.</p> <p>Global guards can be applied at application level using <code>use_global_guards</code> as shown below:</p> <p>project_name/server.py<pre><code>import os\n\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom .apps.cars.guards import RoleGuard\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"dialerai.config:DevelopmentConfig\"\n    )\n)\napplication.use_global_guards(RoleGuard, MoreGuards, ...)\n</code></pre> Global Guards can also be applied through Dependency Injection. For instance, in <code>project_name/car/module.py</code>, we can register <code>RoleGuard</code> in the module <code>providers</code> parameter as a Global guards. See illustration below:</p> project_name/car/module.py<pre><code>from ellar.common import Module, GlobalGuard\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container, ProviderConfig\n\nfrom .services import CarRepository\nfrom .controllers import CarController\nfrom .guards import RoleGuard\n\n@Module(\n    controllers=[CarController],\n    providers=[CarRepository, ProviderConfig(GlobalGuard, use_class=RoleGuard)]\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre>"},{"location":"overview/guards/#rounding-up-roleguard","title":"Rounding up RoleGuard","text":"<p>Our <code>RolesGuard</code> is working, but it's not very smart yet. Let's assume we want our <code>RoleGuard</code> to manage user role permissions in a more general context employing the power of <code>ExecutionContext</code> and <code>custom metadata</code>. In <code>CarController</code>, for example, could have different permission schemes for different routes.  Some might be available only for an admin user, and others could be open for everyone. </p> <p><pre><code>from ellar.common import post, set_metadata\n\n...\n@post()\n@set_metadata('roles', ['admin'])\nasync def create(self, payload:Body[CreateCarSerializer]):\n    self.repo.create_car(payload)\n    return 'This action adds a new car'\n...\n</code></pre> In the above example, we attached the <code>roles</code> metadata (roles is a key, while ['admin'] is a particular value) to the <code>create()</code> method.  While this works, it's not good practice to use <code>@set_metadata()</code> directly in your routes. So we can refactor that code as shown below:</p> <pre><code># project_name/role_decorator.py\nimport typing\nfrom ellar.common import set_metadata\n\n\ndef roles(*_roles: str) -&gt; typing.Callable:\n    return set_metadata('roles', list(_roles))\n</code></pre> <p>This approach is much cleaner and more readable, and is strongly typed.  Now that we have a custom <code>@roles()</code> decorator, we can use it to decorate the <code>create()</code> method. <pre><code>...\n@post()\n@role('admin', 'staff')\nasync def create(self, payload:Body[CreateCarSerializer]):\n    self.repo.create_car(payload)\n    return 'This action adds a new car'\n...\n</code></pre></p> <p>Let's now go back and tie this together with our <code>RolesGuard</code>. Currently, it simply returns <code>true</code> in all cases, allowing every request to proceed.  We want to make the return value conditional based on the comparing the roles assigned to the current <code>user</code> to the actual roles required by the current route being processed. </p> <p>In order to access the route's function <code>role(s)</code> (custom metadata), we'll use the <code>Reflector</code> helper class, which is provided out of the box by the framework.</p> <p><pre><code># project_name/apps/cars/guards.py\nimport typing as t\nfrom ellar.di import injectable\nfrom ellar.common import GuardCanActivate, IExecutionContext\nfrom ellar.core.services import Reflector\n\n\n@injectable()\nclass RoleGuard(GuardCanActivate):\n    def __init__(self, reflector: Reflector):\n        self.reflector = reflector\n\n    def match_roles(self, roles: t.List[str], user_roles: t.List[str]) -&gt; bool:\n        for user_role in user_roles:\n            if user_role in roles:\n                return True\n\n        return False\n\n    async def can_activate(self, context: IExecutionContext) -&gt; bool:\n        roles = self.reflector.get('roles', context.get_handler())\n        # request = context.switch_to_http_connection().get_request()\n        # check if user in request object has role\n        if not roles:\n            return True\n\n        request = context.switch_to_http_connection().get_request()\n        user = request.user\n\n        return self.match_roles(roles, user_roles=user.roles)\n</code></pre> Here, we are assuming an authenticated <code>user</code> object exist in request object.</p> <p>When a user with insufficient privileges requests an endpoint, Ellar automatically returns the following response: <pre><code>{\n  \"detail\": \"Forbidden\",\n  \"status_code\": 403\n}\n</code></pre></p> <p>Note that behind the scenes, when a guard returns <code>false</code>, the framework throws a <code>HTTPException</code> with status code 403 .  If you want to return a different error response, you should throw your own specific exception by override <code>raise_exception</code> function as shown below: <pre><code>from ellar.common import APIException, GuardCanActivate\nfrom ellar.di import injectable\nfrom ellar.core import Reflector\n\n@injectable()\nclass RoleGuard(GuardCanActivate):\n    def __init__(self, reflector: Reflector):\n        self.reflector = reflector\n\n    def raise_exception(self) -&gt; None:\n        raise APIException(detail=\"You don't have the permission to perform this action\", status_code=403)\n    ...\n</code></pre> The construct will output the json below when the guard returns <code>false</code> <pre><code>{\n  \"detail\": \"You don't have the permission to perform this action\"\n}\n</code></pre></p>"},{"location":"overview/interceptors/","title":"Interceptors - (AOP) technique","text":"<p>An interceptor is a class marked with the <code>@injectable()</code> decorator and adhering to the <code>EllarInterceptor</code> interface.  They execute additional logic before or after method invocation.</p> <p>Inspired by the principles of Aspect-Oriented Programming (AOP),  interceptors offer several functionalities:</p> <ul> <li>bind extra logic before / after route function execution</li> <li>transform the result returned from a route function</li> <li>transform the exception thrown from a route function</li> <li>extend the basic route function behavior</li> <li>completely override a route function depending on specific conditions (e.g., for caching purposes)</li> </ul>"},{"location":"overview/interceptors/#basic","title":"Basic","text":"<p>Each interceptor class includes an <code>intercept()</code> method, accepting two parameters.  The first parameter is an instance of the <code>ExecutionContext</code> class, which is identical to the object used for guards.  The second parameter is a callable asynchronous function called <code>next_interceptor</code>,  responsible for executing the subsequent interceptor in the execution sequence.</p> <pre><code>import typing as t\nfrom abc import ABC, abstractmethod\nfrom ellar.common import IExecutionContext\n\n\nclass EllarInterceptor(ABC):\n    @abstractmethod\n    async def intercept(\n        self, context: IExecutionContext, next_interceptor: t.Callable[..., t.Coroutine]\n    ) -&gt; t.Any:\n        \"\"\"implementation comes here\"\"\"\n</code></pre> <p>Note</p> <p>The <code>intercept()</code> method within an interceptor class is an asynchronous function.</p>"},{"location":"overview/interceptors/#execution-context","title":"Execution context","text":"<p>The <code>ExecutionContext</code> introduces several auxiliary methods that offer further insights into the ongoing execution process.  This additional information can be valuable for creating more versatile interceptors capable of functioning across various controllers, methods, and execution contexts.  For further details on <code>ExecutionContext</code>, refer to the documentation here.</p>"},{"location":"overview/interceptors/#next-interceptor-handler","title":"Next Interceptor Handler","text":"<p>The <code>next_interceptor</code> parameter in the <code>intercept()</code> method of the <code>EllarInterceptor</code> class serves a crucial role in invoking the route handler method within your interceptor. Omitting the invocation of <code>next_interceptor</code> within your implementation of <code>intercept()</code> will result in the route handler method not being executed.</p> <p>This mechanism essentially encapsulates the request/response cycle within the <code>intercept()</code> method. Consequently, you have the flexibility to incorporate custom logic both before and after the execution of the final route handler. While it's evident how to include code before calling <code>next_interceptor()</code>, influencing the behavior afterward depends on the data returned by <code>next_interceptor()</code>.</p> <p>From the perspective of Aspect-Oriented Programming, the invocation of the route handler (i.e., calling <code>next_interceptor()</code>) represents a Pointcut, denoting the point at which additional logic is injected.</p> <p>For instance, consider an incoming <code>POST /car</code> request targeting the <code>create()</code> handler in the <code>CarController</code>. If an interceptor fails to call <code>next_interceptor()</code> at any point, the <code>create()</code> method won't execute. However, once <code>next_interceptor()</code> is invoked, the <code>create()</code> handler proceeds. Subsequently, upon receiving the response, additional operations can be performed on the returned data before delivering the final result to the client.</p>"},{"location":"overview/interceptors/#aspect-interception","title":"Aspect interception","text":"<p>Here's a simple example demonstrating the use of an interceptor to log user interactions. The LoggingInterceptor intercepts requests before and after the route handler execution to log relevant information such as start time, end time, and duration of execution.</p> <pre><code>import typing as t\nimport logging\nimport time\nfrom ellar.common import EllarInterceptor, IExecutionContext\nfrom ellar.di import injectable\n\nlogger = logging.getLogger('ellar')\n\n@injectable()\nclass LoggingInterceptor(EllarInterceptor):\n    async def intercept(\n        self, context: IExecutionContext, next_interceptor: t.Callable[..., t.Coroutine]\n    ) -&gt; t.Any:\n        logger.info('Before Route Handler Execution...')\n        start_time = time.time()\n\n        # Invoke the next interceptor in the chain (or the route handler)\n        res = await next_interceptor()\n\n        # Log after route handler execution\n        logger.info(f'After Route Handler Execution.... {time.time() - start_time}s')\n\n        return res\n</code></pre> <p>This interceptor captures the timing of the request execution by recording the start time before invoking the route handler and calculating the duration after execution. It utilizes the logging module to output the relevant information.</p> <p>Remember, like other components such as controllers and providers, interceptors can also inject dependencies through their constructor, enabling seamless integration with other parts of the application.</p>"},{"location":"overview/interceptors/#binding-interceptors","title":"Binding interceptors","text":"<p>To set up an interceptor, we utilize the <code>@UseInterceptors()</code> decorator from the <code>ellar.common</code> package. Similar to guards, interceptors can be scoped at the controller level, method level, or globally.</p> <pre><code>from ellar.common import UseInterceptors, Controller\n\n@UseInterceptors(LoggingInterceptor)\n@Controller()\nclass CarController:\n    ...\n</code></pre> <p>In the above code snippet, we apply the <code>UseInterceptors()</code> decorator to the <code>CarController</code> class, specifying <code>LoggingInterceptor</code> as the interceptor to be used. Note that we pass the type of the interceptor (not an instance), allowing the framework to handle instantiation and enabling dependency injection. Alternatively, we can directly pass an instance:</p> <pre><code>from ellar.common import UseInterceptors, Controller\n\n@UseInterceptors(LoggingInterceptor())\n@Controller()\nclass CarController:\n    ...\n</code></pre> <p>This construction attaches the interceptor to every handler declared within the controller. If we want to limit the scope of the interceptor to a specific method, we apply the decorator at the method level.</p> <p>For setting up a global interceptor, we utilize the <code>use_global_interceptors()</code> method of the Ellar application instance:</p> <pre><code>from ellar.app import AppFactory\n\napp = AppFactory.create_from_app_module(ApplicationModule)\napp.use_global_interceptors(LoggingInterceptor())\n# OR\n# app.use_global_interceptors(LoggingInterceptor)\n</code></pre> <p>This approach ensures that the interceptor is applied to every request processed by the Ellar application, regardless of the controller or method handling the request.</p>"},{"location":"overview/interceptors/#exception-handling","title":"Exception Handling","text":"<p>You can also manage exceptions during the request/response cycle before they are handled by system exception handlers.</p> <pre><code>class CustomException(Exception):\n    pass\n\n\n@injectable\nclass InterceptCustomException(EllarInterceptor):\n    async def intercept(\n        self, context: IExecutionContext, next_interceptor: t.Callable[..., t.Coroutine]\n    ) -&gt; t.Any:\n        try:\n            return await next_interceptor()\n        except CustomException as cex:\n            # Access the response object from the context\n            res = context.switch_to_http_connection().get_response()\n            # Set the status code to 400 for a custom exception\n            res.status_code = 400\n            # Return a JSON response with the exception message\n            return {\"message\": str(cex)}\n</code></pre> <p>In the above code, the <code>InterceptCustomException</code> interceptor catches any <code>CustomException</code> raised during the execution of the request/response cycle.  It then modifies the response object to set the status code to 400 and returns a JSON response containing the exception message.  This allows for custom handling of exceptions within the interceptor before they are propagated to the system's exception handlers.</p>"},{"location":"overview/middleware/","title":"Middlewares","text":"<p>Middlewares are functions that are called during requests before hitting a specific route handler. Middleware functions can modify request and response objects during the <code>HTTP</code> or <code>WebSocket</code> connection. </p> <p></p> <p>Ellar Middlewares follows the <code>Starlette ASGI Middleware</code> contract. The middlewares are set up in a pipeline\u00a0fashion that\u00a0creates a chain of request-response cycles.</p> <p>During request, each <code>ASGI</code> Middleware must call another ASGI <code>app</code> passed to it during the middlewares instantiation and <code>await</code> its response.\u00a0</p> <p>Info</p> <p>An <code>ASGI</code> type is any callable that takes <code>scope</code>, <code>receive</code> and <code>send</code> as arguments <pre><code>def app(scope, receive, send):\n    pass\n</code></pre></p> <pre><code># ASGI Middleware Interface\nimport typing as t\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\n\nclass EllarASGIMiddlewareStructure:\n    def __init__(self, app: ASGIApp, **other_options: t.Any):\n        self.app = app\n        self.options = other_options\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        await self.app(scope, receive, send)\n</code></pre> <p>Actions that can be performed by middleware functions:</p> <ul> <li>Execute any code</li> <li>Make changes to request and response objects</li> <li>End the request-response cycle if need be</li> <li>Each middleware class or function must call <code>app</code> or <code>call_next</code> respectively else the request will be left without response</li> </ul>"},{"location":"overview/middleware/#application-middleware","title":"Application Middleware","text":"<p>Ellar applies some ASGI middleware necessary for resource protection, error handling, and context management. They include:</p> <ul> <li><code>CORSMiddleware</code>: - 'Cross-Origin-Resources-Sharing' - Adds appropriate <code>CORS</code> headers to outgoing responses in order to allow cross-origin requests from browsers.</li> <li><code>TrustedHostMiddleware</code>: - Enforces that all incoming requests have a correctly set <code>Host</code> header, in order to guard against HTTP Host Header attacks.</li> <li><code>RequestServiceProviderMiddleware</code>: - This inherits from <code>ServerErrorMiddleware</code>. It provides DI context during request and  also ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode.</li> <li><code>RequestVersioningMiddleware</code>: This computes resource versioning info from request object based on configured resource versioning scheme at the application level.</li> <li><code>ExceptionMiddleware</code>: - Adds exception handlers, so that some common exception raised with the application can be associated with handler functions. For example raising <code>HTTPException(status_code=404)</code> within an endpoint will end up rendering a custom 404 page.</li> <li><code>SessionMiddleware</code>: controls session state using the session strategy configured in the application.   </li> <li><code>IdentityMiddleware</code>: controls all registered authentication schemes and provides user identity to all request</li> </ul>"},{"location":"overview/middleware/#applying-middleware","title":"Applying Middleware","text":"<p>Middleware can be applied through the application <code>config</code> - <code>MIDDLEWARES</code> variable. </p> <p>Let's apply some middleware in our previous project. At the project root level, open <code>config.py</code>.</p> <p>Then apply the <code>GZipMiddleware</code> middleware as shown below.</p> <pre><code># project_name/config.py\nimport typing as t\nfrom ellar.core.middleware import Middleware, GZipMiddleware\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    MIDDLEWARE: t.Sequence[Middleware] = [\n        Middleware(GZipMiddleware, minimum_size=1000)\n    ]\n</code></pre> <p>Hint</p> <p>This is how to apply any <code>ASGI</code> middlewares such as <code>GZipMiddleware</code>, <code>EllarASGIMiddlewareStructure</code>, and others available in\u00a0the <code>Starlette</code> library.</p>"},{"location":"overview/middleware/#dependency-injection","title":"Dependency Injection","text":"<p>In section above, we saw how middleware are registered to the application. But what if the middleware class depends on other services, how then should we configure it?  The <code>Middleware</code> does all the work.</p> <p>For example, lets modify the <code>GZipMiddleware</code> class and make it depend on <code>Config</code> service. <pre><code>from ellar.core import Config\nfrom ellar.core.middleware import GZipMiddleware, Middleware\nfrom ellar.common.types import ASGIApp\n\n\nclass CustomGZipMiddleware(GZipMiddleware):\n    def __init__(self, app: ASGIApp, config: Config, minimum_size: int = 500, compresslevel: int = 9):\n        super().__init__(app, minimum_size, compresslevel)\n        self._config = config\n\n## And in Config.py\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    MIDDLEWARE: list[Middleware] = [\n        Middleware(CustomGZipMiddleware, minimum_size=1000)\n    ]\n</code></pre></p> <p>In the example above, <code>Middleware</code> that wraps <code>CustomGZipMiddleware</code> with ensure dependent classes in <code>CustomGZipMiddleware</code> are resolved when instantiating <code>CustomGZipMiddleware</code> object. As you see, the <code>config</code> value was not provided but will be injected during runtime.</p>"},{"location":"overview/middleware/#function-as-middleware","title":"Function as Middleware","text":"<p>In Modules middleware sections, we saw how you can define middlewares in module.  In similar fashion, we can define a function a register them as middleware.</p> <p>For example: <pre><code># project_name/middleware_function.py\nfrom ellar.common import IHostContext\nfrom ellar.core.middleware import Middleware, FunctionBasedMiddleware\n\n\nasync def my_middleware_function(context: IHostContext, call_next):\n    request = context.switch_to_http_connection().get_request() # for http response only\n    request.state.my_middleware_function_1 = True\n    await call_next()\n\n## And in Config.py\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    MIDDLEWARE: list[Middleware] = [\n        Middleware(FunctionBasedMiddleware, dispatch=my_middleware_function),\n    ]\n</code></pre></p> <p>In above, we created <code>my_middleware_function</code> function then registered as <code>FunctionBasedMiddleware</code> as a dispatch action to be called during request handling lifecycle. It is important to note that <code>dispatch</code> function must take <code>context</code> and <code>call_next</code> as function parameters.</p>"},{"location":"overview/middleware/#starlette-middlewares","title":"Starlette Middlewares","text":"<p>Let's explore other Starlette middlewares and other third party <code>ASGI</code> Middlewares</p>"},{"location":"overview/middleware/#gzipmiddleware","title":"<code>GZipMiddleware</code>","text":"<p>Handles GZip responses for any request that includes <code>\"gzip\"</code> in the Accept-Encoding header. The middleware will handle both standard and streaming responses.</p> <pre><code># project_name/config.py\nimport typing as t\nfrom ellar.core.middleware import Middleware, GZipMiddleware\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    MIDDLEWARE: t.Sequence[Middleware] = [\n        Middleware(GZipMiddleware, minimum_size=1000)\n    ]\n</code></pre> <p>The following arguments are supported:</p> <ul> <li><code>minimum_size</code> - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to <code>500</code>.</li> </ul> <p>The middleware won't GZip responses that already have a Content-Encoding set, to prevent them from being encoded twice.</p>"},{"location":"overview/middleware/#httpsredirectmiddleware","title":"<code>HTTPSRedirectMiddleware</code>","text":"<p>Enforces that all incoming requests must either be <code>https</code> or <code>wss</code>.</p> <p>Any incoming requests to <code>http</code> or <code>ws</code> will be redirected to the secure scheme instead.</p> <pre><code># project_name/config.py\nimport typing as t\nfrom ellar.core.middleware import Middleware, HTTPSRedirectMiddleware\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    MIDDLEWARE: t.Sequence[Middleware] = [\n        Middleware(HTTPSRedirectMiddleware)\n    ]\n</code></pre>"},{"location":"overview/middleware/#trustedhostmiddleware","title":"<code>TrustedHostMiddleware</code>","text":"<p>This middleware is already part of ellar application middlewares. The middleware takes an argument <code>allowed_host</code> which can be configured in the configuration class.</p> <p><pre><code># project_name/config.py\nimport typing as t\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    ALLOWED_HOSTS: t.List[str] = ['example.com', '*.example.com']\n</code></pre> <code>ALLOWED_HOSTS</code> - A list of domain names that should be allowed as hostnames.  Wildcard domains such as <code>*.example.com</code> are supported for matching subdomains.  To allow any hostname either use <code>allowed_hosts=[\"*\"]</code> or omit the middleware.</p> <p>If an incoming request does not validate correctly then a <code>400</code> response will be sent.</p>"},{"location":"overview/middleware/#corsmiddleware","title":"<code>CORSMiddleware</code>","text":"<p>Adds appropriate <code>CORS headers</code> to outgoing responses in order to allow cross-origin requests from browsers.</p> <p>Since <code>CORSMiddleware</code> is part of default application middleware, let's see how to configure CORS arguments in ellar application.</p> <pre><code># project_name/config.py\nimport typing as t\n...\n\nclass DevelopmentConfig(BaseConfig):\n    DEBUG: bool = True\n    # Application middlewares\n    CORS_ALLOW_ORIGINS: t.List[str] = [\"*\"]\n    CORS_ALLOW_METHODS: t.List[str] = [\"*\"]\n    CORS_ALLOW_HEADERS: t.List[str] = [\"*\"]\n\n    CORS_ALLOW_CREDENTIALS: bool = True\n    CORS_ALLOW_ORIGIN_REGEX: t.Optional[str] = None\n    CORS_EXPOSE_HEADERS: t.Sequence[str] = ()\n    CORS_MAX_AGE: int = 600\n</code></pre> <p>The following arguments are supported:</p> <ul> <li><code>CORS_ALLOW_ORIGINS</code> - A list of origins that should be permitted to make cross-origin requests. eg. <code>['https://example.org', 'https://www.example.org']</code>. You can use <code>['*']</code> to allow any origin.</li> <li><code>CORS_ALLOW_ORIGIN_REGEX</code> - A regex string to match against origins that should be permitted to make cross-origin requests. eg. <code>'https://.*\\.example\\.org'</code>.</li> <li><code>CORS_ALLOW_METHODS</code> - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to <code>['GET']</code>. You can use <code>['*']</code> to allow all standard methods.</li> <li><code>CORS_ALLOW_HEADERS</code> - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to <code>[]</code>. You can use <code>['*']</code> to allow all headers. The <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code> and <code>Content-Type</code> headers are always allowed for CORS requests.</li> <li><code>CORS_ALLOW_CREDENTIALS</code> - Indicate that cookies should be supported for cross-origin requests. Defaults to <code>False</code>.</li> <li><code>CORS_EXPOSE_HEADERS</code> - Indicate any response headers that should be made accessible to the browser. Defaults to <code>[]</code>.</li> <li><code>CORS_MAX_AGE</code> - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to <code>600</code>.</li> </ul>"},{"location":"overview/middleware/#cors-preflight-requests","title":"CORS preflight requests","text":"<p>These are any <code>OPTIONS</code> request with <code>Origin</code> and <code>Access-Control-Request-Method</code> headers.</p> <p>In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a <code>200</code> or <code>400</code> response for informational purposes. The middleware responds to two particular types of HTTP request</p>"},{"location":"overview/middleware/#simple-requests","title":"Simple requests","text":"<p>Any request with an <code>Origin</code> header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.</p>"},{"location":"overview/middleware/#other-middlewares","title":"<code>Other Middlewares</code>","text":"<p>There are many other ASGI middlewares. For example:</p> <ul> <li>Sentry</li> <li>Uvicorn's ProxyHeadersMiddleware</li> <li>MessagePack</li> </ul> <p>To see other available middlewares check Starlette's Middleware docs  and the ASGI Awesome List.</p> <p>Technical Details</p> <p>Most of the available middlewares come directly from Starlette. Ellar provides few required for its basic functionalities</p>"},{"location":"overview/module-router/","title":"Module Router","text":"<p><code>ModuleRouter</code> allows you to define your route handlers as standalone functions, offering an alternative to using classes.  This can be advantageous for Python developers who prefer using functions.  Importantly, using <code>ModuleRouter</code> does not restrict your access to other features provided by Ellar.</p>"},{"location":"overview/module-router/#usage","title":"Usage","text":"<p>The Ellar CLI tool automatically generates a <code>routers.py</code> file with every <code>create-module</code> scaffold command.  This file serves as a concise guide on utilizing the <code>ModuleRouter</code> class.</p> <p>Now, let's leverage the routers.py file generated in our prior project to implement two route functions, namely addition and subtraction. <pre><code># project_name/apps/car/routers.py\n\"\"\"\nDefine endpoints routes in python function fashion\nexample:\n\nmy_router = ModuleRouter(\"/cats\", tag=\"Cats\", description=\"Cats Resource description\")\n\n@my_router.get('/')\ndef index(request: Request):\n    return {'detail': 'Welcome to Cats Resource'}\n\"\"\"\nfrom ellar.common import ModuleRouter\nfrom ellar.openapi import ApiTags\n\nmath_router = ModuleRouter('/math')\nopen_api_tag = ApiTags(name='Math')\nopen_api_tag(math_router)\n\n@math_router.get('/add')\ndef addition(a: int, b: int):\n    return a + b\n\n\n@math_router.get('/subtract')\ndef subtraction(a: int, b: int):\n    return a - b\n</code></pre></p> <p>In the provided example, the <code>math_router</code> is created with a prefix <code>/math</code> and an OPENAPI tag 'Math'.  Two routes, <code>addition(a:int, b:int)</code> and <code>subtraction(a:int, b:int)</code>, are added to the router, each handling two query parameters ('a' and 'b') of integer type. These functions perform the specified mathematical operations and return the results.</p> <p>To make the <code>math_router</code> visible to the application, it is registered with the current injector using <code>current_injector.register(ModuleRouter, math_router)</code>. This step ensures that the router is recognized and accessible within the application.</p>"},{"location":"overview/module-router/#registering-module-router","title":"Registering Module Router","text":"<p>Like controllers, ModuleRouters also need to be registered to their root module to be used in a web application.  In the example provided above, the <code>math_router</code> would be registered under the <code>project_name/apps/car/module.py</code> file.</p> <p>This registration process typically involves importing the <code>math_router</code> and then adding it to the list of <code>routers</code> in the <code>module.py</code> file.  This allows the router to be recognized by the application and its routes to be available to handle requests.</p> <pre><code>from ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\n\nfrom .controllers import CarController\nfrom .routers import math_router\n\n\n@Module(\n    controllers=[CarController],\n    providers=[],\n    routers=[math_router],\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre> <p></p>"},{"location":"overview/module-router/#accessing-other-request-object","title":"Accessing Other Request Object","text":"<p>In functional route handle, we can access request object and response object through custom decorators or type annotation as shown below.</p>"},{"location":"overview/module-router/#by-type-annotation","title":"By Type Annotation","text":"<p>Let's inject request and response object in <code>addition</code> route handler function from our previous example</p> <pre><code>from ellar.core import Request\nfrom ellar.common import ModuleRouter, Response\n\n\nmath_router = ModuleRouter('/math', name='Math')\n\n@math_router.get('/add')\ndef addition(request: Request, res: Response, a:int, b:int):\n    res.headers['x-operation'] = 'Addition'\n    return dict(is_request_object=isinstance(request, Request), is_response_object=isinstance(res, Response), operation_result=a + b)\n</code></pre>"},{"location":"overview/module-router/#by-custom-decorators","title":"By Custom decorators","text":"<p>You can also achieve the same result by using custom decorator.</p> <pre><code>from ellar.core import Request\nfrom ellar.common import ModuleRouter,Response, Inject\n\n\nmath_router = ModuleRouter('/math', name='Math')\n\n@math_router.get('/add')\ndef addition(request:Inject[Request], res:Inject[Response], a:int, b:int):\n    res.headers['x-operation'] = 'Addition'\n    return dict(is_request_object=isinstance(request, Request), is_response_object=isinstance(res, Response), operation_result=a + b)\n</code></pre> <p></p>"},{"location":"overview/module-router/#inject-services","title":"Inject Services","text":"<p>We can also inject service providers just like controller routes using the <code>Provide</code> function.</p> <pre><code>from ellar.core import Config\nfrom ellar.common import ModuleRouter, Response, Inject\n\n\nmath_router = ModuleRouter('/math', name='Math')\n\n@math_router.get('/subtract')\ndef subtraction(a:int, b:int, res:Response, config:Inject[Config]):\n    res.headers['x-operation'] = 'Subtraction'\n    return dict(\n        is_config=isinstance(config, Config),\n        operation_result=a - b\n    )\n</code></pre>"},{"location":"overview/modules/","title":"Modules","text":"<p>A module in Ellar is essentially a class marked with the <code>@Module()</code> decorator.  This simple yet powerful annotation serves as the cornerstone of defining the architecture and organization of an application.</p> <p></p> <p>Embracing the modular approach, each module encapsulates a specific set of functionalities, ensuring a clear separation of concerns within the application. The <code>ApplicationModule</code> typically acts as the root module, orchestrating the composition of various submodules.</p> <p>This modular structure enables efficient management of dependencies, promotes code reusability, and enhances maintainability  by facilitating clear boundaries between different components of the application. By structuring the application into modules,  developers can easily reason about the codebase, foster collaboration among team members, and scale the application seamlessly.</p>"},{"location":"overview/modules/#feature-modules","title":"Feature modules","text":"<p>Developing an application as a collection of feature modules grouped together offers several advantages. It helps in managing complexity, maintains a codebase that is both extendable and testable, and promotes adherence to SOLID principles.</p> <p>A prime example of a feature module is the car project. In this project, the <code>CarModule</code> encapsulates all the services and controllers responsible for handling the <code>car</code> resource. This modular structure simplifies maintenance, extension, and testing of the codebase.</p> <pre><code># project_name/apps/car/module.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\nfrom .services import CarRepository\nfrom .controllers import CarController\n\n\n@Module(\n    controllers=[CarController],\n    providers=[CarRepository],\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # Additional provider registrations can be done here\n        pass\n</code></pre>"},{"location":"overview/modules/#module-parameters","title":"Module Parameters","text":"<p>Let's create a Module and take a quick overview of its parameters.</p> <pre><code>from ellar.common import Module\nfrom ellar.core import ModuleBase\n\n@Module(\n    name='', \n    modules=[], \n    providers=[],\n    controllers=[],\n    exports=[],\n    routers=[],\n    commands=[],\n    base_directory=None, \n    static_folder='static', \n    template_folder='templates'\n)\nclass BookModule(ModuleBase):\n    pass\n</code></pre> Parameter Description <code>name</code> The name of the module. It's relevant for identification purposes. <code>modules</code> A list of dependencies required by this module. <code>providers</code> Providers to be instantiated by the Ellar injector, possibly shared across this module. <code>exports</code> List of services accessible at application scope level. <code>controllers</code> Controllers defined in this module that need instantiation. <code>routers</code> ModuleRouters defined in this module. <code>commands</code> Functions decorated with <code>EllarTyper</code> or <code>command</code> that serve as commands. <code>base_directory</code> The root directory for this module, used to locate <code>static_folder</code> and <code>template_folder</code>. Default is the module's root. <code>static_folder</code> The folder for static files within this module. Default is 'static'. <code>template_folder</code> The folder for templates within this module. Default is 'templates'."},{"location":"overview/modules/#additional-module-configurations","title":"Additional Module Configurations","text":"<p>The Ellar framework offers additional module configurations to handle various aspects of the application lifecycle and behavior.</p>"},{"location":"overview/modules/#module-events","title":"Module Events","text":"<p>Modules can define <code>post_build</code> class method can be used to define additional <code>Module</code> properties after <code>Module</code> has built successfully.</p> <pre><code>from ellar.common import Module\nfrom ellar.core.modules import ModuleBase, ModuleRefBase\n\n\n@Module()\nclass ModuleEventSample(ModuleBase):\n    @classmethod\n    def post_build(cls, module_ref: ModuleRefBase) -&gt; None:\n        \"\"\"Executed after a module build process is done\"\"\"\n</code></pre>"},{"location":"overview/modules/#module-application-cycle","title":"Module Application Cycle","text":"<p>Ellar follows a two-phase application lifecycle with <code>on_startup</code> and <code>on_shutdown</code> events managed by <code>EllarApplicationLifespan</code>.</p> <pre><code>from ellar.common import Module, IApplicationShutdown, IApplicationStartup\nfrom ellar.core import ModuleBase\n\n@Module()\nclass AModuleSample(ModuleBase, IApplicationStartup):\n    async def on_startup(self, app: \"App\") -&gt; None:\n        pass\n\n@Module()\nclass BModuleSample(ModuleBase, IApplicationShutdown):\n    async def on_shutdown(self) -&gt; None:\n        pass\n\n@Module()\nclass CModuleSample(ModuleBase, IApplicationStartup, IApplicationShutdown):\n    async def on_startup(self, app: \"App\") -&gt; None:\n        pass\n\n    async def on_shutdown(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"overview/modules/#module-exceptions","title":"Module Exceptions","text":"<p>Modules can register custom exception handlers for specific HTTP error codes.</p> <pre><code>from ellar.common import Module, exception_handler, JSONResponse, Response, IHostContext\nfrom ellar.core import ModuleBase\n\n@Module()\nclass ModuleExceptionSample(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(self, context: IHostContext, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"))\n</code></pre>"},{"location":"overview/modules/#module-templating-filters","title":"Module Templating Filters","text":"<p>Define Jinja2 templating filters within modules, which are then added to the Jinja2 environment instance during template loading.</p> <pre><code>from ellar.common import Module, template_global, template_filter\nfrom ellar.core import ModuleBase\n\n@Module()\nclass ModuleTemplateFilterSample(ModuleBase):\n    @template_filter()\n    def double_filter(self, n):\n        return n * 2\n\n    @template_global()\n    def double_global(self, n):\n        return n * 2\n\n    @template_filter(name=\"dec_filter\")\n    def double_filter_dec(self, n):\n        return n * 2\n</code></pre> <p>These configurations enhance the flexibility and functionality of Ellar modules,  allowing for greater control over application behavior and lifecycle events.</p>"},{"location":"overview/modules/#dependency-injection","title":"Dependency Injection","text":"<p>A module class can inject providers, such as configuration objects, for various purposes. Let's consider an example from our sample project where we inject <code>Config</code> into the <code>CarModule</code>.</p> <pre><code># project_name/apps/car/module.py\n\nfrom ellar.common import Module\nfrom ellar.core import Config, ModuleBase\nfrom ellar.di import Container\nfrom .services import CarRepository\nfrom .controllers import CarController\n\n\n@Module(\n    controllers=[CarController],\n    providers=[CarRepository],\n)\nclass CarModule(ModuleBase):\n    def __init__(self, config: Config):\n        self.config = config\n\n    def register_providers(self, container: Container) -&gt; None:\n        # Additional provider registrations can be performed here\n        pass\n</code></pre> <p>In this example, the <code>CarModule</code> class accepts a <code>Config</code> object in its constructor.  This allows us to access configuration parameters within the module.  Additionally, the <code>register_providers</code> method can be utilized for more advanced provider registrations within the container.</p>"},{"location":"overview/modules/#module-middleware","title":"Module Middleware","text":"<p>Middleware functions can be defined at the module level using the <code>@middleware()</code> function decorator. Let's illustrate this with an example:</p> <pre><code>from ellar.common import Module, middleware, IHostContext, PlainTextResponse\nfrom ellar.core import ModuleBase\n\n\n@Module()\nclass ModuleMiddlewareSample(ModuleBase):\n    @middleware()\n    async def my_middleware_function_1(self, context: IHostContext, call_next):\n        request = context.switch_to_http_connection().get_request() # for HTTP response only\n        request.state.my_middleware_function_1 = True\n        await call_next()\n\n    @middleware()\n    async def my_middleware_function_2(self, context: IHostContext, call_next):\n        if context.get_type() == 'websocket':\n            websocket = context.switch_to_websocket().get_client()\n            websocket.state.my_middleware_function_2 = True\n        await call_next()\n\n    @middleware()\n    async def my_middleware_function_3(self, context: IHostContext, call_next):\n        connection = context.switch_to_http_connection().get_client() # for HTTP response only\n        if connection.headers['somekey']:\n            # response = context.get_response() -&gt; use the `response` to add extra definitions to things you want to see on\n            return PlainTextResponse('Header is not allowed.')\n        await call_next()\n</code></pre> <p>Key points to remember: - Middleware functions must be asynchronous (<code>async</code>). - Middleware functions can return a response or modify a response returned. - Middleware functions must call <code>call_next()</code> and await its actions as demonstrated above.</p>"},{"location":"overview/modules/#injector-module","title":"Injector Module","text":"<p>The <code>EllarInjector</code> module, built on top of the Python library <code>injector</code>, offers similar features to the <code>injector</code>  library, with some additional capabilities. One such feature is the ability to create or reuse modules from <code>injector</code>  Modules for configuring bindings and providers for dependency injection.</p> <pre><code>from ellar.core import ModuleBase\nfrom ellar.di import Container\nfrom injector import provider\n\n\nclass Name(str):\n    pass\n\n\nclass Description(str):\n    pass\n\n\nclass ExampleModule(ModuleBase):\n    def register_services(self, container: Container) -&gt; None:\n        container.bind(Name, to='Sherlock')\n\n    @provider\n    def describe(self, name: Name) -&gt; Description:\n        return Description('%s is a man of astounding insight' % name)\n</code></pre> <p>In this example, the <code>ExampleModule</code> registers the <code>Description</code> and <code>Name</code> types with the injector.  These can then be resolved if required by any object in the application.</p> <p>For more details on the use cases of the <code>injector</code> module,  you can refer to the documentation here.</p>"},{"location":"overview/modules/#forwardrefmodule","title":"ForwardRefModule","text":"<p><code>ForwardRefModule</code> is a powerful feature that allows you to reference a <code>@Module()</code> class in your application  without needing to instantiate or configure it directly at the point of reference.  This is particularly useful in scenarios where you have circular dependencies between modules  or when you want to declare dependencies without tightly coupling your modules.</p>"},{"location":"overview/modules/#forward-reference-by-class","title":"Forward Reference by Class","text":"<p>In the following example, we have two modules, <code>ModuleA</code> and <code>ModuleB</code>. <code>ModuleB</code>  needs to reference <code>ModuleA</code> as a dependency, but instead of instantiating <code>ModuleA</code>  directly, it uses <code>ForwardRefModule</code> to declare the dependency.</p> <pre><code>from ellar.common import Module\nfrom ellar.core.modules import ForwardRefModule, ModuleBase, ModuleRefBase\n\n@Module(name=\"moduleA\")\nclass ModuleA:\n    pass\n\n\n@Module(name=\"ModuleB\", modules=[ForwardRefModule(ModuleA)])\nclass ModuleB(ModuleBase):\n    @classmethod\n    def post_build(cls, module_ref: ModuleRefBase) -&gt; None:\n        assert ModuleA in module_ref.modules\n\n\n@Module(modules=[ModuleA, ModuleB])\nclass ApplicationModule(ModuleBase):\n    pass\n</code></pre> <p>In this example: - <code>ModuleB</code> references <code>ModuleA</code> using <code>ForwardRefModule</code>, meaning <code>ModuleB</code> knows about <code>ModuleA</code> but doesn't instantiate it. - When <code>ApplicationModule</code> is built, both <code>ModuleA</code> and <code>ModuleB</code> are instantiated. During this build process, <code>ModuleB</code> can reference the instance of <code>ModuleA</code>, ensuring that all dependencies are resolved properly.</p> <p>This pattern is particularly useful when modules need to reference each other, creating a situation where they might otherwise be instantiated out of order or cause circular dependencies.</p>"},{"location":"overview/modules/#forward-reference-by-name","title":"Forward Reference by Name","text":"<p><code>ForwardRefModule</code> also supports referencing a module by its name, allowing for even more flexibility. This is beneficial when module classes are defined in separate files or when the module class may not be available at the time of reference.</p> <pre><code>from ellar.common import Module\nfrom ellar.core.modules import ForwardRefModule, ModuleBase, ModuleRefBase\n\n@Module(name=\"moduleA\")\nclass ModuleA:\n    pass\n\n\n@Module(name=\"ModuleB\", modules=[ForwardRefModule(module_name=\"moduleA\")])\nclass ModuleB(ModuleBase):\n    @classmethod\n    def post_build(cls, module_ref: ModuleRefBase) -&gt; None:\n        assert ModuleA in module_ref.modules\n\n\n@Module(modules=[ModuleA, ModuleB])\nclass ApplicationModule(ModuleBase):\n    pass\n</code></pre> <p>In this second example: - <code>ModuleB</code> references <code>ModuleA</code> by its name, <code>\"moduleA\"</code>.  - During the build process of <code>ApplicationModule</code>, the name reference is resolved, ensuring that <code>ModuleA</code> is instantiated and injected into <code>ModuleB</code> correctly.</p> <p>This method allows you to define module dependencies without worrying about the order of their definition,  providing greater modularity and flexibility in your application's architecture.</p> <p>By using <code>ForwardRefModule</code>, you can build complex,  interdependent module structures without running into  issues related to instantiation order or circular dependencies,  making your codebase more maintainable and easier to manage.</p>"},{"location":"overview/providers/","title":"Providers","text":"<p>A provider is any class or object that can be injected as a dependency when creating an instance of another class.  These can include services, repository services, factories, and other classes responsible for handling complex tasks.  Providers are made accessible to controllers, route handlers, or other providers as dependencies, following the principles of Dependency Injection.</p> <p>In Ellar, creating a provider or injectable class is simplified by decorating the class with the <code>@injectable()</code> marker and specifying the desired scope.</p> <pre><code>from ellar.di import injectable, singleton_scope\n\n@injectable(scope=singleton_scope)\nclass UserRepository:\n    pass\n</code></pre> <p>For example, we've created a UserRepository provider to manage the loading and saving of user data to the database.</p> <p>Now, let's integrate this service into a controller.</p> <pre><code>from ellar.di import injectable, singleton_scope\nfrom ellar.common import Controller, ControllerBase\n\n@injectable(scope=singleton_scope)\nclass UserRepository:\n    pass\n\n@Controller()\nclass UserController(ControllerBase):\n    def __init__(self, user_repo: UserRepository) -&gt; None:\n        self.user_repo = user_repo\n</code></pre> <p>We've added the UserRepository as a dependency to the UserController,  ensuring that Ellar resolves the UserRepository instance when creating the UserController instance.</p> <p>Next, let's refactor our CarController and move some actions to a service.</p> <pre><code># project_name/apps/car/services.py\nimport typing as t\nfrom ellar.di import injectable, singleton_scope\nfrom .schemas import CreateCarSerializer, CarSerializer\n\n@injectable(scope=singleton_scope)\nclass CarRepository:\n    def __init__(self):\n        self._cars: t.List[CarSerializer] = []\n\n    def create_car(self, data: CreateCarSerializer) -&gt; dict:\n        data = CarSerializer(id=len(self._cars) + 1, **data.dict())\n        self._cars.append(data)\n        return data.dict()\n\n    def get_all(self) -&gt; t.List[CarSerializer]:\n        return self._cars\n</code></pre> <p>We've created a CarRepository with a singleton scope to handle car-related operations.</p> <p>Now, let's wire it up to CarController and rewrite some route handlers.</p> <pre><code># project_name/apps/car/controllers.py\nfrom ellar.common import Body, Controller, get, post, Query, ControllerBase\nfrom .schemas import CreateCarSerializer, CarListFilter\nfrom .services import CarRepository\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    def __init__(self, repo: CarRepository):\n        self.repo = repo\n\n    @post()\n    async def create(self, payload: CreateCarSerializer = Body()):\n        result = self.repo.create_car(payload)\n        result.update(message='This action adds a new car')\n        return result\n\n    @get()\n    async def get_all(self, query: CarListFilter = Query()):\n        res = dict(\n            cars=self.repo.get_all(), \n            message=f'This action returns all cars at limit={query.limit}, offset={query.offset}')\n        return res\n\n    ...\n</code></pre> <p>By defining CarRepository as a dependency for CarController, Ellar automatically resolves the CarRepository instance when creating the CarController instance.</p> <p>Note that every class dependency should be defined in the class constructor as a type annotation to ensure that Ellar is aware of the dependencies required for object instantiation.</p>"},{"location":"overview/providers/#provider-registration","title":"Provider Registration","text":"<p>In order to make the <code>CarRepository</code> accessible within the <code>CarModule</code>, similar to how we exposed the <code>CarController</code>,  we need to include it in the list of providers within the <code>CarModule</code>.</p> <pre><code># project_name/apps/car/module.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\nfrom .services import CarRepository\nfrom .controllers import CarController\n\n@Module(\n    controllers=[CarController],\n    providers=[CarRepository],  # Include CarRepository in the list of providers\n    routers=[],\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre> <p>By adding <code>CarRepository</code> to the list of providers, Ellar ensures that it is available for dependency injection within the <code>CarModule</code>.  This allows us to use <code>CarRepository</code> within any class or object defined within the <code>CarModule</code>,  providing a seamless integration of services and controllers within the module.</p>"},{"location":"overview/providers/#other-ways-of-registering-a-providerservices","title":"Other ways of registering a Provider/Services","text":"<p>There are two methods available for registering or configuring providers in EllarInjector IoC.</p>"},{"location":"overview/providers/#1-providerconfig","title":"1. <code>ProviderConfig</code>:","text":"<p>With <code>ProviderConfig</code>, you can register a <code>base_type</code> against a <code>concrete_type</code> or a <code>base_type</code> against a value type.</p> <p>For instance: <pre><code># main.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase, Config\nfrom ellar.di import ProviderConfig, injectable, EllarInjector\nfrom ellar.core.modules.ref import create_module_ref_factor\n\ninjector = EllarInjector(auto_bind=False)\n\n\nclass IFoo:\n    pass\n\n\nclass IFooB:\n    pass\n\n\n@injectable\nclass AFooClass(IFoo, IFooB):\n    pass\n\n\na_foo_instance = AFooClass()\n\n\n@Module(\n    providers=[\n        ProviderConfig(IFoo, use_class=AFooClass),\n        ProviderConfig(IFooB, use_value=a_foo_instance)\n    ]\n)\nclass AModule(ModuleBase):\n    def __init__(self, ifoo: IFoo, ifoo_b: IFooB):\n        self.ifoo = ifoo\n        self.ifoo_b = ifoo_b\n\n\ndef validate_provider_config():\n    module_ref = create_module_ref_factor(\n      AModule, container=injector.container, config=Config(),\n    )\n    module_ref.run_module_register_services()\n    a_module_instance = injector.get(AModule)\n\n    assert isinstance(a_module_instance.ifoo, AFooClass)\n    assert isinstance(a_module_instance.ifoo_b, AFooClass)\n    assert a_module_instance.ifoo_b == a_foo_instance\n\n\nif __name__ == \"__main__\":\n    validate_provider_config()\n</code></pre></p> <p>In the above example, <code>ProviderConfig</code> is used as a value type for <code>IFooB</code> and as a concrete type for <code>IFoo</code>.</p>"},{"location":"overview/providers/#2-register_providers","title":"2. <code>register_providers</code>:","text":"<p>Another method is by overriding <code>register_services</code> in any Module class.</p> <p>For example: <pre><code># main.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase, Config\nfrom ellar.di import Container, EllarInjector, injectable\nfrom ellar.core.modules.ref import create_module_ref_factor\n\ninjector = EllarInjector(auto_bind=False)\n\n\nclass IFoo:\n    pass\n\n\nclass IFooB:\n    pass\n\n\n@injectable\nclass AFooClass(IFoo, IFooB):\n    pass\n\n\na_foo_instance = AFooClass()\n\n\n@Module()\nclass AModule(ModuleBase):\n    def register_services(self, container: Container) -&gt; None:\n        container.register(IFoo, AFooClass)\n        container.register(IFooB, a_foo_instance)\n\n\ndef validate_register_services():\n    module_ref = create_module_ref_factor(\n       AModule, container=injector.container, config=Config(),\n    )\n    module_ref.run_module_register_services()\n\n    ifoo_b = injector.get(IFooB)\n    ifoo = injector.get(IFoo)\n\n    assert isinstance(ifoo_b, AFooClass)\n    assert isinstance(ifoo, AFooClass)\n    assert ifoo_b == a_foo_instance\n\nif __name__ == \"__main__\":\n    validate_register_services()\n</code></pre></p> <p>In the illustration above, the <code>AModule</code> <code>register_services</code> method was used to register <code>IFoo</code> and <code>IFooB</code> with their respective concrete implementations.</p>"},{"location":"overview/providers/#tagging-registered-providers","title":"Tagging Registered Providers","text":"<p>There are situations where you want to tag a service with a name and also resolve the service with the tag.</p> <p>For example:</p> <pre><code>from ellar.di import EllarInjector\n\ninjector = EllarInjector(auto_bind=False)\n\n\nclass Foo:\n    pass\n\n\nclass FooB:\n    pass\n\ninjector.container.register_singleton(Foo, tag=\"first_foo\")\ninjector.container.register(FooB, tag=\"second_foo\")\n\nfirst_foo_instance = injector.get(\"first_foo\")\nsecond_foo_instance = injector.get(\"second_foo\")\n\nassert first_foo_instance is injector.get(Foo)\nassert isinstance(second_foo_instance, Foo)\n</code></pre> <p>In the above example, we are tagging <code>Foo</code> as <code>first_foo</code> and <code>FooB</code> as <code>second_foo</code>. By doing this, we can resolve both services using their tag names, thus providing the possibility of resolving services by tag name or type.</p> <p>Also, services can be injected as a dependency by using tags. To achieve this, the <code>InjectByTag</code> decorator is used.</p> <p>For example:</p> <pre><code>from ellar.di import EllarInjector, InjectByTag, scopes\n\ninjector = EllarInjector(auto_bind=False)\n\n\nclass Foo:\n    name: str = \"foo\"\n\n\nclass FooB:\n    def __init__(self, foo: InjectByTag(\"fooTag\")):\n        self.foo = foo\n\ninjector.container.register(Foo, tag=\"fooTag\", scope=scopes.singleton_scope)\ninjector.container.register(FooB)\n\nassert injector.get(FooB).foo == 'foo'\n</code></pre> <p>This allows for more flexibility in managing dependencies and resolving services based on tags.</p>"},{"location":"overview/step-one/","title":"Step One","text":"<p>You will learn the core fundamentals of Ellar with this set of articles. We are going to build a basic CRUD application with features that cover a lot of ground at an introductory level.</p>"},{"location":"overview/step-one/#library-dependencies","title":"Library Dependencies","text":"<p>Ellar core depends on:</p> <ul> <li><code>python &gt;= 3.7</code></li> <li><code>Starlette</code></li> <li><code>Injector</code></li> </ul>"},{"location":"overview/step-one/#quick-step","title":"Quick Step","text":"<p>Using the Ellar CLI, you can easily set up a new project by running the following commands in your OS terminal: <pre><code>$(venv) pip install ellar-cli\n$(venv) ellar new project-name\n</code></pre></p> <p>The <code>new</code> command will create a <code>project-name</code> project directory with other necessary files needed for the Ellar CLI tool to properly manage your project. Also, some boilerplate files are populated and installed in a new <code>project_name</code> to get structure to your project.</p> <pre><code>project-name/\n\u251c\u2500 project_name/\n\u2502  \u251c\u2500 core/\n\u2502  \u251c\u2500 domain/\n\u2502  \u251c\u2500 config.py\n\u2502  \u251c\u2500 root_module.py\n\u2502  \u251c\u2500 server.py\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 tests/\n\u2502  \u251c\u2500 __init__.py\n\u251c\u2500 pyproject.toml\n\u251c\u2500 README.md\n</code></pre> <p>A brief overview of generated core files:</p> <code>pyproject.toml</code> Python project metadata store. <code>README.md</code> Project Description and documentation. <code>project_name.core</code> Core/business logic folder. <code>project_name.domain</code> Domain logic folder. <code>project_name.config</code> Application configuration file <code>project_name.root_module</code> The root module of the application <code>project_name.server</code> The entry file of the application which uses the core function <code>AppFactory</code> to create an application instance. <p>In <code>project_name.server</code>, we create the <code>application</code> instance using the <code>AppFactory.create_from_app_module</code> function. <pre><code># project_name/server.py\nimport os\n\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.app import AppFactory\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"project_name.config:DevelopmentConfig\"\n    ),\n)\n</code></pre></p> <p>There are two ways to create an Ellar application using the <code>AppFactory</code>, <code>create_from_app_module</code> and <code>create_app</code>. Both provides all necessary parameter for creating Ellar application</p>"},{"location":"overview/step-one/#run-your-project","title":"Run your project","text":"<p>Ellar runs UVICORN - ASGI Server under the hood.</p> <p><pre><code>$(venv) cd project-name\n$(venv) ellar runserver --reload\n</code></pre> <code>--reload</code> is to watch for file changes</p> <pre><code>INFO:     Will watch for changes in these directories: ['/home/user/working-directory']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [2934815] using WatchFiles\nINFO:     APP SETTINGS MODULE: project_name.config:DevelopmentConfig\nINFO:     Started server process [2934818]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>Now go to http://127.0.0.1:8000 </p> <p>For more info on Ellar CLI, click here</p> <p>To run the application with a different configuration, In <code>project_name/config</code>, Add a <code>ProductionConfig</code></p> <p><pre><code>...\n\nclass ProductionConfig(BaseConfig):\n    DEBUG: bool = False\n</code></pre> Next, export <code>ProductionConfig</code> string import to the environment with <code>ELLAR_CONFIG_MODULE</code> as key.</p> <pre><code>$(venv) export ELLAR_CONFIG_MODULE='project_name.config:ProductionConfig'\n$(venv) ellar runserver\n</code></pre> <p>That will start up the application using <code>ProductionConfig</code> <pre><code>INFO:     APP SETTINGS MODULE: project_name.config:ProductionConfig\nINFO:     Started server process [2934818]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre></p> <p>One last thing, before we move to the next page, we need to create an app <code>module</code>.</p> <p>Lets add a <code>car</code> module/app to our project: <pre><code>$(venv) ellar create-module car apps/\n</code></pre> The result of this CLI command is stored in <code>project-name/project_name/apps</code> <pre><code>apps/\n\u251c\u2500 car/\n\u2502  \u251c\u2500 controllers.py\n\u2502  \u251c\u2500 module.py\n\u2502  \u251c\u2500 schemas.py\n\u2502  \u251c\u2500 services.py\n\u2502  \u251c\u2500 __init__.py\n</code></pre> Brief overview of the generated files:</p> <code>car.controllers</code> A basic controller with an <code>index</code> route. <code>car.module.py</code> car module/app <code>Module</code> metadata definition. <code>car.services.py</code> For Car module service declarations. <code>car.schemas.py</code> Data-transfer-object or Serializers declarations. <p>To finish up with the created <code>car</code> module, we need to register it to the  <code>project_name.root_module.py</code></p> <p><pre><code># project_name/root_module.py\n...\nfrom .apps.cars.module import CarModule\n\n\n@Module(modules=[HomeModule, CarModule])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, request: Request, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"))\n</code></pre> That's it.</p> <p>Goto your browser and visit: http://localhost:8000/car/ <pre><code>{\n  \"detail\": \"Welcome Car Resource\"\n}\n</code></pre></p>"},{"location":"overview/step-one/#enabling-openapi-docs","title":"Enabling OpenAPI Docs","text":"<p>To set up OPENAPI documentation, we need to go back to the project folder. In the <code>server.py</code> then add the below. <pre><code># project_name/server.py\n\nimport os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.app import AppFactory\nfrom ellar.openapi import OpenAPIDocumentModule, OpenAPIDocumentBuilder, SwaggerUI\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"project_name.config:DevelopmentConfig\"\n    ),\n)\n\ndocument_builder = OpenAPIDocumentBuilder()\ndocument_builder.set_title('Project Name API') \\\n    .set_version('1.0.0') \\\n    .set_contact(name='Eadwin', url='https://www.yahoo.com', email='eadwin@gmail.com') \\\n    .set_license('MIT Licence', url='https://www.google.com')\n\ndocument = document_builder.build_document(application)\nOpenAPIDocumentModule.setup(\n    app=application,\n    docs_ui=SwaggerUI(),\n    document=document,\n    guards=[]\n)\n</code></pre></p> <p>Goto your browser and visit: http://localhost:8000/docs/</p>"},{"location":"security/authorization/","title":"Coming Soon","text":""},{"location":"security/csrf/","title":"CSRF or XSRF","text":"<p>CSRF or XSRF is a security vulnerability and attack method in web applications. It involves tricking a user's browser  into sending unauthorized requests to a website where the user is authenticated, allowing attackers to perform actions on behalf of the user.</p>"},{"location":"security/csrf/#available-asgi-csrf-middlewares","title":"Available ASGI CSRF Middlewares","text":"<ul> <li>Piccolo CSRF Middleware</li> <li>Starlette CSRF</li> </ul> <p>These middlewares can be configured as every other asgi middleware as shown in middleware docs to work in Ellar</p> <p>For example, using Starlette CSRF Middleware <pre><code># config.py\nimport typing as t\nfrom ellar.core.middleware import Middleware\nfrom ellar.core.conf import ConfigDefaultTypesMixin\nfrom starlette_csrf import CSRFMiddleware\n\nclass Development(ConfigDefaultTypesMixin):\n    DEBUG: bool = True\n    SECRET_KEY = \"xxxxxxxxxxxxxx\"\n    # Application middlewares\n    MIDDLEWARE: t.Sequence[Middleware] = [\n        Middleware(\n            CSRFMiddleware, \n            secret=SECRET_KEY, \n            cookie_name='csrftoken', \n            safe_methods={\"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\"}\n        )\n    ]\n</code></pre></p>"},{"location":"security/csrf/#cors","title":"CORS","text":"<p>Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from another domain.  Under the hood, Ellar registers CORS Middleware and provides CORS options in application for CORS customization. See how to configure CORS here</p>"},{"location":"security/encryption_and_hashing/","title":"Encryption and Hashing","text":"<p>Encryption is the method of transforming data. This process changes the original information, referred to as plaintext,  into an alternative form called ciphertext.  The goal is to ensure that only authorized parties possess the capability to decrypt ciphertext back into plaintext and access the original information.  Encryption doesn't inherently prevent interference but rather restricts the intelligible content from potential interceptors.  Encryption is a bidirectional operation; what's encrypted can be decrypted using the correct key.</p> <p>Hashing is the process of converting a given key into another value.  A hash function is employed to create this new value following a mathematical algorithm.  After hashing is applied, it should be practically impossible to reverse the process and derive the original  input from the output.</p>"},{"location":"security/encryption_and_hashing/#encryption","title":"Encryption","text":"<p>In Python, the <code>cryptography</code> library provides a user-friendly way to implement encryption.  One common encryption scheme is Fernet, which offers symmetric key encryption.</p> <p>For example, <pre><code>from cryptography.fernet import Fernet\n\n# Generate a random encryption key\nkey = Fernet.generate_key()\n\n# Create a Fernet cipher object with the key\ncipher_suite = Fernet(key)\n\n# Text to be encrypted\nplaintext = b\"Hello, this is a secret message!\"\n\n# Encrypt the plaintext\ncipher_text = cipher_suite.encrypt(plaintext)\n\n# Decrypt the ciphertext\ndecrypted_text = cipher_suite.decrypt(cipher_text)\n\n# Convert bytes to string for printing\noriginal_message = decrypted_text.decode(\"utf-8\")\n\nprint(\"Original Message: \", plaintext)\nprint(\"Encrypted Message: \", cipher_text)\nprint(\"Decrypted Message: \", original_message)\n</code></pre> The provided Python example demonstrates this process, securing a message with encryption and then decrypting it using the same key.  It's crucial to manage encryption keys securely in real applications to maintain the confidentiality and integrity of your data.</p>"},{"location":"security/encryption_and_hashing/#hashing","title":"Hashing","text":"<p>For hashing, Ellar works with passlib and hashlib to create a wrapper around some hashing algorithms listed below,</p> <ul> <li>PBKDF2Hasher: <code>pbkdf2_sha256</code> hashing algorithm wrapper</li> <li>PBKDF2SHA1Hasher: <code>pbkdf2_sha1</code> hashing algorithm wrapper</li> <li>Argon2Hasher: <code>argon2</code> hashing algorithm wrapper</li> <li>BCryptSHA256Hasher: <code>bcrypt_sha256</code> hashing algorithm wrapper</li> <li>BCryptHasher: <code>bcrypt</code> hashing algorithm wrapper</li> <li>ScryptHasher: <code>scrypt</code> hashing algorithm wrapper</li> <li>MD5Hasher: <code>md5</code> hashing algorithm wrapper</li> </ul>"},{"location":"security/encryption_and_hashing/#password-hashing","title":"Password Hashing","text":"<p>Ellar provides two important utility functions: <code>make_password</code> for password hashing  and <code>check_password</code> for password validation. Both of these functions are available in the  <code>ellar.core.security.hashers</code> package.</p> <pre><code>def make_password(\n    password: str|bytes,\n    algorithm: str = \"pbkdf2_sha256\",\n    salt: str|None = None,\n) -&gt; str:\n    pass\n\n\ndef check_password(\n    password: str|bytes,\n    encoded: str,\n    setter: Callable[..., Any]|None = None,\n    preferred_algorithm: str = \"pbkdf2_sha256\",\n) -&gt; bool:\n    pass\n</code></pre> <p>The <code>make_password</code> function takes plain text and generates a hashed result based on the provided hash algorithm.  In the code snippet above, the default algorithm for <code>make_password</code> is <code>pbkdf2_sha256</code>.</p> <p>The PBKDF2 algorithm with a SHA256 hash is a password stretching mechanism recommended by NIST. This should be sufficient for most users as it is quite secure and requires massive amounts of computing time to break.</p> <p>Note</p> <p>All hashing wrappers are registered as <code>key-value</code> pairs and can be accessed by the algorithm names using the get_hasher utility function in the <code>ellar.core.security.hashers</code> package.</p> <p>For an example, <pre><code>from ellar.core.security.hashers import make_password\n\n## Using pbkdf2_sha256 - PBKDF2Hasher\npassword_hash = make_password('mypassword1234', algorithm=\"pbkdf2_sha256\", salt='seasalt')\nprint(password_hash)\n# pbkdf2_sha256$870000$seasalt$XE8bb8u57rxvyv2SThRFtMg9mzJLff2wjm3J8kGgFVI=\n\n## Using bcrypt_sha256 - BCryptSHA256Hasher\npassword_hash = make_password('mypassword1234', algorithm=\"bcrypt_sha256\", salt='20AmWL1wKJZAHPiI1HEk4k')\nprint(password_hash)\n# bcrypt_sha256$$2b$12$20AmWL1wKJZAHPiI1HEk4eZuAlMGHkK1rw4oou26bnwGmAE8F0JGK\n</code></pre></p> <p>On the other hand, you can check or validate a password using the <code>check_password</code> function.</p> <pre><code>from ellar.core.security.hashers import check_password\n\nhash_secret = \"bcrypt_sha256$$2b$12$20AmWL1wKJZAHPiI1HEk4eZuAlMGHkK1rw4oou26bnwGmAE8F0JGK\"\nassert check_password('mypassword1234', hash_secret) # True\n</code></pre>"},{"location":"security/rate-limit/","title":"Rate Limiting","text":"<p><code>Ellar-Throttler</code> package offers a robust rate-limiting module designed specifically for Ellar,  providing efficient throttling capabilities for web applications.</p>"},{"location":"security/rate-limit/#installation","title":"Installation","text":"<p>To install the Ellar Throttler package, use pip within your virtual environment:</p> <pre><code>$(venv) pip install ellar-throttler\n</code></pre>"},{"location":"security/rate-limit/#usage","title":"Usage","text":""},{"location":"security/rate-limit/#throttlermodule","title":"ThrottlerModule","text":"<p>The <code>ThrottlerModule</code> serves as the primary interface for configuring throttling mechanisms across the entire Ellar application.</p>"},{"location":"security/rate-limit/#throttlermodule-parameters","title":"ThrottlerModule Parameters","text":"Parameter Description throttlers A list of <code>IThrottleModel</code> instances defining various throttling mechanisms. storage An <code>IThrottlerStorage</code> service, instance, or class responsible for tracking throttling. error_message A customizable string to replace the default throttler error message. ignore_user_agents An array of user-agent strings to exempt from throttling. skip_if A global function that evaluates <code>ExecutionContext</code> and returns a boolean to bypass throttler logic."},{"location":"security/rate-limit/#throttlermodule-setup","title":"ThrottlerModule Setup","text":"<p>Similar to other Ellar modules, you can set up <code>ThrottlerModule</code> directly using the <code>setup</code> function or configure it via <code>register_setup</code>.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # Allow 100 requests per 5 minutes for anonymous users\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # Allow 2000 requests per day for authenticated users\n        ]\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>In the above setup, we've specified a limit of 100 requests per 5 minutes for anonymous users and 2000 requests per day for authenticated users.</p> <p>Alternatively, configuration-based setup is demonstrated below:</p> config.py<pre><code>...\nfrom ellar_throttler import AnonymousThrottler, UserThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # Allow 100 requests per 5 minutes for anonymous users\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # Allow 2000 requests per day for authenticated users\n        ]\n    }\n</code></pre> <p>Then, in <code>ApplicationModule</code>:</p> <pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule\n\n@Module(modules=[\n    ThrottlerModule.register_setup()\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"security/rate-limit/#throttle-all-routes","title":"Throttle All Routes","text":"<p>To apply throttling to all incoming requests, utilize <code>ThrottlerInterceptor</code> globally, as illustrated below:</p> <pre><code>from ellar.app import AppFactory\nfrom ellar_throttler import ThrottlerInterceptor\nfrom .module import AppModule\n\napp = AppFactory.create_from_app_module(AppModule)\napp.use_global_interceptors(ThrottlerInterceptor)\n</code></pre>"},{"location":"security/rate-limit/#decorators","title":"Decorators","text":"<p>This package introduces two decorators, <code>Throttle</code> and <code>SkipThrottle</code>,  designed to provide additional metadata for the <code>ThrottlerInterceptor</code>, guiding its throttling behavior or  bypassing it for decorated controllers or route functions.</p>"},{"location":"security/rate-limit/#using-throttle-decorator","title":"Using <code>Throttle</code> Decorator","text":"<p>The <code>Throttle</code> decorator applies the <code>ThrottlerInterceptor</code> and allows for overriding  configurations for any throttler model defined in the <code>ThrottlerModule.throttlers</code> list.</p> controllers.py<pre><code>from ellar_throttler import Throttle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@Throttle(intercept=True)\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>In the above example, by setting <code>intercept=True</code> within @Throttle,  the <code>ThrottlerInterceptor</code> is applied to all routes within the <code>LimitController</code>.  This feature is particularly useful when <code>ThrottlerInterceptor</code> is not globally applied.</p> <p>Additionally, the @Throttle decorator can be used on a route level:</p> <pre><code>@get()\n@Throttle(intercept=True)\ndef get_throttled(self, use_auth: bool):\n    return self.app_service.success(use_auth)\n</code></pre> <p>Another application of the @Throttle decorator is to override <code>ttl</code> and <code>limit</code> for a specific configured throttler model:</p> <pre><code>@Controller(\"/limit\")\n@Throttle(intercept=True, anon={'ttl': 100, 'limit': 30})\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>In this scenario, different <code>ttl</code> and <code>limit</code> values are applied to the LimitController  when executing against a throttler model named <code>anon</code>.</p>"},{"location":"security/rate-limit/#using-skipthrottle-decorator","title":"Using <code>SkipThrottle</code> Decorator","text":"<p>The <code>SkipThrottle</code> decorator marks a decorated class or route function with metadata  used by <code>ThrottlerInterceptor</code> to entirely bypass throttling or selectively skip specific throttler models.</p> <p>For instance, if using <code>ThrottlerInterceptor</code> as a global interceptor and wishing to bypass throttling for <code>LimitController</code>:</p> <pre><code>from ellar_throttler import SkipThrottle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@SkipThrottle()\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>This setup will bypass all throttling models for <code>LimitController</code>. If only the <code>user</code> throttler model needs to be skipped:</p> <pre><code>from ellar_throttler import SkipThrottle\nfrom ellar.common import Controller, get\n\n\n@Controller(\"/limit\")\n@SkipThrottle(user=True)\nclass LimitController:\n    def __init__(self, app_service: AppService):\n        self.app_service = app_service\n\n    @get()\n    def get_throttled(self, use_auth: bool):\n        return self.app_service.success(use_auth)\n</code></pre> <p>This configuration skips all throttling models except for the one named <code>user</code>.</p>"},{"location":"security/rate-limit/#ithrottlermodel","title":"IThrottlerModel","text":"<p>The IThrottlerModel serves as an interface for defining attributes and properties specific to a throttler.  The package provides several <code>ThrottlerModel</code> implementations to facilitate usage.</p>"},{"location":"security/rate-limit/#anonymousthrottler","title":"AnonymousThrottler","text":"<p>The <code>AnonymousThrottler</code> model is designed for throttling unauthenticated users, utilizing their  <code>client.host</code> address as a key for throttling purposes. It exempts authenticated requests and is  ideal for limiting requests from unknown sources.</p> <pre><code>from ellar_throttler import AnonymousThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            # Configuring burst and sustained throttling for unauthenticated users\n            AnonymousThrottler(limit=100, ttl=(60*5), name='burst'),\n            AnonymousThrottler(limit=1000, ttl=(60*60*24), name='sustain'),\n        ]\n    }\n</code></pre>"},{"location":"security/rate-limit/#userthrottler","title":"UserThrottler","text":"<p>The <code>UserThrottler</code> model is tailored for throttling authenticated users,  utilizing user <code>id</code> or <code>sub</code> to generate a key for throttling. Unauthenticated requests  resort to using the <code>client.host</code> address for generating a unique key. </p> <pre><code>from ellar_throttler import UserThrottler\n\nclass BaseConfig:\n    ELLAR_THROTTLER_CONFIG: {\n        'throttlers': [\n            # Configuring burst and sustained throttling for authenticated users\n            UserThrottler(limit=100, ttl=(60*5), name='burst'),\n            UserThrottler(limit=1000, ttl=(60*60*24), name='sustain'),\n        ]\n    }\n</code></pre>"},{"location":"security/rate-limit/#ithrottlerstorage","title":"IThrottlerStorage","text":"<p>The <code>IThrottlerStorage</code> interface defines methods for managing the details of request tracking within the throttler.  This package provides two implementations of <code>IThrottlerStorage</code>:</p>"},{"location":"security/rate-limit/#throttlerstorageservice","title":"<code>ThrottlerStorageService</code>:","text":"<p>This service offers in-memory storage for throttling, suitable for testing request throttling in development environments.  When configuring <code>ThrottlerModule</code>, if no storage parameter is provided, <code>ThrottlerStorageService</code> is selected by default.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, ThrottlerStorageService\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=200, ttl=(60*24), name='anon'), # 200/day for anonymous requests\n            UserThrottler(limit=1000, ttl=(60*24), name='user'), # 1000/day for authenticated requests\n        ],\n        # storage=ThrottlerStorageService() use as an instance OR\n        storage=ThrottlerStorageService\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"security/rate-limit/#cachethrottlerstorageservice","title":"<code>CacheThrottlerStorageService</code>","text":"<p>This service utilizes the default caching setup in your Ellar application, providing more dynamic storage options.  It requires setting up caching, where various storage backends are available through  <code>CacheModule</code>.  In the example below, caching is set up using the Redis backend.</p> root_module.py<pre><code>from ellar.common import Module\nfrom ellar.cache import CacheModule\nfrom ellar.cache.backends.redis import RedisCacheBackend\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, CacheThrottlerStorageService\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # 200/5mins for anonymous requests\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # 2000/24hrs for authenticated requests\n        ],\n        storage=CacheThrottlerStorageService\n    ),\n    CacheModule.setup(default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']))\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>To modify the caching type used in <code>CacheThrottlerStorageService</code>,  you need to extend the class and set the <code>cache_backend</code> to point to the desired caching service backend:</p> <pre><code>from ellar.di import injectable\nfrom ellar.cache import ICacheService, CacheModule\nfrom ellar_throttler import CacheThrottlerStorageService, ThrottlerModule\n\n\n@injectable()\nclass MyNewCacheThrottlerStorageService(CacheThrottlerStorageService):\n    def __init__(self, cache_service: ICacheService) -&gt; None:\n        super().__init__(cache_service)\n        self.cache_backend = 'my_backend'\n\n\n# in root_module.py\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            AnonymousThrottler(limit=100, ttl=(60*5), name='anon'), # 200/5mins for anonymous requests\n            UserThrottler(limit=2000, ttl=(60*60*24), name='user'), # 2000/24hrs for authenticated requests\n        ],\n        storage=MyNewCacheThrottlerStorageService\n    ),\n    CacheModule.setup(\n        default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']),\n        my_backend=RedisCacheBackend(servers=['redis://127.0.0.1:6379'])\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre>"},{"location":"security/rate-limit/#proxies","title":"Proxies","text":"<p>If you're working with multiple proxies,  you may need to install <code>ProxyHeadersMiddleware</code>.</p>"},{"location":"security/rate-limit/#working-with-websockets","title":"Working with WebSockets","text":"<p>To utilize WebSockets, you can include <code>WebsocketThrottler</code> in the list of throttlers for your application.</p> <pre><code>from ellar.common import Module\nfrom ellar.cache import CacheModule\nfrom ellar.cache.backends.redis import RedisCacheBackend\nfrom ellar_throttler import ThrottlerModule, AnonymousThrottler, UserThrottler, CacheThrottlerStorageService, model\n\n@Module(modules=[\n    ThrottlerModule.setup(\n        throttlers=[\n            # HTTP Throttling Models\n            AnonymousThrottler(limit=200, ttl=(60*24)), # 200/day for anonymous requests \n            UserThrottler(limit=1000, ttl=(60*24)), # 1000/day for authenticated requests\n            # Websocket Throttling Models\n            model.WebsocketThrottler('ws-burst', limit=200, ttl=(60*24)), # 200/day  \n            model.WebsocketThrottler('ws-sustain', limit=2000, ttl=(60*24)), # 2000/day \n        ],\n        storage=CacheThrottlerStorageService\n    ),\n    CacheModule.setup(default=RedisCacheBackend(servers=['redis://127.0.0.1:6379']))\n])\nclass ApplicationModule:\n    pass\n</code></pre> <p>The <code>WebsocketThrottler</code> only runs within the websocket environment.  Additionally, note that <code>WebsocketThrottler</code> workers like <code>UserThrottler</code> for an authenticated  request and <code>AnonymousThrottler</code> for anonymous request.</p>"},{"location":"security/rate-limit/#inline-throttling-definition","title":"Inline Throttling Definition","text":"<p>It is possible to define throttling models at the point usage and they will override the globally registered models.</p> <p>For example: <pre><code>@get(\"/shorter-inline-throttling\")\n@Throttle(AnonymousThrottler(ttl=5, limit=3), UserThrottler(ttl=3, limit=3)) # overriding global throttling options\ndef get_shorter_inline_version(self, use_auth: bool):\n    return self.app_service.success(use_auth)\n</code></pre></p> <p>In <code>get_shorter_inline_version</code>, <code>AnonymousThrottler(ttl=5, limit=3)</code> and <code>UserThrottler(ttl=3, limit=3)</code> throttling models were defined in it. This will be used as throttling models for <code>get_shorter_inline_version</code> during runtime.</p>"},{"location":"security/sessions/","title":"Session","text":"<p>A web session acts as a transient interaction between a user and a web application, usually initiated upon visiting a website.  It enables the storage of user-specific data across multiple requests, facilitating personalized experiences, authentication,  and state management within the application.</p> <p>In Ellar, session management is overseen by the <code>SessionMiddleware</code>, which delegates the serialization and  deserialization of sessions to any registered <code>SessionStrategy</code> service within the Dependency Injection (DI) container.  Sessions can be accessed and modified using the <code>request.session</code> dictionary interface.</p>"},{"location":"security/sessions/#accessing-session","title":"Accessing Session","text":"<p>Session objects are accessible via <code>request.session</code> or by injecting <code>Session</code> into route parameters.</p> <p>For example:</p> Request ObjectRoute Parameter Injection <pre><code>from ellar.common import Controller, ControllerBase, get\n\n@Controller\nclass SampleController(ControllerBase):\n    @get()\n    def index(self):\n        session = self.context.switch_to_http_connection().get_request().session\n        assert isinstance(session, dict)\n        return {'index': 'okay'}\n</code></pre> <pre><code>from ellar.common import Controller, ControllerBase, get, Inject\n\n@Controller\nclass SampleController(ControllerBase):\n    @get()\n    def index(self, session: Inject[str, Inject.Key('Session')]):\n        assert isinstance(session, dict)\n        return {'index': 'okay'}\n</code></pre>"},{"location":"security/sessions/#sessionclientstrategy","title":"SessionClientStrategy","text":"<p>The <code>SessionClientStrategy</code> serves as the default implementation for <code>SessionStrategy</code>,  leveraging the <code>itsdangerous</code> package for hashing session data. It serializes session data and saves it on the client side.  However, large session data may cause issues for some requests.</p> <p>To utilize <code>SessionClientStrategy</code>, ensure the <code>itsdangerous</code> package is installed:</p> <pre><code>pip install itsdangerous\n</code></pre> <p>Activate <code>SessionClientStrategy</code> by registering it with the DI container, as demonstrated below:</p> <p><pre><code>from ellar.common import IHostContext, JSONResponse, Module, Response, exception_handler\nfrom ellar.core import ModuleBase\nfrom ellar.samples.modules import HomeModule\n\nfrom ellar.auth.session.strategy import SessionClientStrategy\nfrom ellar.auth.session import SessionStrategy\nfrom ellar.di import ProviderConfig\n\nfrom .car.module import CarModule\n\n\n@Module(\n    modules=[HomeModule, CarModule],\n    providers=[ProviderConfig(SessionStrategy, use_class=SessionClientStrategy)]\n)\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, context: IHostContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre> By registering <code>ISessionStrategy</code> as <code>SessionClientStrategy</code> with <code>ProviderConfig(ISessionStrategy, use_class=SessionClientStrategy)</code>, <code>SessionMiddleware</code> utilizes <code>SessionClientStrategy</code> for session management.</p>"},{"location":"security/sessions/#sessionstrategy-configuration-options","title":"SessionStrategy Configuration Options","text":"<ul> <li>SESSION_COOKIE_NAME: Defaults to \"session\".</li> <li>SESSION_COOKIE_PATH: Sets the path for the session cookie. If not set, the cookie is valid for all of <code>APPLICATION_ROOT</code> or '/' if not specified.</li> <li>SESSION_COOKIE_SECURE: Controls whether the cookie is set with the secure flag, which restricts it to HTTPS requests. Default: <code>False</code>.</li> <li>SESSION_COOKIE_MAX_AGE: Sets the session expiry time in seconds, defaulting to 2 weeks. If set to <code>None</code>, the cookie lasts until the browser session ends.</li> <li>SESSION_COOKIE_SAME_SITE: Specifies the SameSite flag to prevent sending the session cookie along with cross-site requests. Defaults to 'lax'.</li> <li>SESSION_COOKIE_HTTPONLY: Indicates whether the HttpOnly flag should be set, restricting cookie access to HTTP requests only. Defaults to <code>False</code>.</li> <li>SESSION_COOKIE_DOMAIN: Specifies the domain of the cookie, facilitating sharing between subdomains or cross-domains. The browser defaults the domain to the same host that set the cookie, excluding subdomain references.</li> </ul>"},{"location":"security/sessions/#custom-sessionstrategy","title":"Custom SessionStrategy","text":"<p>In this section, we'll walk through creating another session strategy that saves session data  to a relational database using the <code>EllarSQL</code> package.</p> <p>To begin, you'll need to install the <code>EllarSQL</code> package:</p> <pre><code>pip install ellar-sql\n</code></pre> <p>Next, create a Python file named <code>session.py</code> in your project's root directory and paste the following code:</p> project_name/session.py<pre><code>import pickle\nimport secrets\nimport typing as t\nfrom ellar_sql import model, first_or_none\nfrom datetime import datetime, timedelta\n\nfrom ellar.auth.session import SessionStrategy, SessionCookieObject, SessionCookieOption\nfrom ellar.threading import run_as_sync\n\nfrom itsdangerous import want_bytes\n\n\nclass SessionTable(model.Model):\n    id = model.Column(model.Integer, primary_key=True)\n    session_id = model.Column(model.String(255), unique=True)\n    data = model.Column(model.LargeBinary)\n    expiry = model.Column(model.DateTime)\n\n    def __init__(self, session_id, data, expiry):\n        super().__init__()\n\n        self.session_id = session_id\n        self.data = data\n        self.expiry = expiry\n\n    def __repr__(self):\n        return \"&lt;Session data %s&gt;\" % self.data\n\n\nclass EllarSQLSessionStrategy(SessionStrategy):\n    \"\"\"Uses the EllarSQL for a session backend.\"\"\"\n\n    serializer = pickle\n\n    def __init__(\n            self,\n            key_prefix: str,\n            name: str = \"ellar-sql\"\n    ):\n        self.key_prefix = key_prefix\n        self._session_option = SessionCookieOption(NAME=name)\n\n    @property\n    def session_cookie_options(self) -&gt; SessionCookieOption:\n        return self._session_option\n\n    def serialize_session(\n            self,\n            session: t.Union[str, SessionCookieObject],\n    ) -&gt; str:\n        return self._save_session_data(session)\n\n    def deserialize_session(self, session_data: t.Optional[str]) -&gt; SessionCookieObject:\n        return self._fetch_record(session_data)\n\n    async def _try_coroutine(self, func: t.Optional[t.Coroutine]) -&gt; None:\n        if isinstance(func, t.Coroutine):\n            await func\n\n    @run_as_sync\n    async def _fetch_record(self, key: str) -&gt; SessionCookieObject:\n        \"\"\"Get the saved session (record) from the database\"\"\"\n        key  = key or secrets.token_urlsafe(5)\n        store_id = self.key_prefix + key\n        record: t.Optional[SessionTable] = await first_or_none(\n            model.select(SessionTable).filter_by(session_id=store_id))\n\n        # If the expiration time is less than or equal to the current time (expired), delete the document\n        if record is not None:\n            expiration_datetime = record.expiry\n            if expiration_datetime is None or expiration_datetime &lt;= datetime.utcnow():\n                session = SessionTable.get_db_session()\n                await self._try_coroutine(session.delete(record))\n                await self._try_coroutine(session.commit())\n\n                record = None\n\n        # If the saved session still exists after checking for expiration, load the session data from the document\n        if record:\n            try:\n                session_data = self.serializer.loads(want_bytes(record.data))\n                return SessionCookieObject(session_data, sid=key)\n            except pickle.UnpicklingError:\n                return SessionCookieObject(sid=key)\n\n        return SessionCookieObject(sid=key)\n\n    @run_as_sync\n    async def _save_session_data(self, session: t.Union[str, SessionCookieObject], ) -&gt; str:\n        \"\"\"Generate a prefixed session id\"\"\"\n        prefixed_session_id = self.key_prefix + session.sid\n\n        # If the session is empty, do not save it to the database or set a cookie\n        if not session:\n            # If the session was deleted (empty and modified), delete the saved session  from the database and tell the client to delete the cookie\n            if session.modified:\n                record = await first_or_none(model.select(SessionTable).filter_by(session_id=prefixed_session_id))\n                session = SessionTable.get_db_session()\n\n                await self._try_coroutine(session.delete(record))\n                await self._try_coroutine(session.commit())\n\n            return self.get_cookie_header_value(session, delete=True)\n\n        # Serialize session data\n        serialized_session_data = self.serializer.dumps(dict(session))\n\n        # Get the new expiration time for the session\n        expiration_datetime = datetime.utcnow() + timedelta(days=14)\n\n        # Update existing or create new session in the database\n        record = await first_or_none(model.select(SessionTable).filter_by(session_id=prefixed_session_id))\n        db_session = SessionTable.get_db_session()\n\n        if record:\n            record.data = serialized_session_data\n            record.expiry = expiration_datetime\n        else:\n            db_session = SessionTable.get_db_session()\n            record = SessionTable(\n                session_id=prefixed_session_id,\n                data=serialized_session_data,\n                expiry=expiration_datetime,\n            )\n            db_session.add(record)\n        await self._try_coroutine(db_session.commit())\n\n        return self.get_cookie_header_value(session.sid)\n</code></pre> <p>In the code above, session data is serialized to bytes using the Python <code>pickle</code> package, and other processes are standard SQLAlchemy actions.</p> <p>Next, register the <code>EllarSQLSessionStrategy</code> as the <code>SessionStrategy</code>:</p> <pre><code>from ellar.common import IHostContext, JSONResponse, Module, Response, exception_handler, IApplicationStartup\nfrom ellar.core import ModuleBase\nfrom ellar.samples.modules import HomeModule\nfrom ellar.auth.session import SessionStrategy\nfrom ellar.di import ProviderConfig\nfrom ellar_sql import EllarSQLService\n\nfrom .car.module import CarModule\nfrom .session import EllarSQLSessionStrategy\n\n\n@Module(\n    modules=[HomeModule, CarModule],\n    providers=[ProviderConfig(SessionStrategy, use_class=EllarSQLSessionStrategy)]\n)\nclass ApplicationModule(ModuleBase, IApplicationStartup):\n    async def on_startup(self, app: \"App\") -&gt; None:\n        ellar_sql_service = app.injector.get(EllarSQLService)\n        ellar_sql_service.create_all()\n\n    @exception_handler(404)\n    def exception_404_handler(cls, context: IHostContext, exc: Exception) -&gt; Response:\n        return JSONResponse({\"detail\": \"Resource not found.\"}, status_code=404)\n</code></pre> <p>In the above code, the <code>on_startup</code> method from <code>IApplicationStartup</code> ensures that the <code>SessionTable</code> is created.</p> <p>Once this setup is complete, restart the local server to observe session table data in your relational database.</p>"},{"location":"security/sessions/#disable-session","title":"Disable Session","text":"<p>To disable sessions in your Ellar application, set <code>SESSION_DISABLED=True</code> in your application configuration.  This configuration change will effectively turn off session functionality throughout your Ellar application.</p>"},{"location":"security/authentication/auth-handler-strategy/","title":"Authentication Schemes Strategy","text":"<p>Authentication scheme is another strategy for identifying the user who is using the application. The difference between it and and Guard strategy is your identification executed at middleware layer when processing incoming request while guard execution happens just before route function is executed.</p> <p>Ellar provides <code>BaseAuthenticationHandler</code> contract which defines what is required to set up any authentication strategy.  We are going to make some modifications on the existing project to see how we can achieve the same result and to show how authentication handlers in ellar.</p>"},{"location":"security/authentication/auth-handler-strategy/#creating-a-jwt-authentication-handler","title":"Creating a JWT Authentication Handler","text":"<p>Just like AuthGuard, we need to create its equivalent. But first we need to create a <code>auth_scheme.py</code> at the root level  of your application for us to define a <code>JWTAuthentication</code> handler. </p> prject_name/auth_scheme.py<pre><code>import typing as t\nfrom ellar.common.serializer.guard import (\n    HTTPAuthorizationCredentials,\n)\nfrom ellar.auth import UserIdentity\nfrom ellar.auth.handlers import HttpBearerAuthenticationHandler\nfrom ellar.common import IHostContext\nfrom ellar.di import injectable\nfrom ellar_jwt import JWTService\n\n\n@injectable\nclass JWTAuthentication(HttpBearerAuthenticationHandler):\n    def __init__(self, jwt_service: JWTService) -&gt; None:\n        self.jwt_service = jwt_service\n\n    async def authentication_handler(\n        self,\n        context: IHostContext,\n        credentials: HTTPAuthorizationCredentials,\n    ) -&gt; t.Optional[t.Any]:\n        # this function will be called by Identity Middleware but only when a `Bearer token` is found on the header request\n        try:\n            data = await self.jwt_service.decode_async(credentials.credentials)\n            return UserIdentity(auth_type=self.scheme, **data)\n        except Exception as ex:\n            # if we cant identity the user or token has expired, we return None.\n            return None\n</code></pre> <p>Let us make <code>JWTAuthentication</code> Handler available for ellar to use as shown below</p> <p>project_name.server.py<pre><code>import os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.app import AppFactory, use_authentication_schemes\nfrom ellar.core import LazyModuleImport as lazyLoad\nfrom .auth_scheme import JWTAuthentication\n\n\napplication = AppFactory.create_from_app_module(\n    lazyLoad('project_name.root_module:ApplicationModule'),\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"project_name.config:DevelopmentConfig\"\n    ),\n)\nuse_authentication_schemes(JWTAuthentication)\n</code></pre> Unlike guards, Authentication handlers are registered global by default as shown in the above illustration.  Also, we need to remove <code>GlobalGuard</code> registration we did in <code>AuthModule</code>,  so that we don't have too user identification checks.</p> <p>Note</p> <p>In the above illustration, we added JWTAuthentication as a type. This means DI will create JWTAuthentication instance. We can use this method because we want <code>JWTService</code> to be injected when instantiating <code>JWTAuthentication</code>.  But if you don't have any need for DI injection, you can use the below. <pre><code>...\napplication.add_authentication_schemes(JWTAuthentication())\n## OR\n## use_authentication_schemes(JWTAuthentication())\n</code></pre></p> <p>We need to refactor auth controller and mark <code>refresh_token</code> and <code>sign_in</code> function as public routes by using <code>SkipAuth</code> decorator from <code>ellar.auth</code> package.</p> <p>auth/controller.py<pre><code>from ellar.common import Controller, ControllerBase, post, Body, get\nfrom ellar.auth import SkipAuth, AuthenticationRequired\nfrom ellar.openapi import ApiTags\nfrom .services import AuthService\n\n\n@AuthenticationRequired('JWTAuthentication')\n@Controller\n@ApiTags(name='Authentication', description='User Authentication Endpoints')\nclass AuthController(ControllerBase):\n    def __init__(self, auth_service: AuthService) -&gt; None:\n        self.auth_service = auth_service\n\n    @post(\"/login\")\n    @SkipAuth()\n    async def sign_in(self, username: Body[str], password: Body[str]):\n        return await self.auth_service.sign_in(username=username, password=password)\n\n    @get(\"/profile\")\n    async def get_profile(self):\n        return self.context.user\n\n    @SkipAuth()\n    @post(\"/refresh\")\n    async def refresh_token(self, payload: str = Body(embed=True)):\n        return await self.auth_service.refresh_token(payload)\n</code></pre> In the above illustration, we decorated AuthController with <code>@AuthenticationRequired('JWTAuthentication')</code> to ensure we have authenticated user before executing any route function and,  we passed in <code>JWTAuthentication</code> as a parameter, which will be used in openapi doc to define the controller routes security scheme.</p> <p>It is importance to note that when using <code>AuthenticationHandler</code> approach, that you have to always use <code>AuthenticationRequired</code> decorator on route functions or controller that needs protected from anonymous users.</p> <p>But if you have a single form of authentication, you can register <code>AuthenticatedRequiredGuard</code> from <code>eellar.auth.guard</code> module globally just like we did in applying guard globally</p> auth/module.py<pre><code>from datetime import timedelta\n\nfrom ellar.app import use_global_guards\nfrom ellar.auth.guards import AuthenticatedRequiredGuard\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\nfrom ellar_jwt import JWTModule\n\nfrom .controllers import AuthController\nfrom .services import AuthService\n\n## Registers AuthenticatedRequiredGuard to the GLOBAL GUARDS\nuse_global_guards(AuthenticatedRequiredGuard('JWTAuthentication', []))\n\n@Module(\n    modules=[\n        lazyLoad('project_name.users.module:UserModule'),\n        JWTModule.setup(\n            signing_secret_key=\"my_poor_secret_key_lol\", lifetime=timedelta(minutes=5)\n        ),\n    ],\n    controllers=[AuthController],\n    providers=[AuthService],\n)\nclass AuthModule(ModuleBase):\n    \"\"\"\n    Auth Module\n    \"\"\"\n</code></pre> <p>Still having the server running, we can test as before</p> <p><pre><code>$ # GET /auth/profile\n$ curl http://localhost:8000/auth/profile\n{\"detail\":\"Forbidden\"} # status_code=403\n\n$ # POST /auth/login\n$ curl -X POST http://localhost:8000/auth/login -d '{\"username\": \"john\", \"password\": \"password\"}' -H \"Content-Type: application/json\"\n{\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTg3OTE0OTE...\"}\n\n$ # GET /profile using access_token returned from previous step as bearer code\n$ curl http://localhost:8000/auth/profile -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm...\"\n{\"exp\":1698793558,\"iat\":1698793258,\"jti\":\"e96e94c5c3ef4fbbbd7c2468eb64534b\",\"sub\":1,\"user_id\":1,\"username\":\"john\", \"id\":null,\"auth_type\":\"bearer\"}\n</code></pre> Source Code to this example is here</p>"},{"location":"security/authentication/guard-strategy/","title":"Authentication and Guard authentication","text":"<p>Authentication is an essential part of most applications. It refers to the methods and techniques used to verify the identity of users interacting with your application. There are many different approaches and strategies to handle authentication. The approach taken for any project depends on its particular application requirements. In this section, we shall go through different approaches to authentication in Ellar and how it will suit your authentication requirements.</p> <p>There are two ways in which user authentication and identification are processed in Ellar:</p> <ul> <li>Using Guards</li> <li>Using Authentication Schemes</li> </ul>"},{"location":"security/authentication/guard-strategy/#1-guard-authentication","title":"1. Guard Authentication","text":"<p>We have discussed in detail how Guards are used to protect a route and check for user authorizations, but we never really addressed how they can be used for authentication purposes. For this, we are going to illustrate JWT authentication using Guard</p> <p>Note</p> <p>Read more on Guards</p> <p>Let's flesh out our requirements. For this use case, clients will start by authenticating with a username and password.  Once authenticated, the server will issue a JWT that can be sent as a bearer token in an authorization header on subsequent requests to prove authentication.  Then, we create a protected route that is accessible only to requests that contain a valid JWT.</p> <p>Let's start with the first requirement: authenticating a user, then extend that by issuing a JWT.  And finally, we'll create a protected route that checks for a valid JWT on the request.</p>"},{"location":"security/authentication/guard-strategy/#creating-an-authentication-module","title":"Creating an authentication module","text":"<p>We\u00b4ll start by scaffolding an <code>AuthModule</code> with the Ellar CLI tool followed by <code>AuthService</code> and <code>AuthController</code> implementations. We\u00b4ll use the <code>AuthService</code> to implement the authentication logic and the <code>AuthController</code> to expose the authentication endpoints.</p> <pre><code>ellar create-module auth\n</code></pre> <p>Also, the AuthService would need UserService, which encapsulates user operations. Let's also scaffold a user module.</p> <pre><code>ellar create-module user\n</code></pre> <p>Now, let's add some implementations to the generated files. For this application, the <code>UserService</code> will be working with a hard-coded list of users with a retrieve one-by-email method.  In a real application, you\u00b4d build your user model and persistence layer using a library of your choice like SQLAlchemy, Django ORM, Peewee, PonyORM, etc.</p> user/services.py<pre><code>from ellar.common import Serializer\nfrom ellar.common.serializer import SerializerFilter\nfrom ellar.di import injectable\nfrom ellar.core.security.hashers import make_password\n\n\nclass UserModel(Serializer):\n    _filter = SerializerFilter(exclude={'password'})\n\n    user_id: int\n    username: str\n    password: str\n\n\n@injectable()\nclass UsersService:\n    users = [\n        {\n            'user_id': 1,\n            'username': 'john',\n            'password': make_password('password'),\n        },\n        {\n            'user_id': 2,\n            'username': 'clara',\n            'password': make_password('guess'),\n        },\n    ]\n\n    async def get_user_by_username(self, username: str) -&gt; UserModel | None:\n        filtered_list = filter(lambda item: item[\"username\"] == username, self.users)\n        found_user = next(filtered_list)\n        if found_user:\n            return UserModel(**found_user)\n</code></pre> <p>In the above example, we have used <code>make_password</code> to hash the password. It is strictly advised you don't save passwords as plain text. In the <code>UsersModule</code>, we need to register the <code>UserService</code> we just created so that it will be injectable in <code>AuthService</code></p> user/module.py<pre><code>from ellar.common import Module\nfrom ellar.core import ModuleBase\n\nfrom .services import UsersService\n\n\n@Module(\n    providers=[UsersService],\n    exports=[UsersService]\n)\nclass UserModule(ModuleBase):\n    \"\"\"\n    User Module\n    \"\"\"\n</code></pre>"},{"location":"security/authentication/guard-strategy/#implementing-the-sign-in-endpoint","title":"Implementing the \"Sign in\" endpoint","text":"<p>The <code>AuthService</code> has the job of retrieving a user and verifying the password.  Let's create a <code>sign_in</code> function for this purpose.</p> auth/services.py<pre><code>import typing as t\n\nfrom ellar.core.security.hashers import check_password\nfrom ellar.di import injectable\nfrom ellar.common import exceptions\nfrom ..user.services import UsersService\n\n\n@injectable()\nclass AuthService:\n    def __init__(self, users_service: UsersService) -&gt; None:\n        self.users_service = users_service\n\n    async def sign_in(self, username: str, password: str) -&gt; t.Any:\n        user_model = await self.users_service.get_user_by_username(username)\n        if not user_model:\n            raise exceptions.AuthenticationFailed()\n\n        if not check_password(user_model.password, password):\n            raise exceptions.AuthenticationFailed()\n\n        return user_model.serialize()\n</code></pre> <p>Next, we create the AuthController and add a sign_in endpoint</p> auth/controllers.py<pre><code>from ellar.common import Controller, ControllerBase, post, Body\nfrom .services import AuthService\n\n\n@Controller\nclass AuthController(ControllerBase):\n    def __init__(self, auth_service: AuthService) -&gt; None:\n        self.auth_service = auth_service\n\n    @post(\"/login\")\n    async def sign_in(self, username: Body[str], password: Body[str]):\n        return await self.auth_service.sign_in(username=username, password=password)\n</code></pre> <p>At this junction, the <code>AuthService</code> returns a Python dictionary object of the user retrieved if the password is correct.  But in the real sense, we need a token returned to the client. </p> <p>For this, we need to install the <code>ellar-jwt</code> package</p> <pre><code>pip install ellar-jwt\n</code></pre> <p>Let us review and refine our requirements once again:</p> <ul> <li>Allow users to authenticate with username/password, returning a JWT for use in subsequent calls to protected API endpoints. This is almost done. What is left is to write the code that issues a JWT.</li> <li>Create API routes that are protected based on the presence of a valid JWT as a bearer token</li> </ul> <p>EllarJWT comes with <code>JWTModule</code> and <code>JWTService</code> for encoding and decoding tokens.  Let us configure the JWTModule inside AuthModule.\u00a0</p> <p>Hint</p> <p>You can also see docs on how to use the EllarJWT</p> auth/module.py<pre><code>from datetime import timedelta\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\nfrom ellar_jwt import JWTModule\n\nfrom .controllers import AuthController\nfrom .services import AuthService\n\n\n@Module(\n    modules=[\n        lazyLoad('project_name.users.module:UserModule'),\n        JWTModule.setup(\n            signing_secret_key=\"my_poor_secret_key_lol\", lifetime=timedelta(minutes=5)\n        ),\n    ],\n    controllers=[AuthController],\n    providers=[AuthService],\n)\nclass AuthModule(ModuleBase):\n    \"\"\"\n    Auth Module\n    \"\"\"\n</code></pre> <p>In the above example, we configured <code>JWTModule</code> with very minimal configurations and registered it as a module dependency together with <code>UserModule</code>. Also we have registered <code>AuthController</code> and <code>AuthService</code> to <code>AuthModule</code> as well.  With\u00a0that done, we have completed the <code>AuthModule</code> setup.\u00a0</p> <p>Now, let us finish the <code>AuthService</code> by returning a token using <code>JWTService</code>.</p> auth/services.py<pre><code>import typing as t\n\nfrom ellar.core.security.hashers import check_password\nfrom ellar.di import injectable\nfrom ellar.common import exceptions\nfrom ellar_jwt import JWTService\n\nfrom ..user.services import UsersService\n\n\n@injectable()\nclass AuthService:\n    def __init__(self, users_service: UsersService, jwt_service: JWTService) -&gt; None:\n        self.users_service = users_service\n        self.jwt_service = jwt_service\n\n    async def sign_in(self, username: str, password: str) -&gt; t.Any:\n        user_model = await self.users_service.get_user_by_username(username)\n        if not user_model:\n            raise exceptions.AuthenticationFailed()\n\n        if not check_password(user_model.password, password):\n            raise exceptions.AuthenticationFailed()\n\n        result = {\"access_token\": await self.jwt_service.sign_async(dict(user_model.serialize(), sub=user_model.user_id))}\n        return result\n</code></pre> <p>At this point, we can run the application to test what we have done so far.  To do that, we need to register <code>AuthModule</code> to the <code>ApplicationModule</code>.</p> project_name/root_module.py<pre><code>from ellar.common import Module, exception_handler\nfrom ellar.common import IExecutionContext, JSONResponse, Response\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\nfrom ellar.samples.modules import HomeModule\n\n\n@Module(\n    modules=[HomeModule, lazyLoad('project_name.auth.module:AuthModule'),],\n)\nclass ApplicationModule(ModuleBase):\n    pass\n</code></pre> <p>Then restart the server if it is\u00a0not running. <pre><code>ellar runserver --reload\n</code></pre> Let us make some requests to the server. Open a terminal window and run the code below: <pre><code>$ # POST to /auth/login\n$ curl -X POST http://localhost:8000/auth/login -d '{\"username\": \"john\", \"password\": \"password\"}' -H \"Content-Type: application/json\"\n{\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTg3OTE0OTE...\"}\n$ # Note: above JWT truncated\n</code></pre></p>"},{"location":"security/authentication/guard-strategy/#implementing-the-authentication-guard","title":"Implementing the authentication guard","text":"<p>At this point, we can now comfortably address our final requirement: protecting endpoints by requiring a valid JWT to be  present on the request. We will do this by creating an AuthGuard that will be used to guard our routes.\u00a0</p> auth/guards.py<pre><code>import typing as t\n\nfrom ellar.auth import UserIdentity\nfrom ellar.common.serializer.guard import (\n    HTTPAuthorizationCredentials,\n)\nfrom ellar.auth.guards import GuardHttpBearerAuth\nfrom ellar.di import injectable\nfrom ellar_jwt import JWTService\nfrom ellar.common import IExecutionContext\nfrom ellar.common.logging import logger\n\n\n@injectable\nclass AuthGuard(GuardHttpBearerAuth):\n    def __init__(self, jwt_service: JWTService) -&gt; None:\n        self.jwt_service = jwt_service\n\n    async def authentication_handler(\n        self,\n        context: IExecutionContext,\n        credentials: HTTPAuthorizationCredentials,\n    ) -&gt; t.Optional[t.Any]:\n        try:\n            data = await self.jwt_service.decode_async(credentials.credentials)\n            return UserIdentity(auth_type=self.scheme, **data)\n        except Exception as ex:\n            logger.logger.error(f\"[AuthGuard] Exception: {ex}\")\n            self.raise_exception()\n</code></pre> <p>We can now implement our protected route and register our AuthGuard to guard it.</p> auth/controllers.py<pre><code>from ellar.common import Controller, ControllerBase, post, Body, get, UseGuards\nfrom .services import AuthService\nfrom .guards import AuthGuard\n\n\n@Controller\nclass AuthController(ControllerBase):\n    def __init__(self, auth_service: AuthService) -&gt; None:\n        self.auth_service = auth_service\n\n    @post(\"/login\")\n    async def sign_in(self, username: Body[str], password: Body[str]):\n        return await self.auth_service.sign_in(username=username, password=password)\n\n    @get(\"/profile\")\n    @UseGuards(AuthGuard)\n    async def get_profile(self):\n        return self.context.user\n</code></pre> <p>Ensure the app is running, and test the routes using <code>cURL</code>.</p> <pre><code>$ # GET /auth/profile\n$ curl http://localhost:8000/auth/profile\n{\"detail\":\"Forbidden\"} # status_code=403\n\n$ # POST /auth/login\n$ curl -X POST http://localhost:8000/auth/login -d '{\"username\": \"john\", \"password\": \"password\"}' -H \"Content-Type: application/json\"\n{\"access_token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTg3OTE0OTE...\"}\n\n$ # GET /profile using access_token returned from previous step as bearer code\n$ curl http://localhost:8000/auth/profile -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm...\"\n{\"exp\":1698793558,\"iat\":1698793258,\"jti\":\"e96e94c5c3ef4fbbbd7c2468eb64534b\",\"sub\":1,\"user_id\":1,\"username\":\"john\", \"id\":null,\"auth_type\":\"bearer\"}\n</code></pre> <p>Note in the <code>AuthModule</code> configuration, we configured the JWT to have an expiration of 5 minutes.  If you wait 5 minutes after authenticating before attempting a <code>GET</code> <code>/auth/profile</code> request,  you'll receive a <code>401</code> Unauthorized response.  This is because the <code>EllarJWT</code> package automatically checks the JWT for its expiration time,  saving you the trouble of doing so in your application.</p>"},{"location":"security/authentication/guard-strategy/#refresh-token","title":"Refresh Token","text":"<p>This was not included in the requirement, but it might be useful to some developers.  So, let us address token refresh using EllarJWT. Depending your application, this illustration may vary.</p> <p>To get this done, we need to edit the <code>sign_in</code> in <code>AuthService</code> to return <code>access_token</code> and <code>refresh_token</code>. We also need to add a <code>refresh_token</code> endpoint to our <code>AuthController</code>.</p> auth/services.py<pre><code>import typing as t\nfrom datetime import timedelta\n\nfrom ellar.core.security.hashers import check_password\nfrom ellar.di import injectable\nfrom ellar.common import exceptions\nfrom ellar_jwt import JWTService\n\nfrom ..user.services import UsersService\n\n\n@injectable()\nclass AuthService:\n    def __init__(self, users_service: UsersService, jwt_service: JWTService) -&gt; None:\n        self.users_service = users_service\n        self.jwt_service = jwt_service\n\n    async def sign_in(self, username: str, password: str) -&gt; t.Any:\n        user_model = await self.users_service.get_user_by_username(username)\n        if user_model is None:\n            raise exceptions.AuthenticationFailed()\n\n        if not check_password(password, user_model.password):\n            raise exceptions.AuthenticationFailed()\n\n        result = {\n            \"access_token\": await self.jwt_service.sign_async(\n                payload=dict(user_model.serialize(), sub=user_model.user_id)\n            ),\n            \"refresh_token\": await self.jwt_service.sign_async(\n                payload=dict(sub=user_model.username),\n                lifetime=timedelta(days=30)\n            ),\n        }\n        return result\n\n    async def refresh_token(self, refresh_token: str) -&gt; t.Dict:\n        try:\n            payload = await self.jwt_service.decode_async(refresh_token)\n        except Exception:\n            raise exceptions.AuthenticationFailed()\n\n        user_model = await self.users_service.get_user_by_username(payload['username'])\n        if user_model is None:\n            raise exceptions.AuthenticationFailed()\n\n        return {\n            \"access_token\": await self.jwt_service.sign_async(\n                payload=dict(user_model.serialize(), sub=user_model.user_id)\n            ),\n        }\n</code></pre> <p>We have modified the sign_in method and added the refresh_token method to handle refresh token actions.  The <code>sign_in</code> method return <code>access_token</code> and <code>refresh_token</code> that expires in 30days.</p> <p>auth/controllers.py<pre><code>from ellar.common import Controller, ControllerBase, post, Body, get, UseGuards\nfrom ellar.openapi import ApiTags\nfrom .services import AuthService\nfrom .guards import AuthGuard\n\n\n@Controller\n@ApiTags(name='Authentication', description='User Authentication Endpoints')\nclass AuthController(ControllerBase):\n    def __init__(self, auth_service: AuthService) -&gt; None:\n        self.auth_service = auth_service\n\n    @post(\"/login\")\n    async def sign_in(self, username: Body[str], password: Body[str]):\n        return await self.auth_service.sign_in(username=username, password=password)\n\n    @get(\"/profile\")\n    @UseGuards(AuthGuard)\n    async def get_profile(self):\n        return self.context.user\n\n    @post(\"/refresh\")\n    async def refresh_token(self, payload: str = Body(embed=True)):\n        return await self.auth_service.refresh_token(payload)\n</code></pre> With the above illustration refresh token mechanism is complete. </p> <p>Note</p> <p>There are ways of refreshing tokens. This was to illustrate how you can achieve it using ellar-jwt package.</p> <p>You can also vist http://localhost:8000/docs </p>"},{"location":"security/authentication/guard-strategy/#apply-authguard-globally","title":"Apply AuthGuard Globally","text":"<p>In situations when you need to protect all your endpoints, you can register <code>AuthGuard</code> as a global guard instead of  using the <code>@UseGuards</code> decorator in all your controllers or route functions.  However, you also need to implement a mechanism to skip the auth guard for certain route functions  that don't require it, such as the <code>sign_in</code> route function.</p> <p>First, let us register <code>AuthGuard</code> a global guard in <code>AuthModule</code>.</p> auth/module.py<pre><code>from datetime import timedelta\nfrom ellar.app import use_global_guards\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase, LazyModuleImport as lazyLoad\nfrom ellar.di import ProviderConfig\nfrom ellar_jwt import JWTModule\n\nfrom .controllers import AuthController\nfrom .services import AuthService\nfrom .guards import AuthGuard\n\n## Registers AuthGuard in Application Config GLOBAL GUARDS\nuse_global_guards(AuthGuard)\n\n\n@Module(\n    modules=[\n        lazyLoad('project_name.users.module:UserModule'),\n        JWTModule.setup(\n            signing_secret_key=\"my_poor_secret_key_lol\", lifetime=timedelta(minutes=5)\n        ),\n    ],\n    controllers=[AuthController],\n    providers=[AuthService, ProviderConfig(GlobalGuard, use_class=AuthGuard)],\n)\nclass AuthModule(ModuleBase):\n    \"\"\"\n    Auth Module\n    \"\"\"\n</code></pre> <p>With this, <code>AuthGuard</code> will be available to all endpoints.</p>"},{"location":"security/authentication/guard-strategy/#anonymous-route-function-mechanism","title":"Anonymous Route Function Mechanism","text":"<p>Let us define a mechanism for declaring routes as anonymous or public. </p> Using Route Function MetaDataUsing GuardCanActivate <p>One way to achieve this, is by using the <code>set_metadata</code> decorator. We can set some metadata on those functions, and it can be read in AuthGuard.  If the metadata is present, we exit the authentication verification and allow the execution to continue.</p> auth/guards.py<pre><code>import typing as t\n\nfrom ellar.auth import UserIdentity\nfrom ellar.common.serializer.guard import (\n    HTTPAuthorizationCredentials,\n)\nfrom ellar.common import IExecutionContext, set_metadata, logger\nfrom ellar.auth.guards import GuardHttpBearerAuth\nfrom ellar.core import Reflector\nfrom ellar.di import injectable\nfrom ellar_jwt import JWTService\n\nIS_ANONYMOUS = 'is_anonymous'\n\n\ndef allow_any() -&gt; t.Callable:\n    return set_metadata(IS_ANONYMOUS, True)    \n\n\n@injectable\nclass AuthGuard(GuardHttpBearerAuth):\n    def __init__(self, jwt_service: JWTService, reflector: Reflector) -&gt; None:\n        self.jwt_service = jwt_service\n        self.reflector = reflector\n\n    async def authentication_handler(\n        self,\n        context: IExecutionContext,\n        credentials: HTTPAuthorizationCredentials,\n    ) -&gt; t.Optional[t.Any]:\n        is_anonymous = self.reflector.get_all_and_override(IS_ANONYMOUS, context.get_handler(), context.get_class())\n\n        if is_anonymous:\n            return True\n\n        try:\n            data = await self.jwt_service.decode_async(credentials.credentials)\n            return UserIdentity(auth_type=self.scheme, **data)\n        except Exception as ex:\n            logger.error(f\"[AuthGuard] Exception: {ex}\")\n            self.raise_exception()\n</code></pre> <p>We have defined the <code>allow_any</code> metadata decorator in the above illustration and have used Ellar's built-in class <code>Reflector</code> to read the metadata defined at the controller or route function.</p> <p>We can create an <code>allow_any</code> decorator function that defines a guard metadata on the decorated function to override the global guard</p> auth/guards.py<pre><code>import typing as t\n\nfrom ellar.auth import UserIdentity\nfrom ellar.common.serializer.guard import (\n    HTTPAuthorizationCredentials,\n)\nfrom ellar.common import IExecutionContext, set_metadata, constants, GuardCanActivate, logger\nfrom ellar.auth.guards import GuardHttpBearerAuth\nfrom ellar.di import injectable\nfrom ellar_jwt import JWTService\n\n\ndef allow_any() -&gt; t.Callable:\n    return set_metadata(constants.GUARDS_KEY, [AllowAny])\n\n\nclass AllowAny(GuardCanActivate):\n    async def can_activate(self, context: IExecutionContext) -&gt; bool:\n        return True\n\n\n@injectable\nclass AuthGuard(GuardHttpBearerAuth):\n    def __init__(self, jwt_service: JWTService) -&gt; None:\n        self.jwt_service = jwt_service\n\n    async def authentication_handler(\n        self,\n        context: IExecutionContext,\n        credentials: HTTPAuthorizationCredentials,\n    ) -&gt; t.Optional[t.Any]:\n        try:\n            data = await self.jwt_service.decode_async(credentials.credentials)\n            return UserIdentity(auth_type=\"bearer\", **data)\n        except Exception as ex:\n            logger.logger.error(f\"[AuthGuard] Exception: {ex}\")\n            self.raise_exception()\n</code></pre>"},{"location":"security/authentication/guard-strategy/#using-allow_any-decorator-function","title":"Using allow_any decorator function","text":"<p>We have seen from above how to get <code>allow_any</code> decorator function. Now we use it on the <code>refresh</code> and <code>sign in</code> endpoints as shown below:</p> <p>auth/controllers.py<pre><code>from ellar.common import Controller, ControllerBase, post, Body, get\nfrom ellar.openapi import ApiTags\nfrom .services import AuthService\nfrom .guards import AuthGuard, allow_any\n\n\n@Controller\n@ApiTags(name='Authentication', description='User Authentication Endpoints')\nclass AuthController(ControllerBase):\n    def __init__(self, auth_service: AuthService) -&gt; None:\n        self.auth_service = auth_service\n\n    @post(\"/login\")\n    @allow_any()\n    async def sign_in(self, username: Body[str], password: Body[str]):\n        return await self.auth_service.sign_in(username=username, password=password)\n\n    @get(\"/profile\")\n    async def get_profile(self):\n        return self.context.user\n\n    @allow_any()\n    @post(\"/refresh\")\n    async def refresh_token(self, payload: str = Body(embed=True)):\n        return await self.auth_service.refresh_token(payload)\n</code></pre> Source Code to this example is here</p>"},{"location":"techniques/background-task/","title":"Background Tasks","text":"<p>Background tasks refer to tasks that are associated with a response and are processed after the response has been sent to the client.  An illustrative example of such tasks includes email notifications sent as a follow-up to a performed action.</p>"},{"location":"techniques/background-task/#adding-backgroundtask","title":"Adding BackgroundTask","text":"<p>In Ellar, you can access the response object and set a <code>background</code> parameter. <pre><code>from starlette.background import BackgroundTask\nfrom ellar.common import ModuleRouter, Response\n\nrouter = ModuleRouter('/background-test')\n\nasync def send_welcome_email(email):\n    print(f'Send Welcome Email Task Called with {email}')\n\n@router.post('/signup')\ndef sign_up(username: str, password: str, email: str, res:Response):\n    res.background = BackgroundTask(send_welcome_email, email=email)\n    return {'status': 'Signup successful'}\n</code></pre> In above construct, we created <code>BackgroundTask</code> around <code>send_welcome_email</code> function and passed to it some <code>*args/**kwargs</code>required to invoke the wrapped function. After the response has been sent to the client, the background function[<code>send_welcome_email</code>] will be called and there will be a print on the server log.</p>"},{"location":"techniques/background-task/#using-backgroundtasks","title":"Using BackgroundTasks","text":"<p><code>BackgroundTasks</code> is another class from Starlette useful for adding multiple background tasks to a response.  Unlike the previous construct, <code>BackgroundTasks</code> can be injected into your route function by type annotation.</p> <p>For example: <pre><code>from starlette.background import BackgroundTasks\nfrom ellar.common import ModuleRouter\n\nrouter = ModuleRouter('/background-test')\n\ndef another_background_task(parameter):\n    print(f'Another Background task called with \"{parameter}\"')\n\nasync def send_welcome_email(email):\n    print(f'Send Welcome Email Task Called with \"{email}\"')\n\n@router.post('/signup')\ndef sign_up(username: str, password: str, email: str, tasks: BackgroundTasks):\n    tasks.add_task(send_welcome_email, email=email)\n    tasks.add_task(another_background_task, 'another_background_task parameter')\n    return {'status': 'Signup successful'}\n</code></pre></p> <p>During request response cycle, <code>BackgroundTasks</code> will be resolved made available to the route handler function.</p> <p>Hint</p> <p>The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.</p>"},{"location":"techniques/caching/","title":"Caching","text":"<p>Caching refers to the process of storing frequently accessed data in a temporary storage area called a <code>cache</code>,  in order to speed up access to that data in the future.</p> <p>In computing, caching is used to optimize the performance of applications and systems by reducing the time it takes to retrieve data from slower or more distant storage.  By caching data in a faster, more local storage location, the system can quickly retrieve the data without needing to go all the way to the original source of the data.</p> <p>In Ellar, we provided several cache backends interface that interacts with different cache types to assist in cache endpoint responses or other relevant data.</p>"},{"location":"techniques/caching/#setting-up-the-cache","title":"Setting up the cache","text":"<p>It's very simple to set up cache in Ellar but the crucial part is picking the cache type that is suitable for your application  because some cache type behave differently and perform better and faster than others.</p> <p>To set up cache, we need to use <code>CacheModule</code>. <code>CacheModule</code> provides two methods, <code>CacheModule.register_setup</code> and <code>CacheModule.setup</code>, for setting up <code>cache</code> in ellar applications.</p> CacheModule Register SetupCacheModule Setup <p>This setup method requires you to defined <code>CACHES</code> variable containing  key value pairs of cache backends in <code>config.py</code> file.</p> <p>for example:</p> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.local_cache import LocalMemCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': LocalMemCacheBackend(ttl=300, key_prefix='local', version=1)\n    }\n</code></pre> <p>After that you register <code>CacheModule</code> to application modules <pre><code># project_name/root_module.py\nfrom ellar.cache import CacheModule\nfrom ellar.common import Module\n\n@Module(modules=[CacheModule.register_setup()])\nclass ApplicationModule:\n    pass\n</code></pre> The <code>register_setup</code> will read <code>CACHES</code> from application config and setup the <code>CacheService</code> appropriately.</p> <p>The setup method requires direct definition of cache backend on the <code>CacheModule</code> setup function.</p> <p>for example:</p> <p><pre><code># project_name/root_module.py\nfrom ellar.cache import CacheModule\nfrom ellar.cache.backends.local_cache import LocalMemCacheBackend\nfrom ellar.common import Module\n\n@Module(modules=[\n    CacheModule.setup(\n        default=LocalMemCacheBackend(ttl=300, key_prefix='default', version=1),\n        local=LocalMemCacheBackend(key_prefix='local'),\n        others=LocalMemCacheBackend(key_prefix='others'),\n    )\n])\nclass ApplicationModule:\n    pass\n</code></pre> In CacheModule.<code>setup</code>, the <code>default</code> parameter must be provided and other cache  backends will be defined as keyword-arguments just like <code>local</code> and <code>others</code> incase you want to set up more than one cache backend.</p>"},{"location":"techniques/caching/#memcached","title":"Memcached","text":"<p>Memcached is an entirely memory-based cache server, originally developed to handle high loads at LiveJournal.com and subsequently open-sourced by Danga Interactive.</p> <p>Memcached runs as a daemon and is allotted a specified amount of RAM. All it does is provide a fast interface for adding, retrieving and deleting data in the cache. All data is stored directly in memory.</p> <p>After installing Memcached itself, you\u2019ll need to install a Memcached binding.  There are several Python Memcached bindings available; </p> <p>Ellar supports are pylibmc and pymemcache</p> <p>For an example, lets assume you have a Memcached is running on localhost (127.0.0.1) port 11211, using the <code>pymemcache</code> or <code>pylibmc</code> binding:</p> pymemcachepylibmc <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyMemcacheCacheBackend(servers=['127.0.0.1:11211'])\n    }\n</code></pre> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pylib_cache import PyLibMCCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyLibMCCacheBackend(servers=['127.0.0.1:11211'])\n    }\n</code></pre> <p>If Memcached is available through a local Unix socket file /tmp/memcached.sock using the <code>pymemcache</code> or <code>pylibmc</code> binding:</p> pymemcachepylibmc <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyMemcacheCacheBackend(servers=['/tmp/memcached.sock'])\n    }\n</code></pre> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pylib_cache import PyLibMCCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyLibMCCacheBackend(servers=['/tmp/memcached.sock'])\n    }\n</code></pre> <p>if your Memcached is its ability to share a cache over multiple servers, then you can config that too Lets assume the cache is shared over Memcached instances running on IP address 172.19.26.240 and 172.19.26.242, both on port 11211 or different ports</p> pymemcachepylibmc <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyMemcacheCacheBackend(servers=[\n            '172.19.26.240:11211',\n            '172.19.26.242:11212',\n            '172.19.26.244:11213',\n        ])\n    }\n</code></pre> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pylib_cache import PyLibMCCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyLibMCCacheBackend(servers=[\n            '172.19.26.240:11211',\n            '172.19.26.242:11212',\n            '172.19.26.244:11213',\n        ])\n    }\n</code></pre> <p>For pymemcache, we provided some default configuration during initialization shown below: <pre><code>import pymemcache\n\n_options = {\n    'allow_unicode_keys': True,\n    'default_noreply': False,\n    'serde': pymemcache.serde.pickle_serde,\n}\n</code></pre></p> <p>These can be changed by setting the desired value in <code>options</code> parameter during initialization. For example:</p> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyMemcacheCacheBackend(servers=[\n            '172.19.26.240:11211',\n            '172.19.26.242:11212',\n            '172.19.26.244:11213',\n        ], options={'default_noreply': True})\n    }\n</code></pre>"},{"location":"techniques/caching/#redis","title":"Redis","text":"<p>Redis is a high-performance, in-memory database that is commonly used for caching data.  To get started with Redis, you will need to have a Redis server running on either your local machine or a remote server.</p> <p>Once you have set up the Redis server,  you will need to install the Redis Python client library to be able  to communicate with Redis from your Python code. </p> <p>To use redis in Ellar, you need to import RedisCacheBackend from <code>ellar.cache.backend.redis</code>.</p> <p>Let's assume after setting up your redis server and it's running on localhost (127.0.0.1) port 6379:</p> RedisRedis - with username and passwordRedis - multiple server <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.redis import RedisCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': RedisCacheBackend(servers=['redis://127.0.0.1:6379'])\n    }\n</code></pre> <p>Often Redis servers are protected with authentication.  In order to supply a username and password as follows: <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.redis import RedisCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': RedisCacheBackend(servers=['redis://username:password@127.0.0.1:6379'])\n    }\n</code></pre></p> <p>If you have multiple Redis servers set up in the replication mode, you can specify the servers either as a semicolon or comma delimited string, or as a list.  While using multiple servers, write operations are performed on the first server (leader).  Read operations are performed on the other servers (replicas) chosen at random:</p> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.redis import RedisCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': RedisCacheBackend(servers=[\n            'redis://127.0.0.1:6379', # leader\n            'redis://127.0.0.1:6378', # read-replica 1\n            'redis://127.0.0.1:6377', # read-replica 2\n        ])\n    }\n</code></pre>"},{"location":"techniques/caching/#local-memory-caching","title":"Local-memory caching","text":"<p>The local memory cache is the default caching mechanism used by Ellar, and it is automatically used if you do not specify a different caching backend in your config.py file.  This cache stores cached data in memory, which provides fast access to cached data, and is ideal if you don't have the resources or capabilities to set up a separate caching server like Memcached. Its also thread-safe.</p> Local Memory Cache <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.local_cache import LocalMemCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': LocalMemCacheBackend()\n    }\n</code></pre>"},{"location":"techniques/caching/#custom-cache-backend","title":"Custom Cache Backend","text":"<p>You can create you own version of the cache backend. All you need is to inherit for <code>ellar.</code></p> <p>for example: <pre><code># project_name/cache_backend.py\nfrom ellar.cache.model import BaseCacheBackend\n\nclass CustomCacheBackend(BaseCacheBackend):\n    pass\n</code></pre> Then, in config.py <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom .cache_backend import CustomCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': CustomCacheBackend()\n    }\n</code></pre></p>"},{"location":"techniques/caching/#cache-arguments","title":"Cache Arguments","text":"<p>You can customize the behavior of each caching backend in Django by passing additional arguments when you configure the cache. The valid arguments that can be passed to each backend are as follows:</p> <ul> <li>TIMEOUT: The default timeout, in seconds, to use for the cache. This argument defaults to 300 seconds (5 minutes). You can set TIMEOUT to None so that, by default, cache keys never expire. A value of 0 causes keys to immediately expire</li> <li>OPTIONS: Any options that should be passed to the cache backend. The list of valid options will vary with each backend.</li> <li>KEY_PREFIX: A string that will be automatically prepended to all cache keys.</li> <li>VERSION: The default version number for cache keys.</li> </ul> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.pymem_cache import PyMemcacheCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': PyMemcacheCacheBackend(\n            servers=['127.0.0.1:11211'], \n            options={'default_noreply': True}, \n            ttl=300, \n            version=1, \n            key_prefix='project_name'\n        )\n    }\n</code></pre>"},{"location":"techniques/caching/#setting-up-more-than-one-cache-backend","title":"Setting up More than One Cache Backend","text":"<p>To set up multiple cache backends in Django, you can add additional entries to the <code>CACHES</code> variable in your <code>config.py</code> file.  The <code>default</code> cache backend is typically defined first, followed by any additional cache backends you want to configure.</p> <p>Here's an example <code>CACHES</code> setting that defines two cache backends:</p> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.cache.backends.redis import RedisCacheBackend\nfrom ellar.cache.backends.local_cache import LocalMemCacheBackend\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    CACHES = {\n        'default': RedisCacheBackend(servers=['redis://127.0.0.1:6379'], key_prefix='project_name'),\n        'secondary': LocalMemCacheBackend(ttl=300, key_prefix='project_name', version=1)\n    }\n</code></pre>"},{"location":"techniques/caching/#cacheservice-icacheservice","title":"CacheService (ICacheService)","text":"<p>Ellar does not provide cache backends directly, but instead offers a caching service that manages all the configured cache backends in your application.  The <code>CacheService</code> class serves as a wrapper for these cache backends and provides a uniform interface for interacting with them.</p> <p>The <code>CacheService</code> class can be injected into your application's code as a dependency, allowing you to use it throughout your application without the need for direct instantiation.  This approach promotes a more modular and extensible design, as well as better testability of your code.</p> <p>The CacheService class provides methods like:</p> <p>class CacheService(ICacheService):</p> <ul> <li>get(key: str, version: str = None, backend: str = None): gets <code>key</code> value from a specified cache backend.</li> <li>get_async(key: str, version: str = None, backend: str = None): asynchronous version of <code>get</code> action</li> <li>set(key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None): sets value to a key to a specified cache backend.</li> <li>set_async(key: str, value: t.Any, ttl: t.Union[float, int] = None, version: str = None,backend: str = None): asynchronous version of <code>set</code> action</li> <li>delete(key: str, version: str = None, backend: str = None): deletes a key from a specified cache backend.</li> <li>delete_async(key: str, version: str = None, backend: str = None): asynchronous version of <code>delete</code> action</li> <li>has_key(key: str, version: str = None, backend: str = None): checks if a key exist in a specified backend</li> <li>has_key_async(key: str, version: str = None, backend: str = None): asynchronous version of <code>has_key</code> action</li> <li>touch(key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None): sets a new expiration for a key</li> <li>touch_async(key: str, ttl: t.Union[float, int] = None, version: str = None, backend: str = None): asynchronous version of <code>touch</code> action</li> <li>incr(key: str, delta: int = 1, version: str = None, backend: str = None): increments a value for a key by delta</li> <li>incr_async(key: str, delta: int = 1, version: str = None, backend: str = None): asynchronous version of <code>incr</code> action</li> <li>decr(key: str, delta: int = 1, version: str = None, backend: str = None): decrement a value for a key by delta</li> <li>decr_async(key: str, delta: int = 1, version: str = None, backend: str = None): asynchronous version of <code>decr</code> action</li> </ul> <p>Note</p> <p>If <code>backend=None</code>, <code>default</code> backend configuration is used.</p> <p>These methods are available for each of the configured cache backends and can be used interchangeably with any backend.</p>"},{"location":"techniques/caching/#injecting-cacheservice","title":"Injecting CacheService","text":"<p><code>CacheService</code> is a core service registered in <code>EllarInjector</code> and can be injected as every other service.</p> <p>For example, lets make <code>CacheService</code> available in our route function.</p> Synchronous Route FunctionAsynchronous Route Function <pre><code>from ellar.common import get, Inject\nfrom ellar.cache import ICacheService\n\n...\n@get('/cache-test')\ndef my_route_function(self, cache_service: Inject[ICacheService]):\n    cached_value = cache_service.get(\"my-key\")\n    if cached_value:\n        return cached_value\n    processed_value = 'some-value'\n    cache_service.set('my-key', processed_value, ttl=300) # for 5mins\n    return processed_value\n</code></pre> <pre><code>from ellar.common import get, Inject\nfrom ellar.cache import ICacheService\n\n...\n@get('/cache-test')\nasync def my_route_function(self, cache_service: Inject[ICacheService]):\n    cached_value = await cache_service.get_async(\"my-key\")\n    if cached_value:\n        return cached_value\n    processed_value = 'some-value'\n    await cache_service.set_async('my-key', processed_value, ttl=300) # for 5mins\n    return processed_value\n</code></pre>"},{"location":"techniques/caching/#using-cache-decorator","title":"Using Cache Decorator","text":"<p>Ellar provides a cache decorator that can be used to cache the responses of route functions.  The cache decorator can be applied to a route function to automatically cache its response data for a specified amount of time.</p> <p>The cache decorator takes the following arguments:</p> <ul> <li><code>ttl</code>(time to live): the amount of time (in seconds) for which the response data should be cached.</li> <li><code>key_prefix</code> (optional): a string that is used to prefix the cache key, allowing for easy differentiation between different cache items.</li> <li><code>version</code> (optional): a string that is used to version the cache key, allowing for cache invalidation when the data schema changes.</li> <li><code>backend</code> (optional): the name of the cache backend to use for storing the cached data. By default, the <code>default</code> cache backend is used.</li> <li><code>make_key_callback</code> (optional): a callback function that can be used to generate a custom cache key. This function takes an <code>IExecutionContext</code> instance (which contains information about the request context) and key prefix, and should return the custom cache key to use.</li> </ul> <p>Info</p> <p><code>Cache</code> Decorator can also be applied to any controller class.  When this is done, all the routes response of that controller will be cached</p> <p>We can rewrite the above example using <code>cache</code> decorator:</p> Synchronous Route FunctionAsynchronous Route Function <pre><code>from ellar.common import get\nfrom ellar.cache import Cache\n...\n@get('/cache-test')\n@Cache(ttl=300, version='v1', key_prefix='project_name')\ndef my_route_function(self):\n    processed_value = 'some-value'\n    return processed_value\n</code></pre> <pre><code>from ellar.common import get\nfrom ellar.cache import Cache\n\n...\n@get('/cache-test')\n@Cache(ttl=300, version='v1', key_prefix='project_name')\nasync def my_route_function(self):\n    processed_value = 'some-value'\n    return processed_value\n</code></pre>"},{"location":"techniques/caching/#adding-custom-key-gen-function-for-cache-decorator","title":"Adding Custom key gen function for cache Decorator","text":"<p>By default, the <code>cache</code> decorator combines the route function's URL and the specified <code>key_prefix</code> value to generate the cache key used to store the response data.  However, you can customize this behavior by providing a <code>make_key_callback</code> function to the cache decorator.</p> <p>The <code>make_key_callback</code> function takes an <code>ExecutionContext</code> instance (which contains information about the request context) and the <code>key_prefix</code> value as input, and should return the custom cache key to use.</p> <p>Here's an example of how to use a custom <code>make_key_callback</code> function with the cache decorator:</p> Synchronous Route FunctionAsynchronous Route Function <pre><code>from ellar.common import get\nfrom ellar.cache import Cache\nfrom ellar.core import ExecutionContext\nfrom ellar.utils import get_name\n\ndef make_key_function(ctx: ExecutionContext, key_prefix: str) -&gt; str:\n    function_name = get_name(ctx.get_handler())\n    return \"%s:%s:%s\" % (function_name, key_prefix, ctx.switch_to_http_connection().get_client().url)\n\n...\n@get(\"/my_endpoint\")\n@Cache(ttl=60, make_key_callback=make_key_function)\ndef my_endpoint(self):\n    # Code to generate response data here\n    processed_value = 'some-value'\n    return processed_value\n...\n</code></pre> <pre><code>from ellar.common import get\nfrom ellar.cache import Cache\nfrom ellar.core import ExecutionContext\nfrom ellar.utils import get_name\n\ndef _make_key_function(ctx: ExecutionContext, key_prefix: str) -&gt; str:\n    function_name = get_name(ctx.get_handler())\n    return \"%s:%s:%s\" % (function_name, key_prefix, ctx.switch_to_http_connection().get_client().url)\n\n...\n@get(\"/my_endpoint\")\n@Cache(ttl=60, make_key_callback=_make_key_function)\nasync def my_endpoint(self):\n    # Code to generate response data here\n    processed_value = 'some-value'\n    return processed_value\n...\n</code></pre> <p>In this example, the <code>cache</code> decorator is applied to the <code>my_endpoint</code> route function, with a custom <code>make_key_callback</code> function specified. </p> <p>The <code>make_key_callback</code> function uses the <code>get_name</code> helper function to extract the name of the route function, and combines it with the <code>key_prefix</code> value and the request URL to generate the cache key.</p>"},{"location":"techniques/configurations/","title":"Application Configurations","text":"<p>The <code>config.py</code> file contains all the configuration necessary in bootstrapping ellar application. </p> <p>Lets in this section go through the different configuration available.</p>"},{"location":"techniques/configurations/#configuration-variables","title":"Configuration Variables","text":""},{"location":"techniques/configurations/#secret_key","title":"SECRET_KEY","text":"<p>Default: <code>' '</code> (Empty string)</p> <p>A secret key is a unique and unpredictable value.</p> <p><code>ellar new project</code> command automatically adds a randomly-generated <code>SECRET_KEY</code> to each new project.</p>"},{"location":"techniques/configurations/#debug","title":"DEBUG","text":"<p>Default: <code>False</code></p> <p>A boolean that turns on/off debug mode.</p> <p>Never deploy a site into production with <code>DEBUG</code> turned <code>on</code>.</p> <p>One of the main features of <code>debug</code> mode is the display of detailed error pages.  If your app raises an exception when <code>DEBUG</code> is <code>True</code>, Ellar will display a detailed traceback.</p> <p>If <code>DEBUG</code> is <code>False</code>, you also need to properly set the <code>ALLOWED_HOSTS</code> setting. Failing to do so will result in all requests being returned as <code>\u201cBad Request (400)\u201d</code>.</p>"},{"location":"techniques/configurations/#injector_auto_bind","title":"INJECTOR_AUTO_BIND","text":"<p>Default: <code>False</code></p> <p>A boolean that turns on/off injector <code>auto_bind</code> property.</p> <p>When turned on, <code>injector</code> can automatically bind to missing types as <code>singleton</code> at the point of resolving object dependencies. And when turned off, missing types will raise an <code>UnsatisfiedRequirement</code> exception.</p>"},{"location":"techniques/configurations/#default_json_class","title":"DEFAULT_JSON_CLASS","text":"<p>Default: <code>JSONResponse</code> - (<code>starlette.common.JSONResponse</code>)</p> <p>DEFAULT_JSON_CLASS is used when sending JSON response to the client.</p> <p>There are other options for JSON available in Ellar:</p> <ul> <li>UJSONResponse(<code>ellar.common.UJSONResponse</code>):  renders JSON response using ujson. </li> <li>ORJSONResponse(<code>ellar.common.ORJSONResponse</code>):  renders JSON response using orjson. </li> </ul>"},{"location":"techniques/configurations/#jinja_templates_options","title":"JINJA_TEMPLATES_OPTIONS","text":"<p>Default: <code>{}</code></p> <p>Default is an empty dictionary object. It defines options used when creating <code>Jinja2</code> Environment for templating.</p> <p>Different keys available:</p> <ul> <li><code>block_start_string</code> (str) \u2013</li> <li><code>block_end_string</code> (str) \u2013</li> <li><code>variable_start_string</code> (str) \u2013</li> <li><code>variable_end_string</code> (str) \u2013</li> <li><code>comment_start_string</code> (str) \u2013</li> <li><code>comment_end_string</code> (str) \u2013</li> <li><code>line_statement_prefix</code> (Optional[str]) \u2013</li> <li><code>line_comment_prefix</code> (Optional[str]) \u2013</li> <li><code>trim_blocks</code> (bool) \u2013</li> <li><code>lstrip_blocks</code> (bool) \u2013</li> <li><code>newline_sequence</code> (te.Literal['\\n', '\\r\\n', '\\r']) \u2013</li> <li><code>keep_trailing_newline</code> (bool) \u2013</li> <li><code>extensions</code> (Sequence[Union[str, Type[Extension]]]) \u2013</li> <li><code>optimized</code> (bool) \u2013</li> <li><code>undefined</code> (Type[jinja2.runtime.Undefined]) \u2013</li> <li><code>finalize</code> (Optional[Callable[[...], Any]]) \u2013</li> <li><code>autoescape</code> (Union[bool, Callable[[Optional[str]], bool]]) \u2013</li> <li><code>loader</code> (Optional[BaseLoader]) \u2013</li> <li><code>cache_size</code> (int) \u2013</li> <li><code>auto_reload</code> (bool) \u2013</li> <li><code>bytecode_cache</code> (Optional[BytecodeCache]) \u2013</li> <li><code>enable_async</code> (bool)</li> </ul> <p>Info</p> <p>Check Jinja2 environment option for more information.</p>"},{"location":"techniques/configurations/#versioning_scheme","title":"VERSIONING_SCHEME","text":"<p>Default: <code>DefaultAPIVersioning()</code></p> <p>VERSIONING_SCHEME defined the versioning scheme for the application. The DefaultAPIVersioning is placeHolder object for versioning scheme.</p> <p>Other Options includes:</p> <ul> <li>UrlPathAPIVersioning - for url versioning. eg <code>https://example.com/v1</code> or <code>https://example.com/v2</code></li> <li>HostNameAPIVersioning - for host versioning. eg <code>https://v1.example.com</code> or <code>https://v2.example.com</code></li> <li>HeaderAPIVersioning - for request header versioning. eg <code>Accept: application/json; version=1.0</code></li> <li>QueryParameterAPIVersioning - for request query versioning. eg <code>/something/?version=0.1</code></li> </ul>"},{"location":"techniques/configurations/#redirect_slashes","title":"REDIRECT_SLASHES","text":"<p>Default: <code>False</code></p> <p>A boolean that turns on/off router <code>redirect_slashes</code> property.</p> <p>When REDIRECT_SLASHES is turned on, the Application Router creates a redirect with a <code>/</code> to complete a URL path. This only happens when the URL was not found but may exist when  <code>/</code> is appended to the URL.</p> <p>For example, a route to the user profile goes like this <code>http://localhost:8000/user/profile/</code>. If a path like this is passed <code>http://localhost:8000/user/profile</code>, it will be redirected to <code>http://localhost:8000/user/profile</code> automatically.</p> <p>This approach may be complex depending on the application size because ApplicationRouter has to loop through its routes twice.</p> <p>When REDIRECT_SLASHES is turned off, URL paths have to be an exact match, or a <code>404</code> exception is raised.</p>"},{"location":"techniques/configurations/#static_folder_packages","title":"STATIC_FOLDER_PACKAGES","text":"<p>Default: <code>[]</code></p> <p>It is used to apply static files that exist in installed python package.</p> <p>For example:</p> <p><pre><code>STATIC_FOLDER_PACKAGES = [('boostrap4', 'statics')]\n</code></pre> <code>'boostrap4'</code> is the package, and <code>'statics'</code> is the static folder.</p>"},{"location":"techniques/configurations/#static_directories","title":"STATIC_DIRECTORIES","text":"<p>Default: <code>[]</code></p> <p>It is used to apply static files that project level</p> <p>For example:</p> <pre><code>STATIC_DIRECTORIES = ['project_name/staticfiles', 'project_name/path/to/static/files']\n</code></pre>"},{"location":"techniques/configurations/#middleware","title":"MIDDLEWARE","text":"<p>Default: <code>[]</code></p> <p>MIDDLEWARE defines a list of user-defined ASGI Middleware to be applied to the application alongside default application middleware.</p>"},{"location":"techniques/configurations/#exception_handlers","title":"EXCEPTION_HANDLERS","text":"<p>Default: <code>[]</code></p> <p>It defines a list of <code>IExceptionHandler</code> objects used in handling custom exceptions or any exception.</p>"},{"location":"techniques/configurations/#static_mount_path","title":"STATIC_MOUNT_PATH","text":"<p>Default: <code>/static</code></p> <p>It configures the root path to serve static files. For example, if there is a <code>stylesheet.css</code> in a static folder, and <code>STATIC_MOUNT_PATH=/static</code>, <code>stylesheet.css</code> can be reached through the link <code>http://localhost:8000/static/stylesheet.css</code> assuming you are on local development server.</p> <p>Also, if <code>STATIC_MOUNT_PATH=None</code>, static route handler would not be registered to application routes.</p>"},{"location":"techniques/configurations/#serializer_custom_encoder","title":"SERIALIZER_CUSTOM_ENCODER","text":"<p>Default: <code>ENCODERS_BY_TYPE</code> (<code>ellar.pydantic.ENCODERS_BY_TYPE</code>)</p> <p>SERIALIZER_CUSTOM_ENCODER is a key-value pair of a type and function. Default is a pydantic JSON encode type. It is used when serializing objects to JSON format.</p>"},{"location":"techniques/configurations/#default_not_found_handler","title":"DEFAULT_NOT_FOUND_HANDLER","text":"<p>Default: <code>not_found</code> (<code>not_found(scope: TScope, receive: TReceive, send: TSend)</code>)</p> <p>Default is an ASGI function. DEFAULT_NOT_FOUND_HANDLER is used by the application router as a callback function to a resource not found.</p> <pre><code>from ellar.common.types import TScope, TReceive, TSend\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.websockets import WebSocketClose\nfrom ellar.common import PlainTextResponse\n\n\nasync def _not_found(scope: TScope, receive: TReceive, send: TSend) -&gt; None:\n    if scope[\"type\"] == \"websocket\":\n        websocket_close = WebSocketClose()\n        await websocket_close(scope, receive, send)\n        return\n\n    # If we're running inside a starlette application then raise an\n    # exception, so that the configurable exception handler can deal with\n    # returning the response. For plain ASGI apps, just return the response.\n    if \"app\" in scope:\n        raise StarletteHTTPException(status_code=404)\n    else:\n        response = PlainTextResponse(\"Not Found\", status_code=404)\n    await response(scope, receive, send)\n</code></pre>"},{"location":"techniques/configurations/#default_lifespan_handler","title":"DEFAULT_LIFESPAN_HANDLER","text":"<p>Default: <code>None</code></p> <p>DEFAULT_LIFESPAN_HANDLER is a function that returns <code>AsyncContextManager</code>  used to manage <code>startup</code> and <code>shutdown</code> together instead of having a separate handler for <code>startup</code> and <code>shutdown</code> events.</p> <pre><code>import contextlib\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom ellar.app import App\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(app: App):\n    async with some_async_resource():\n        yield\n\n\nclass BaseConfig(ConfigDefaultTypesMixin):\n    DEFAULT_LIFESPAN_HANDLER = lifespan\n</code></pre> <p>Consider using <code>anyio.create_task_group()</code> for managing asynchronous tasks.</p>"},{"location":"techniques/configurations/#cors_allow_origins","title":"CORS_ALLOW_ORIGINS","text":"<p>Default: <code>[]</code></p> <p>A list of origins that should be permitted to make cross-origin requests. e.g. <code>['https://example.org', 'https://www.example.org']</code>. </p> <p>You can use <code>['*']</code> to allow any origin.</p>"},{"location":"techniques/configurations/#cors_allow_methods-tliststr","title":"CORS_ALLOW_METHODS: t.List[str]","text":"<p>Default: <code>[\"GET\"]</code></p> <p>A list of HTTP methods that should be allowed for cross-origin requests.</p> <p>You can use <code>['*']</code> to allow all standard methods.</p>"},{"location":"techniques/configurations/#cors_allow_headers","title":"CORS_ALLOW_HEADERS:","text":"<p>Default: <code>[]</code></p> <p>A list of HTTP request headers that should be supported for cross-origin requests. </p> <p>You can use <code>['*']</code> to allow all headers. The <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code> and <code>Content-Type</code> headers are always allowed for CORS requests.</p>"},{"location":"techniques/configurations/#cors_allow_credentials","title":"CORS_ALLOW_CREDENTIALS","text":"<p>Default: <code>False</code></p> <p>Indicate that cookies should be supported for cross-origin requests.</p>"},{"location":"techniques/configurations/#cors_allow_origin_regex","title":"CORS_ALLOW_ORIGIN_REGEX:","text":"<p>Default: <code>None</code></p> <p>A regex string to match against origins that should be permitted to make cross-origin requests. eg. <code>'https://.*\\.example\\.org'</code>.</p>"},{"location":"techniques/configurations/#cors_expose_headers","title":"CORS_EXPOSE_HEADERS:","text":"<p>Default: <code>None</code></p> <p>Indicate any response headers that should be made accessible to the browser.</p>"},{"location":"techniques/configurations/#cors_max_age","title":"CORS_MAX_AGE:","text":"<p>Defaults: <code>600</code></p> <p>Sets a maximum time in seconds for browsers to cache CORS responses.</p>"},{"location":"techniques/configurations/#allowed_hosts","title":"ALLOWED_HOSTS","text":"<p>Default: <code>[\"*\"]</code></p> <p>A list of domain names that should be allowed as hostnames in <code>TrustedHostMiddleware</code>. Wildcard domains such as <code>*.example.com</code> are supported for matching subdomains. </p> <p>To allow any hostname either use <code>allowed_hosts=[\"*\"]</code> or omit the middleware.</p>"},{"location":"techniques/configurations/#redirect_host","title":"REDIRECT_HOST","text":"<p>Default: <code>True</code></p> <p>Indicates whether to append <code>www.</code> when redirecting host in <code>TrustedHostMiddleware</code></p>"},{"location":"techniques/configurations/#configuration-with-prefix","title":"Configuration with prefix","text":"<p>Ellar configuration module also support loading of its configurations with appended prefix. for instance, we can have a file <code>my_settings.py</code> with some ellar's configurations set to it with some prefix <code>API_</code> as shown below.</p> <p><pre><code># my_settings.py\nAPI_DEBUG = True\nAPI_SECRET_KEY = \"your-secret-key-changed\"\nAPI_INJECTOR_AUTO_BIND = True\nAPI_JINJA_TEMPLATES_OPTIONS = {\"auto_reload\": True}\n\nOTHER_XYZ_CONFIGS_1 ='whatever'\nOTHER_XYZ_CONFIGS_2 ='whatever2'\n</code></pre> To apply these configurations without having to load everything, you have to provide the prefix to be used to load configurations that belongs to ellar. For example,</p> <p><pre><code>from ellar.app import AppFactory\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(ApplicationModule, config_module=dict(\n    config_module='project_name:my_settings',\n    config_prefix='api_',\n))\n</code></pre> In the above construct, we used a dict object to define the configuration module(<code>'project_name:my_settings'</code>) and prefix <code>api_</code>.  This will be applied to the configuration instance when the application is ready.</p>"},{"location":"techniques/configurations/#defining-configurations-directly","title":"Defining Configurations directly","text":"<p>During application bootstrapping with <code>AppFactory</code>, you can define app configurations directly under <code>config_module</code> as a dict object as some below.</p> <pre><code>from ellar.app import AppFactory\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule, \n    config_module=dict(\n        SECRET_KEY = \"your-secret-key-changed\",\n        INJECTOR_AUTO_BIND = True,\n        MIDDLEWARE=[],\n        EXCEPTION_HANDLERS=[]\n    )\n)\n</code></pre>"},{"location":"techniques/mount/","title":"Mount","text":"<p>In Starlette, <code>Mount</code> is used to mount sub-routes and ASGI apps or WSGI apps. The same is applicable in Ellar.</p> <p>Let's see how to mount sub-routes in ellar <pre><code>from starlette.routing import Mount\nfrom ellar.core.routing import RouteOperation\nfrom ellar.core import Request\n\ndef users(request:Request):\n    return \"List of users\"\n\ndef user(username: str, request:Request):\n    return f\"Users Profile of {username}\"\n\n\nmount = Mount(\n    path='/users', \n    routes=[\n        RouteOperation(path='/', endpoint=users, methods=['GET', 'POST'], response={200: str}), \n        RouteOperation(path='/{username}', endpoint=user, methods=['GET', 'POST'], response={200: str})\n    ]\n)\n</code></pre> In the construct above, we have created a starlette-like example of <code>Mount</code> with a base path <code>/users</code> and with two endpoints,  <code>/</code> to get list of users and <code>/username</code> to a users profile. </p>"},{"location":"techniques/mount/#mount-with-ellar","title":"Mount with Ellar","text":"<p>Now, we have a <code>mount</code> instance for the previous code construct, to get it to work in ellar, we need to register it to a Module.</p> <p>For example, <pre><code>from ellar.common import Module\nfrom .path_to_mount import mount\n\n\n@Module(routers=[mount])\nclass ApplicationModule:\n    pass\n</code></pre></p>"},{"location":"techniques/mount/#applying-middleware-to-mount","title":"Applying Middleware to Mount","text":"<p>Just like in every other ASGI app, middlewares can be added to <code>Mount</code> during its instantiation.</p> <p>For example, <pre><code>...\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\n\n\nmount = Mount(\n    path='/users', \n    routes=[\n        RouteOperation(path='/', endpoint=users, methods=['GET', 'POST'], response={200: str}), \n        RouteOperation(path='/{username}', endpoint=user, methods=['GET', 'POST'], response={200: str})\n    ],\n    middleware=[Middleware(GZipMiddleware)]\n)\n</code></pre> Checkout this documentation from starlette on some conditions to using <code>middleware</code> on Mount</p>"},{"location":"techniques/response-model/","title":"Response Models","text":"<p>Each route handler has key-value pair of status codes and a response model.  This response model holds information on the type of response to be returned.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Serializer, ControllerBase\n\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response=UserSchema)\n    def me(self):\n        return dict(username='Ellar', email='ellar@example.com')\n</code></pre> <p>During route response computation, the <code>me</code> route handler response will evaluate to a <code>JSONResponseModel</code> with <code>UserSchema</code> as content validation schema.</p> <p>The resulting route responses will be:</p> <pre><code>from ellar.common import Serializer\nfrom ellar.common.responses.models import JSONResponseModel\n\n\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n\nresponse = {200: JSONResponseModel(model_field_or_schema=UserSchema)}\n</code></pre> <p>For documentation purposes, we can apply some <code>description</code> to the returned response</p> <p><pre><code>@get(\"/me\", response=(UserSchema, 'User Schema Response'))\ndef me(self):\n    return dict(username='Ellar', email='ellar@example.com')\n</code></pre> This will be translated to:</p> <pre><code>response = {200: JSONResponseModel(model_field_or_schema=UserSchema, description='User Schema Response')}\n</code></pre> <p></p> <p>Info</p> <p>Each route handler has its own <code>ResponseModel</code> computation and validation. If there is no response definition, Ellar default the route handler model to <code>EmptyAPIResponseModel</code>.</p>"},{"location":"techniques/response-model/#override-response-type","title":"Override Response Type","text":"<p>When you use a <code>Response</code> class as response, a <code>ResponseModel</code> is used and the <code>response_type</code> is replaced with applied response class.</p> <p>For example:</p> <p><pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, ControllerBase,PlainTextResponse, Serializer\n\n\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response={200: PlainTextResponse, 201: UserSchema})\n    def me(self):\n        return \"some text response.\"\n</code></pre> This will be translated to:</p> <pre><code>from ellar.common.responses.models import ResponseModel, JSONResponseModel\nfrom ellar.common import PlainTextResponse\n\nresponse = {200: ResponseModel(response_type=PlainTextResponse), 201: JSONResponseModel(model_field_or_schema=UserSchema)}\n</code></pre>"},{"location":"techniques/response-model/#response-model-properties","title":"Response Model Properties","text":"<p>All response model follows <code>IResponseModel</code> contract.</p> <p><pre><code>import typing as t\n\nfrom ellar.pydantic.fields import ModelField\nfrom ellar.common import IExecutionContext, Response\n\n\nclass IResponseModel:\n    media_type: str\n    description: str\n    get_model_field: t.Callable[..., t.Optional[t.Union[ModelField, t.Any]]]\n    create_response: t.Callable[[IExecutionContext, t.Any], Response]\n</code></pre> Properties Overview:</p> <ul> <li><code>media_type</code>: Read from response media type. Required</li> <li><code>description</code>: For documentation purpose. Default: <code>Success Response</code>. Optional</li> <li><code>get_model_field</code>: returns response schema if any. Optional</li> <li><code>create_response</code>: returns a response for the client. Optional</li> </ul> <p>There is also a <code>BaseResponseModel</code> concrete class for more generic implementation. And its adds extra properties for configuration purposes.</p> <p>They include:</p> <ul> <li><code>response_type</code>: Response classes eg. JSONResponse, PlainResponse, HTMLResponse. etc. Default: <code>Response</code>. Required</li> <li><code>model_field_or_schema</code>: <code>Optional</code> property. For return data validation. Default: <code>None</code> Optional</li> </ul>"},{"location":"techniques/response-model/#different-response-models","title":"Different Response Models","text":"<p>Let's see different <code>ResponseModel</code> available in Ellar and how you can create one too.</p>"},{"location":"techniques/response-model/#responsemodel","title":"ResponseModel","text":"<p>Response model that manages rendering of other response types.</p> <ul> <li>Location: <code>ellar.common.responses.models.ResponseModel</code></li> <li>response_type: <code>Response</code></li> <li>model_field_or_schema: <code>None</code></li> <li>media_type: <code>text/plain</code></li> </ul>"},{"location":"techniques/response-model/#jsonresponsemodel","title":"JSONResponseModel","text":"<p>Response model that manages <code>JSON</code> response.</p> <ul> <li>Location: <code>ellar.common.responses.models.json.JSONResponseModel</code></li> <li>response_type: <code>JSONResponse</code> OR <code>config.DEFAULT_JSON_CLASS</code></li> <li>model_field_or_schema: <code>Required</code></li> <li>media_type: <code>application/json</code></li> </ul>"},{"location":"techniques/response-model/#htmlresponsemodel","title":"HTMLResponseModel","text":"<p>Response model that manages <code>HTML</code> templating response. see <code>@render</code> decorator.</p> <ul> <li>Location: <code>ellar.common.responses.models.html.HTMLResponseModel</code></li> <li>response_type: <code>TemplateResponse</code></li> <li>model_field_or_schema: <code>None</code></li> <li>media_type: <code>text/html</code></li> </ul>"},{"location":"techniques/response-model/#fileresponsemodel","title":"FileResponseModel","text":"<p>Response model that manages <code>FILE</code> response. see <code>@file</code> decorator.</p> <ul> <li>Location: <code>ellar.common.responses.models.file.FileResponseModel</code></li> <li>response_type: <code>FileResponse</code></li> <li>model_field_or_schema: <code>ellar.common.responses.models.file.FileResponseModelSchema</code></li> <li>media_type: <code>Required</code></li> </ul>"},{"location":"techniques/response-model/#streamingresponsemodel","title":"StreamingResponseModel","text":"<p>Response model that manages <code>STREAMING</code> response. see <code>@file</code> decorator.</p> <ul> <li>Location: <code>ellar.common.responses.models.file.StreamingResponseModel</code></li> <li>response_type: <code>StreamingResponse</code></li> <li>model_field_or_schema: <code>ellar.common.responses.models.file.StreamResponseModelSchema</code></li> <li>media_type: <code>Required</code></li> </ul>"},{"location":"techniques/response-model/#emptyapiresponsemodel","title":"EmptyAPIResponseModel","text":"<p>Default <code>ResponseModel</code> applied when no response is defined.</p> <ul> <li>Location: <code>ellar.common.responses.models.json.EmptyAPIResponseModel</code></li> <li>response_type: <code>JSONResponse</code> OR <code>config.DEFAULT_JSON_CLASS</code></li> <li>model_field_or_schema: <code>dict</code></li> <li>media_type: <code>application/json</code></li> </ul>"},{"location":"techniques/response-model/#custom-response-model","title":"Custom Response Model","text":"<p>Lets create a new JSON response model.</p> <pre><code># project_name/apps/items/controllers.py\n\nimport typing as t\nfrom ellar.common import Controller, get, ControllerBase, JSONResponse, Serializer\nfrom ellar.common.responses.models import ResponseModel\n\n\nclass NoteSchema(Serializer):\n    id: t.Union[int, None]\n    text: str\n    completed: bool\n\n\nclass JsonApiResponse(JSONResponse):\n    media_type = \"application/vnd.api+json\"\n\n\nclass JsonApiResponseModel(ResponseModel):\n    response_type = JsonApiResponse\n    model_field_or_schema = t.List[NoteSchema]\n    default_description = 'Successful JsonAPI Response'\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/notes/\", response=JsonApiResponseModel())\n    def get_notes(self):\n        return [\n            dict(id=1, text='My Json Api Response 1', completed=True),\n            dict(id=2, text='My Json Api Response 2', completed=True),\n        ]\n</code></pre> <p></p>"},{"location":"techniques/serializers/","title":"Serializers","text":"<p>The <code>Serializer</code> class in the Ellar, is a custom class based on <code>pydantic</code> models, which provides additional functionality specific to Ellar's requirements.</p> <p>To use <code>Serializer</code> in Ellar, you simply need to create a class that inherits from <code>Serializer</code> and define your data model using pydantic fields.  Here's an example of how you could define a serializer class for a user model:</p> <pre><code>from ellar.common import Serializer\n\nclass UserSerializer(Serializer):\n    name: str\n    email: str\n    age: int\n</code></pre> <p>With this setup, you can use the <code>UserSerializer</code> class to validate incoming data and or serialize outgoing response data,  ensuring that it matches the expected format before saving it to the database or returning it to the client.</p>"},{"location":"techniques/serializers/#handling-responses","title":"Handling Responses","text":"<p>Let's see how we can use Serializer as a responses schema which will help us validate out data output and also provide documentation on route function response.</p> <p>The response schema is defined on the HTTP method decorator.</p> <p>For example: <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Serializer, ControllerBase\n\n# Define a User class with username, email, first_name, and last_name attributes\nclass User:\n    def __init__(self, username: str, email:str=None, first_name:str=None, last_name:str=None) -&gt; None:\n        self.username = username\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.is_authenticated = False\n\n    @property\n    def full_name(self) -&gt; str:\n        assert self.first_name and self.last_name\n        return f'{self.first_name} {self.last_name}'\n\n# Define a Serializer class to validate response data\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n# Create a fake user object\ncurrent_user = User(username='ellar', email='ellar@example.com', first_name='ellar', last_name='asgi')    \n\n# Define an endpoint that returns the fake user's information\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response=UserSchema)\n    def me(self):\n        return current_user\n</code></pre> This code sets up a User model and a <code>UserSerializer</code> class based on the <code>Serializer</code> class.  The User model represents a user with a <code>username</code>, <code>email</code>, <code>first_name</code>, and <code>last_name</code>.  The <code>UserSerializer</code> class is used to define the expected format of the response data in the <code>/me</code> endpoint.</p> <p>When the <code>/me</code> endpoint is called, it returns the <code>current_user</code> object as the response.  The <code>UserSerializer</code> is then used to parse and validate the <code>current_user</code> object, converting it into a dictionary representation  that can be easily serialized to JSON.  The resulting dictionary is then passed to the <code>JSONResponseModel</code> for serialization to a  JSON string and sending the response to the client.</p>"},{"location":"techniques/serializers/#multiple-response-types","title":"Multiple Response Types","text":"<p>The <code>response</code> parameter takes different shape. Let's see how to return a different response if the user is not authenticated.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, ControllerBase, Serializer\n\nclass User:\n    def __init__(self, username: str, email:str=None, first_name:str=None, last_name:str=None) -&gt; None:\n        self.username = username\n        self.email = email\n        self.first_name = first_name\n        self.last_name = last_name\n        self.is_authenticated = False\n\n    @property\n    def full_name(self) -&gt; str:\n        assert self.first_name and self.last_name\n        return f'{self.first_name} {self.last_name}'\n\n\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n\nclass MessageSchema(Serializer):\n    message: str\n\n\ncurrent_user = User(username='ellar', email='ellar@example.com', first_name='ellar', last_name='asgi')    \n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response={200: UserSchema, 403: MessageSchema})\n    def me(self):\n        if not current_user.is_authenticated:\n            return 403, {\"message\": \"Please sign in first\"}\n        return current_user\n\n    @get(\"/login\", response=MessageSchema)\n    def login(self):\n        if current_user.is_authenticated:\n            return dict(message=f'{current_user.full_name} already logged in.') \n\n        current_user.is_authenticated = True\n        return MessageSchema(\n            message=f'{current_user.full_name} logged in successfully.'\n        ) \n        # the same as returning dict(message=f'{current_user.full_name} logged in successfully.')\n</code></pre> <p>Here, the <code>response</code> parameter takes a KeyValuePair of the <code>status</code> and response <code>Schema</code>.</p> <p>Info</p> <p>Note that we returned a tuple of status code and response data (<code>403, {\"message\": \"Please sign in first\"}</code>) to specify the response validation to use.</p>"},{"location":"techniques/serializers/#using-response-typeobject-as-response","title":"Using Response Type/Object As Response","text":"<p>You can use <code>Response</code> type to change the format of data returned from endpoint functions.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, ControllerBase, PlainTextResponse\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response=PlainTextResponse)\n    def me(self):\n        return \"some text response.\"\n</code></pre> <p>Also, we can return response object from endpoint functions, and it will override initial <code>response</code> declared before.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Serializer, ControllerBase, PlainTextResponse\n\nclass UserSchema(Serializer):\n    username: str\n    email: str = None\n    first_name: str = None\n    last_name: str = None\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/me\", response=UserSchema)\n    def me(self):\n        return PlainTextResponse(\"some text response.\", status_code=200)\n</code></pre>"},{"location":"techniques/staticfiles/","title":"Static Files","text":"<p>A static file is a type of file that does not change often and is not generated by a server-side script. Examples of static files include images, CSS and JavaScript files, audio and video files, and other types of media.</p> <p>Static files in Ellar are served using the <code>StaticFiles</code> ASGI class, which is an extension of the Starlette <code>StaticFiles</code> ASGI class.  This class uses the static files specified in the application's modules and configuration.</p> <p>In addition, Ellar creates a route that mounts the static server at the <code>/static</code> path.  The path can be modified by providing a new value for the <code>STATIC_MOUNT_PATH</code> configuration variable.</p>"},{"location":"techniques/staticfiles/#configuring-static-files","title":"Configuring static files","text":"<ol> <li> <p>In your config file, define <code>STATIC_MOUNT_PATH</code>, for example:     <pre><code>class Config:\n    STATIC_MOUNT_PATH = '/static'\n</code></pre></p> </li> <li> <p>Store your static files in a folder called static in your module. For example my_module/static/my_module/example.jpg.</p> </li> <li>In your templates, use the <code>url_for</code> with <code>static</code> and <code>path</code> parameter to build the URL for the given relative path using the configured in <code>STATIC_DIRECTORIES</code>, <code>STATIC_FOLDER_PACKAGES</code> or Module.    <pre><code> &lt;img src=\"{{url_for('static', path='my_module/example.jpg')}}\" alt=\"My image\"&gt;\n</code></pre>    OR, visit <code>/static/my_app/example.jpg</code></li> </ol>"},{"location":"techniques/staticfiles/#static-file-in-modules","title":"Static File in Modules","text":"<p>Managing multiple sets of static files in larger projects can be challenging,  but by organizing each set of static files within a specific module,  it becomes easier to manage and maintain.  This approach allows for clear organization and separation of static assets,  making it more manageable in a large project.</p> <p>In our previous project, within the <code>car</code> module folder, we can create a following directories, <code>my_static/car</code>.  Inside this folder <code>my_static/car</code>, we can create a file named <code>example.txt</code>.  This allows us to keep all the static files related to the car module organized in one location <code>my_static</code>.</p> <p>Next, we tell <code>CarModule</code> about our static folder.</p> <pre><code># project_name/apps/car/module.py\n\nfrom ellar.common import Module\nfrom ellar.core import ModuleBase\nfrom ellar.di import Container\n\nfrom .controllers import CarController\n\n\n@Module(\n    controllers=[CarController], static_folder='my_static'\n)\nclass CarModule(ModuleBase):\n    def register_providers(self, container: Container) -&gt; None:\n        # for more complicated provider registrations\n        # container.register_instance(...)\n        pass\n</code></pre>"},{"location":"techniques/staticfiles/#other-static-configurations","title":"Other Static Configurations","text":"<p>In addition to setting static directories within modules,  it is also possible to manually specify additional static directories that are not located within a module by using the  <code>STATIC_FOLDER_PACKAGES</code> and <code>STATIC_DIRECTORIES</code> variables in the application's configuration.  These variables allow for even more flexibility in organizing and managing static files in a project.  These directories will be served by the StaticFiles ASGI class along with the module-scoped static files.</p>"},{"location":"techniques/staticfiles/#static_directories","title":"<code>STATIC_DIRECTORIES</code>","text":"<p><code>STATIC_DIRECTORIES</code> variable is a list of directories within the project that contain static files.  These directories are not necessarily scoped to a specific module and can be used to serve static files from any location within the project.  These directories can be added to the <code>STATIC_DIRECTORIES</code> list in the application's configuration.</p> <pre><code>STATIC_DIRECTORIES =  ['project_name/static-files', 'project_name/path/to/static/files']\n</code></pre>"},{"location":"techniques/staticfiles/#static_folder_packages","title":"<code>STATIC_FOLDER_PACKAGES</code>","text":"<p><code>STATIC_FOLDER_PACKAGES</code> variable is a list of tuples that contain python packages that hold some static files.  These packages should have a <code>static</code> folder and the package name should be passed as tuple <code>(package_name, package_path)</code>,  package_path is the relative path of static folder.</p> <pre><code>STATIC_FOLDER_PACKAGES =  [('bootstrap', 'statics'), ('package-name', 'path/to/static/directory')]\n</code></pre> <p>Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.  In <code>HTML</code> mode if <code>404.html</code> file exists it will be shown as 404 response.</p>"},{"location":"techniques/staticfiles/#mounting-other-files","title":"Mounting other files","text":"<p>Ellar offers <code>ASGIFileMount</code> to easily mount files on your application outside of static files.</p> <pre><code>import ellar.common as ec\n\nfrom ellar.core.middleware import as_middleware\nfrom ellar.core.routing import ASGIFileMount\n\n\n@as_middleware\nasync def asgi_middleware(context, call_next):\n    \"\"\"Run some actions\"\"\"\n    await call_next()\n\n\n@ec.Module(routers=[\n   ASGIFileMount(\n       directories=[\"private\"],\n       path=\"/media\",\n       name=\"media\",\n       base_directory='base/path/to/locate/directories',\n       middleware=[\n           asgi_middleware\n       ],\n   )\n])\nclass ModuleSample:\n    pass\n</code></pre> <p>In the provided example, the <code>private</code> directory is mounted using <code>ASGIFileMount</code> under the <code>/media</code> endpoint. Accessing a file, e.g., <code>http://127.0.0.1:8000/media/my-file.txt</code>, will retrieve and display <code>my-file.txt</code> in the browser.  Additionally, there is a middleware configuration option in case if your requirement requires it.</p>"},{"location":"techniques/templating/","title":"HTML Templating with Jinja","text":"<p>Jinja2 is a powerful template engine for Python. It can be used in web applications to separate static and dynamic content,  making it easier to maintain and update the dynamic content. </p> <p>In Ellar, a Model-View-Controller (MVC) framework, Jinja2 templates are typically used in the View layer to render dynamic content,  while the Model and Controller layers handle the data and logic of the application.</p>"},{"location":"techniques/templating/#installation","title":"Installation","text":"<p><code>Jinja2</code> package is installed alongside with Ellar.</p>"},{"location":"techniques/templating/#quick-overview-on-jinja2-usage","title":"Quick overview on jinja2 Usage","text":"<p>A Jinja2 template is a plain text file that contains dynamic content, represented using Jinja2 syntax.  Here's an example template that displays a list of items:</p> <p><pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;ul&gt;\n      {% for item in items %}\n      &lt;li&gt;{{ item }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> The <code>{% for item in items %}</code> and <code>{% endfor %</code>} tags define a loop that iterates over the items list and displays each item as a list item.  The <code>{{ item }}</code> tag inserts the value of the <code>item</code> variable into the template.</p> <p>To render the template, you'll need to use the Jinja2 API in your view function. Here's an example of how you might do this:</p> <pre><code># main.py\n\nimport uvicorn\nfrom jinja2 import Environment, FileSystemLoader\nfrom ellar.core import Request, AppFactory\nfrom ellar.common import ModuleRouter, HTMLResponse\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\nrouter = ModuleRouter('/template-testing')\n\n# Also create a templates folder at the main.py root dir. And add template.html into it\n\n@router.get()\ndef view_function(request: Request):\n    # Load the template file\n    env = Environment(loader=FileSystemLoader('templates'))\n    template = env.get_template('template.html')\n\n    # Render the template with some dynamic data\n    items = ['apple', 'banana', 'cherry']\n    rendered_template = template.render(items=items)\n\n    # Return the rendered template as the response\n    return HTMLResponse(rendered_template)\n\napp = AppFactory.create_app(routers=[router], template_folder='templates', base_directory=BASE_DIR)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n\n# visit: http://127.0.0.1:5000/template-testing/\n</code></pre> <p>This example loads the <code>template.html</code> file from the <code>templates</code> directory, renders it with the items list,  and returns the rendered template as the <code>HTTP</code> response to the request.</p> <p>This example also shows manual setup of using <code>jinja2</code> in Ellar.</p>"},{"location":"techniques/templating/#jinja2-usage-in-ellar","title":"Jinja2 usage in Ellar","text":"<p>In Ellar, the <code>@render</code> decorator transforms the route handler response into a Templated Response via an <code>HTMLResponseModel</code> with a status code of 200.  And the route handler is required to return a <code>dictionary</code> object which serves as the template's context.</p> <p>Additionally, each registered <code>Module</code> functions as a jinja2 <code>TemplateLoader</code> for loading templates, but only when a templates_folder is provided and exists.</p>"},{"location":"techniques/templating/#in-controller","title":"In Controller","text":"<p>In Controllers, the <code>@render</code> decorator uses the decorated function name + controller name to generate a path to the template when creating <code>HTMLResponseModel</code> to handle the response</p> <p>For example: <pre><code># main.py\nimport uvicorn\nfrom ellar.common import render, Controller, get\nfrom ellar.app import AppFactory\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\n\n\n@Controller()\nclass TemplateExampleController:\n    @get('/')\n    @render()\n    def index(self):\n        return {'name': 'Ellar Template'}\n\napp = AppFactory.create_app(controllers=[TemplateExampleController], template_folder='templates', base_directory=BASE_DIR)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n\n# visit: http://127.0.0.1:5000/templateexample/\n</code></pre></p> <p>In this example, the <code>@render</code> decorator will create an <code>HTMLResponseModel</code> with a template path = <code>templateexample/index.html</code>. When the <code>@render</code> decorator is applied to a <code>Controller</code> class, it assumes this pattern of resolving the template part. This behavior can be overridden by providing the <code>template_name</code> parameter on the <code>@render</code> decorator.</p> <p>For example: <pre><code># main.py\nimport uvicorn\nfrom ellar.common import render, Controller, get\nfrom ellar.app import AppFactory\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\n\n\n@Controller()\nclass TemplateExampleController:\n    @get('/')\n    @render(template_name='templateexample/list.html')\n    async def index(self):\n        return {'name': 'Ellar Template'}\n\napp = AppFactory.create_app(\n    controllers=[TemplateExampleController], \n    template_folder='templates', \n    base_directory=BASE_DIR\n)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n\n# visit: http://127.0.0.1:5000/templateexample\n</code></pre></p>"},{"location":"techniques/templating/#in-modulerouter","title":"In ModuleRouter","text":"<p>In <code>ModuleRouter</code>, <code>@render</code> decorators will enforce the <code>template_name</code> provision when creating <code>HTMLResponseModel</code>. Ellar does not assume the function name to be equivalent to the template name because it's a wide scope of guess.</p> <p>A quick example: <pre><code># main.py\n\nimport uvicorn\nfrom ellar.app import AppFactory\nfrom ellar.core import Request\nfrom ellar.common import ModuleRouter, render\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\nrouter = ModuleRouter('/template-testing')\n\n@router.get()\n@render('some-path/template-name.html')\nasync def index(request: Request):\n    return {'name': 'Ellar Template'}\n\n\napp = AppFactory.create_app(routers=[router], template_folder='templates', base_directory=BASE_DIR)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n</code></pre></p> <p>Info</p> <p><code>Jinja2</code> supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations. Instead, we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.' - <code>Starlette Recommendation</code></p>"},{"location":"techniques/templating/#jinja2-configurations","title":"Jinja2 Configurations","text":"<p>If there are specific configurations you want to apply to your Jinja2 Environment, you can look at JINJA_TEMPLATE_OPTIONS configuration.</p>"},{"location":"techniques/templating/#default-jinja-template-context","title":"Default Jinja Template Context","text":"<p>Every jinja template in ellar receives two context, <code>url_for</code>, <code>config</code>, <code>request</code> object and other specific context defined to render a template.</p> <ul> <li><code>url_for</code> is a utility function that helps to resolve path to files and url(reversing url)</li> <li><code>config</code> is current application configuration object.</li> <li><code>request</code> is current request object.</li> </ul>"},{"location":"techniques/templating/#static-files-in-template","title":"Static Files In Template","text":"<p>As stated above, you can resolve file paths to static files using <code>url_for</code>.</p> <p>For example: <pre><code>&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Welcome - Ellar ASGI Python Framework&lt;/title&gt;\n    &lt;link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"{{ url_for('static', path='img/Icon.svg') }}\"/&gt;\n    &lt;link rel=\"stylesheet\" href=\"{{ url_for('static', path='css/bootstrap.min.css') }}\"&gt;\n&lt;/head&gt;\n</code></pre></p> <p>The <code>url_for</code> takes <code>path</code> parameter, in the case of <code>static</code> files, to match the directory and filename to be resolved. This <code>url_for('static', path='img/Icon.svg')</code> will search for <code>img/Icon.svg</code> in all registered static folders.</p>"},{"location":"techniques/templating/#reversing-controllers-urls","title":"Reversing Controllers URLs","text":"<p>It is common to need to generate URLs for specific routes, particularly when returning a redirect response.  This can be achieved by using the <code>request.url_for</code> method in the request object, or in the case of templating, by using the <code>url_for()</code> function.</p> <p>The <code>request.url_for</code> method generates a URL based on the current request context, while in template <code>{{url_for()}}</code> function generates a URL based on the current routing configuration. Both of them will generate a URL for a specific route, allowing the server to redirect the client to the correct location.</p> <p>In controllers, urls are reversed by joining the controller_name and route handler name like so <code>controller_name:function_name</code>.</p> <p>For example:</p> <pre><code># main.py\nimport uvicorn\nfrom ellar.app import AppFactory\nfrom ellar.common import render, Controller, get\nfrom ellar.core import Request\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\n\n\n@Controller()\nclass TemplateExampleController:\n    @get('/')\n    @render()\n    async def index(self, request:Request):\n        assert request.url_for('templateexample:index') == 'http://127.0.0.1:5000/templateexample/'\n        return {'name': 'Ellar Template'}\n\n\napp = AppFactory.create_app(\n    controllers=[TemplateExampleController],\n    template_folder='templates', base_directory=BASE_DIR\n)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n</code></pre> <p>Then in <code>templates/templateexample/index.html</code> add the follow:</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;a href=\"{{url_for('templateexample:index')}}\"&gt;Index&lt;/a&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In the example mentioned, <code>controller_name</code> is combined with <code>function_name</code> to generate the url for the 'index' route.</p> <p>In the same example, URL parameters can also be passed as keyword arguments to the <code>url_for</code> function. For example:</p> <p><pre><code>url_for('templateexample:index', parameter_a='value1', parameter_b='value2')\n</code></pre> This would generate a URL that includes the values of <code>parameter_a</code> and <code>parameter_b</code> as URL parameters, like this :</p> <pre><code>example.com/index/value1/value2\n</code></pre> <p>For instance:</p> <pre><code>@get('/{parameter_a}/{parameter_b}')\n@render()\nasync def index(self, parameter_a:str, request:Request):\n    assert request.url_for('templateexample:index', parameter_a='ellar') == 'http://127.0.0.1:5000/templateexample/ellar'\n    return {'name': 'Ellar Template'}\n</code></pre> <p>In the example <code>request.url_for('templateexample:index', parameter_a='ellar')</code>,  we can see that the <code>parameter_a</code> is used as a keyword argument to satisfy the dependency on the <code>parameter_a</code> parameter in the URL being generated.</p> <p>Info</p> <p>If the <code>url_for</code> function is called with a path that does not exist or with insufficient parameters to resolve an existing URL,  it will raise a <code>starlette.routing.NoMatchFound</code> exception.</p>"},{"location":"techniques/templating/#reversing-module-router-urls","title":"Reversing Module Router URLs","text":"<p>Just like in controller, we can also reverse URLs that belongs to <code>ModuleRouter</code>. </p> <pre><code># main.py\nimport uvicorn\nfrom ellar.app import AppFactory\nfrom ellar.common import ModuleRouter\nfrom ellar.core import Request\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).parent\n\nrouter = ModuleRouter('/template-reversing', name='users')\n\n@router.get('/{user_id}')\ndef profile(user_id: str, request:Request):\n    profile_url = request.url_for('users:profile', user_id=user_id)\n    return profile_url\n\n\napp = AppFactory.create_app(\n    routers=[router],\n    template_folder='templates', base_directory=BASE_DIR\n)\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", port=5000, log_level=\"info\")\n</code></pre> <p>In the example you mentioned, by adding <code>name='users'</code> to the router, it provides a unique way to reverse the routing pattern for the router.  We can now use the name along with the route function name in the form of <code>{name}:{function_name}</code> to resolve the URL.  As you can see in <code>request.url_for('users:profile', user_id=user_id)</code> the 'users:profile' is the string passed to the <code>url_for</code> method.  This is using the name as \"users\" and the function name as \"profile\" to generate the url based on the routing configuration. The user_id parameter is passed as keyword argument which will be used to construct the URL based on the routing configuration, which should include a parameter for user_id</p> <p>However, If you don't provide a name on the router, you'll have to use only the function name to resolve the URL. For example, <code>request.url_for('profile', user_id=user_id)</code>. In this case, the routing configuration should have a route that match the function name 'profile' and have a parameter for <code>user_id</code> in the routing path.</p> <p>For example:</p> <pre><code>router = ModuleRouter('/template-reversing')\n\n@router.get('/{user_id}')\ndef profile(user_id: str, request:Request):\n    profile_url = request.url_for('profile', user_id=user_id)\n    return profile_url\n</code></pre> <p>It's worth noting that providing a unique name to a router is useful if you have multiple routes with the same function name, or to make the URL reversing more readable or meaningful.</p>"},{"location":"techniques/templating/#overriding-reversing-url-function-name","title":"Overriding Reversing URL Function Name","text":"<p>You can override the <code>function_name</code> part of reversing the URL by providing a <code>name</code> on the route method decorator. Each route method has an optional name parameter, which, when set, is used in place of the function name when reversing the URL. For example, you could have the following code:</p> <pre><code>router = ModuleRouter('/template-reversing', name='users')\n\n@router.get(\"/profile/{user_id}\", name=\"user_profile\")\nasync def profile(user_id: str, request:Request):\n    profile_url = request.url_for('users:user_profile', user_id=user_id)\n    return profile_url\n</code></pre> <p>In this case, when reversing the URL, you would use <code>request.url_for('users:user_profile', user_id=user_id)</code> which will generate <code>http://127.0.0.1:5000/template-reversing/profile/value_of_user_id</code> based on routing configuration.</p> <p>This allows for greater control and readability when reversing URLs, and makes it less prone to error if the function name of the route were to change in the future.</p>"},{"location":"techniques/templating/#adding-template-filters-and-template-globals","title":"Adding template filters and template globals.","text":"<p>Jinja template filter and global functions can be defined at module level as shown here: Module Templating Filters</p>"},{"location":"techniques/templating/#templating-context","title":"Templating Context","text":"<p>A context processor is a function that returns a dictionary, which is then merged into the template context.  Each function accepts only one argument, the request, and must return a dictionary to be added to the context.</p> <p>A common use of context processors is to extend the template context with shared variables.</p> <pre><code>import typing\nfrom starlette.requests import Request\n\ndef app_context(request: Request) -&gt; typing.Dict[str, typing.Any]:\n    return {'app': request.app}\n</code></pre>"},{"location":"techniques/templating/#registering-context-templates","title":"Registering context templates","text":"in config.pyin @Module() class <p>In the case of <code>app_context</code>, we can register it by adding to the <code>config.py</code> <code>TEMPLATES_CONTEXT_PROCESSORS</code></p> <p>for example:</p> <pre><code># project_name/config.py\n\nfrom ellar.core import ConfigDefaultTypesMixin\nfrom path/to/context import app_context\n\nclass DevelopmentConfig(ConfigDefaultTypesMixin):\n    TEMPLATES_CONTEXT_PROCESSORS: t.List[t.Callable[[t.Union[Request, HTTPConnection]], t.Dict[str, t.Any]]] = [\n        \"ellar.core.templating.context_processors:request_context\",\n        \"ellar.core.templating.context_processors:user\",\n        \"ellar.core.templating.context_processors:request_state\",\n        app_context\n        ## OR\n        \"path/to/context:app_context\"\n    ]\n</code></pre> <p>@Module() classes can define template contexts  that will be automatically registered to config.TEMPLATES_CONTEXT_PROCESSORS at runtime</p> <p>for example:</p> <pre><code># project_name/root_module.py\nfrom ellar.common import Module, template_context\nfrom ellar.core import Request\n\n\n@Module()\nclass ApplicationModule:\n    @template_context()\n    def app_context(self, request: Request):\n        return {'app': request.app}\n</code></pre>"},{"location":"techniques/versioning/","title":"Versioning","text":"<p>Versioning is a practice in software development that involves managing different versions of endpoints (APIs) within an application.  This is crucial when introducing changes to an API that may impact existing clients or when supporting multiple versions concurrently.  Different versioning strategies are employed to handle these scenarios:</p> <ul> <li><code>URL Versioning</code>: The version is included in the URL of the request.</li> <li><code>Header Versioning</code>: The version is specified using a custom request header.</li> <li><code>Query Versioning</code>: The version is specified in a custom request query.</li> <li><code>Host Versioning</code>: The version is part of the request client host.</li> <li></li> </ul>"},{"location":"techniques/versioning/#url-versioning","title":"URL Versioning","text":"<p>This scheme requires the client to specify the version as part of the URL path. <pre><code>GET /v1/receipes/ HTTP/1.1\nHost: example.com\nAccept: application/json\n</code></pre></p> <p>To enable URL Versioning for your application, do the following: <pre><code># project_name/server.py\nimport os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom ellar.core.versioning import VersioningSchemes\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"dialerai.config:DevelopmentConfig\"\n    ),\n    global_guards=[]\n)\napplication.enable_versioning(VersioningSchemes.URL, version_parameter='v', default_version=None)\n</code></pre> The URL path will be parsed with the provided <code>version_parameter</code>, <code>v</code>, to determine specified version.  For example, <code>https://example.com/v1/route</code>, will resolve to <code>version='1'</code> and <code>https://example.com/v3/route</code>, will resolve to <code>version='3'</code>.</p> <p>If version is not specified in the URL, the <code>default_version</code> will be used. Which in this case is <code>None</code>. </p>"},{"location":"techniques/versioning/#header-versioning","title":"Header Versioning","text":"<p>This scheme requires the client to specify the version as part of the media type in the <code>Accept</code> header.  The version is included as a media type parameter, that supplements the main media type.</p> <p>Here's an example HTTP request using accept header versioning style. <pre><code>GET /receipes/ HTTP/1.1\nHost: example.com\nAccept: application/json; version=1\n</code></pre></p> <p>To enable Header Versioning for your application, do the following: <pre><code># project_name/server.py\nimport os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom ellar.core.versioning import VersioningSchemes\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"dialerai.config:DevelopmentConfig\"\n    ),\n    global_guards=[]\n)\napplication.enable_versioning(\n    VersioningSchemes.HEADER, \n    header_parameter='accept', \n    version_parameter='version', \n    default_version=None\n)\n</code></pre> During request handling, request header <code>accept</code> value will be parsed to read the version value. A header <code>accept: application/json; version=2</code> will resolve to <code>version='2'</code></p>"},{"location":"techniques/versioning/#using-custom-header","title":"Using Custom Header","text":"<p>We can also use a custom header asides <code>accept</code>. for example: <pre><code>GET /receipes/ HTTP/1.1\nHost: example.com\nX-Custom-Header: version=2\n</code></pre></p> <p>And then we enable it with the code below: <pre><code># project_name/server.py\n...\napplication.enable_versioning(\n    VersioningSchemes.HEADER, \n    header_parameter='x-custom-header', \n    version_parameter='version_header', \n    default_version=None\n)\n</code></pre> The header property, <code>x-custom-header</code>, will be the name of the header that will contain the version of the request.  And the value follow the format <code>[version_parameter]=version-number;</code>, for example: <code>headers={'x-custom-header': 'version_header=3'}</code> will resolve to <code>version='3'</code>.</p>"},{"location":"techniques/versioning/#query-versioning","title":"Query Versioning","text":"<p>This scheme is a simple style that includes the version as a query parameter in the URL. For example: <pre><code>GET /receipes?version=2 HTTP/1.1\nHost: example.com\nAccept: application/json\n</code></pre></p> <p>To enable Query Versioning for your application, do the following: <pre><code># project_name/server.py\nimport os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom ellar.core.versioning import VersioningSchemes\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"dialerai.config:DevelopmentConfig\"\n    ),\n    global_guards=[]\n)\napplication.enable_versioning(\n    VersioningSchemes.QUERY, \n    version_parameter='version', \n    default_version=None\n)\n</code></pre></p>"},{"location":"techniques/versioning/#host-versioning","title":"Host Versioning","text":"<p>The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.</p> <p>For example the following is an HTTP request to the <code>http://v1.example.com/receipes/</code> URL: <pre><code>GET /receipes/ HTTP/1.1\nHost: v1.example.com\nAccept: application/json\n</code></pre></p> <p>To enable Host Versioning for your application, do the following: <pre><code># project_name/server.py\nimport os\nfrom ellar.common.constants import ELLAR_CONFIG_MODULE\nfrom ellar.core.factory import AppFactory\nfrom ellar.core.versioning import VersioningSchemes\nfrom .root_module import ApplicationModule\n\napplication = AppFactory.create_from_app_module(\n    ApplicationModule,\n    config_module=os.environ.get(\n        ELLAR_CONFIG_MODULE, \"dialerai.config:DevelopmentConfig\"\n    ),\n    global_guards=[]\n)\napplication.enable_versioning(\n    VersioningSchemes.HOST, \n    version_parameter='v', \n    default_version=None\n)\n</code></pre> By default, this implementation expects the hostname to match this simple regular expression: <pre><code>^([a-zA-Z0-9]+)\\.[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$\n</code></pre></p> <p>Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.</p> <p>The <code>HostNameVersioning</code> scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as 127.0.0.1.  There are various online tutorials on how to access localhost with a custom subdomain which you may find helpful in this case.</p> <p>Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.</p>"},{"location":"techniques/versioning/#controller-versions","title":"Controller Versions","text":"<p>A version can be applied to a controller by using <code>Version</code> decorator from <code>ellar.common</code> package.</p> <p>To add a version to a controller do the following: <pre><code>from ellar.common import Controller, Version\n\n@Controller('/example')\n@Version('1')\nclass ExampleControllerV1:\n    pass\n</code></pre></p>"},{"location":"techniques/versioning/#route-versions","title":"Route Versions","text":"<p>A version can be applied to an individual route. This version will override any other version that would effect the route, such as the Controller Version.</p> <p>To add a version to an individual route do the following:</p> <pre><code>from ellar.common import Controller, Version, get\n\n@Controller('/example')\nclass ExampleController:\n    @Version('1')\n    @get('/items')\n    async def get_items_v1(self):\n        return 'This action returns all items for version 1'\n\n    @get('/items')\n    @Version('2')\n    async def get_items_v2(self):\n        return 'This action returns all items for version 2'\n</code></pre>"},{"location":"techniques/versioning/#multiple-versions","title":"Multiple Versions","text":"<p>Multiple versions can be applied to a controller or route. To use multiple versions, you would set the version to be an Array.</p> <p>To add multiple versions do the following: <pre><code>from ellar.common import Controller, Version, get\n\n@Controller('/example')\n@Version('1', '2')\nclass ExampleControllerV1AndV2:\n    @get('/items')\n    async def get_items(self):\n        return 'This action returns all items for version 1 &amp; 2'\n</code></pre></p>"},{"location":"techniques/validations/","title":"Input Validation Tutorial","text":"<p>In this section, we are going to learn how inputs are parsed in the Ellar route handle functions.</p> <p>To get started, we need to create another module for this tutorial.</p> <p>Open the terminal, navigate to the root level of the project and run the command that scaffolds a new module to your project.</p> <pre><code>$(venv) ellar create-module items\n</code></pre> <p>Next, goto <code>project_name/root_module.py</code> and add <code>ItemsModule</code> to list of modules.</p> <pre><code>from ellar.common import Module, exception_handler, IExecutionContext, JSONResponse, Response\nfrom ellar.core import ModuleBase\nfrom ellar.samples.modules import HomeModule\nfrom .apps.car.module import CarModule\nfrom .apps.items.module import ItemsModule\n\n\n@Module(modules=[HomeModule, CarModule, ItemsModule])\nclass ApplicationModule(ModuleBase):\n    @exception_handler(404)\n    def exception_404_handler(cls, ctx: IExecutionContext, exc: Exception) -&gt; Response:\n        return JSONResponse(dict(detail=\"Resource not found.\"))\n</code></pre> <p>With the server running: <pre><code>$(venv) ellar runserver --reload\n</code></pre></p> <p>visit http://localhost:8000/items/,</p> <pre><code>{\n  \"detail\": \"Welcome Items Resource\"\n}\n</code></pre> <p>All code example will be done on the <code>ItemController</code> in <code>project_name/apps/items/controllers.py</code>.  Please keep it open.</p>"},{"location":"techniques/validations/#tutorial","title":"Tutorial","text":"<p>You are going to learn how to use the following route handler parameter:</p> <ul> <li>Path</li> <li>Query</li> <li>Header</li> <li>Cookie</li> <li>Body</li> <li>Form</li> <li>File</li> </ul>"},{"location":"techniques/validations/body/","title":"Request Body","text":"<p>Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created.</p> <p>To declare a request body, you need to use Ellar <code>Serializer</code>.</p> <p>Info</p> <p>Under the hood Ellar uses Pydantic models with all their power and benefits.</p>"},{"location":"techniques/validations/body/#import-serializer","title":"Import Serializer","text":"<p>First, you need to import <code>Serializer</code> from <code>ella.serializer</code>:</p> <pre><code># project_name/apps/items/controllers.py\nfrom ellar.common import Serializer\n\n# class Item(Serializer):\n#     name: str\n#     description: str = None\n#     price: float\n#     quantity: int\n</code></pre>"},{"location":"techniques/validations/body/#create-your-data-model","title":"Create your data model","text":"<p>Then you declare your data model as a class that inherits from <code>Serializer</code>.</p> <p>Use standard Python types for all the attributes:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, ControllerBase, Controller, post\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n</code></pre> <p>Note: if you use <code>None</code> as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \"<code>object</code>\" (or Python <code>dict</code>) like:</p> <pre><code>{\n    \"name\": \"Alexis\",\n    \"description\": \"An optional description\",\n    \"price\": 400.00,\n    \"quantity\": 6\n}\n</code></pre> <p>...as <code>description</code> is optional (with a default value of <code>None</code>), this JSON \"<code>object</code>\" would also be valid:</p> <pre><code>{\n    \"name\": \"Alexis\",\n    \"price\": 200.00,\n    \"quantity\": 12\n}\n</code></pre>"},{"location":"techniques/validations/body/#declare-it-as-a-parameter","title":"Declare it as a parameter","text":"<p>To add it to your path operation, declare it the same way you declared the path and query parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, post, ControllerBase\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n</code></pre> <p>... and declare its type as the model you created, <code>Item</code>.</p>"},{"location":"techniques/validations/body/#results","title":"Results","text":"<p>With just that Python type declaration, Ellar will:</p> <ul> <li>Read the body of the request as JSON.</li> <li>Convert the corresponding types (if needed).</li> <li>Validate the data.<ul> <li>If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was.</li> </ul> </li> <li>Give you the received data in the parameter <code>item</code>.<ul> <li>Because you declared it in the function to be of type <code>Item</code>, you will also have all the editor support   (completion, etc.) for all the attributes and their types.</li> </ul> </li> <li>Generate JSON Schema definitions for   your models, and you can also use them anywhere else you like if it makes sense for your project.</li> <li>Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's.</li> </ul>"},{"location":"techniques/validations/body/#automatic-docs","title":"Automatic Docs","text":"<p>The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:</p> <p></p> <p>... and they will be also used in the API docs inside each path operation that needs them:</p> <p></p>"},{"location":"techniques/validations/body/#request-body-path-parameters","title":"Request Body + Path parameters","text":"<p>You can declare path parameters and body requests at the same time.</p> <p>Ellar will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared with <code>Serializer</code> should be taken from the request body.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, post, put, ControllerBase\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n\n    @put(\"/items/{item_id}\")\n    def update(self, item_id: int, item: Item):\n        return {\"item_id\": item_id, \"item\": item.dict()}\n</code></pre>"},{"location":"techniques/validations/body/#request-body-path-query-parameters","title":"Request Body + Path + Query parameters","text":"<p>You can also declare body, path and query parameters, all at the same time.</p> <p>Ellar will recognize each of them and take the data from the correct place.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, post, put, ControllerBase\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n\n    @put(\"/{item_id}\")\n    def update(self, item_id: int, item: Item, q: str):\n        return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n</code></pre> <p>The function parameters will be recognized as follows:</p> <ul> <li>If the parameter is also declared in the path, it will be used as a path parameter.</li> <li>If the parameter is of a singular type (like <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, etc.), it will be interpreted as a query parameter.</li> <li>If the parameter is declared to be of the type of Serializer (or Pydantic <code>BaseModel</code>), it will be interpreted as a request body.</li> </ul> <p>Info</p> <p>In here, we have combined both <code>Serializers</code> and <code>Controllers</code> in one file. This is for the convenience of writing this documentation. It's advised to have all your serializers in <code>schemas.py</code> and then import them over to <code>controllers.py</code> if needed.</p>"},{"location":"techniques/validations/body/#singular-values-in-body","title":"Singular values in body","text":"<p>The same way there is a <code>Query</code> and <code>Path</code> to define extra data for query and path parameters,  Ellar provides an equivalent <code>Body</code>.</p> <p>For example, extending the previous model, you could decide that you want to have another key <code>importance</code> in the same body, besides the <code>item</code> and <code>user</code>.</p> <p>If you declare it as is, because it is a singular value, Ellar will assume that it is a query parameter.</p> <p>But you can instruct Ellar to treat it as another body key using Body:</p> <p><pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, Body, post, put, ControllerBase\nfrom pydantic import BaseModel\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\nclass User(BaseModel):\n    username: str\n    full_name: str\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n\n    @put(\"/{item_id}\")\n    def update(self, item_id: int, item: Item, q: str):\n        return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n\n    @put(\"/{item_id}/another\")\n    async def update_another(self, item_id: int, item: Item, user: User, importance: int = Body()):\n        results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"importance\": importance}\n        return results\n</code></pre> In this case, Ellar will expect a body like:</p> <pre><code>{\n    \"item\": {\n        \"name\": \"Foo\",\n        \"description\": \"The pretender\",\n        \"price\": 42.0,\n        \"tax\": 3.2\n    },\n    \"user\": {\n        \"username\": \"dave\",\n        \"full_name\": \"Dave Grohl\"\n    },\n    \"importance\": 5\n}\n</code></pre>"},{"location":"techniques/validations/body/#multiple-body-params-and-query","title":"Multiple body params and query","text":"<p>Of course, you can also declare additional <code>query</code> parameters whenever you need, additional to anybody parameters.</p> <p>As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a <code>Query</code>, you can just do:</p> <p>For example:</p> <p><pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, Body, post, put, ControllerBase\nfrom pydantic import BaseModel\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\nclass User(BaseModel):\n    username: str\n    full_name: str\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item):\n        return item\n\n    @put(\"/{item_id}\")\n    def update(self, item_id: int, item: Item, q: str):\n        return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n\n    @put(\"/{item_id}/another\")\n    async def update_another(self, item_id: int, item: Item, user: User, importance: Body[int], q: str = None):\n        results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"importance\": importance, \"q\": q}\n        return results\n</code></pre> And you will have this:</p> <p></p> <p>Info</p> <p><code>Body</code> also has all the same extra validation and metadata parameters as <code>Query</code>,<code>Path</code> and others you will see later.</p>"},{"location":"techniques/validations/cookie-params/","title":"Cookie Parameters","text":"<p>You can define Cookie parameters the same way you define <code>Path</code> parameters.</p>"},{"location":"techniques/validations/cookie-params/#import-cookie","title":"Import <code>Cookie</code>","text":"<p>First import <code>Cookie</code> from <code>ellar.common</code> module</p>"},{"location":"techniques/validations/cookie-params/#declare-cookie-parameters","title":"Declare <code>Cookie</code> parameters","text":"<p>Then declare the cookie parameters using the same structure as with <code>Path</code> and <code>Query</code>.</p> <p>The first value is the default value, you can pass all the extra validation or annotation parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom typing import Optional\nfrom ellar.common import get, Controller, Cookie, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/\")\n    async def read_items(self, ads_id: Optional[str] = Cookie(default=None)):\n        return {\"ads_id\": ads_id}\n</code></pre> <p>Info</p> <p>To declare cookies, you need to use <code>Cookie</code>, because otherwise the parameters would be interpreted as <code>query</code> parameters.</p>"},{"location":"techniques/validations/cookie-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate <code>Cookies</code> parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, get, Controller, Cookie, ControllerBase\n\n\n\nclass CookieSchema(Serializer):\n    cookieItem1: int = 100\n    cookieItem2: str = None\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/cookie-as-schema')\n    def cookie_as_schema(self, cookie_values: Cookie[CookieSchema]):\n        return {\"cookie_values\": cookie_values.dict()}\n</code></pre>"},{"location":"techniques/validations/file-params/","title":"File Uploads","text":"<p>Handling files are no different from other parameters. You can define files to be uploaded by using <code>File</code>.</p> <p>Info</p> <p>To receive uploaded files, first install <code>python-multipart</code>.</p> <p>E.g. <code>pip install python-multipart</code>.</p> <p>This is because uploaded files are sent as \"form data\".</p>"},{"location":"techniques/validations/file-params/#import-file","title":"Import <code>File</code>","text":"<p>First import <code>File</code> from <code>ellar.common</code> module</p>"},{"location":"techniques/validations/file-params/#define-file-parameters","title":"Define <code>File</code> parameters","text":"<p>Create file parameters the same way you would for <code>Body</code> or <code>Form</code>:</p> <pre><code># project_name/apps/items/controllers.py\nfrom ellar.common import File, Controller, post, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/files/\")\n    async def create_file(self, file: File[bytes]):\n        return {\"file_size\": len(file)}\n</code></pre> <p>The files will be uploaded as \"form data\".</p> <p>If you declare the type of your path operation function parameter as <code>bytes</code>, Ellar will read the file for you and you will receive the contents as <code>bytes</code>.</p> <p>Have in mind that this means that the whole contents will be stored in memory. This will work well for small files.</p> <p>But there are several cases in which you might benefit from using <code>UploadFile</code>.</p>"},{"location":"techniques/validations/file-params/#file-parameters-with-uploadfile","title":"<code>File</code> parameters with <code>UploadFile</code>","text":"<p>Define a <code>File</code> parameter with a type of <code>UploadFile</code>:</p> <pre><code># project_name/apps/items/controllers.py\nfrom ellar.common import File, UploadFile, Controller, post, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/files/\")\n    async def create_file(self, file: File[bytes]):\n        return {\"file_size\": len(file)}\n\n\n    @post(\"/uploadfile/\")\n    async def create_upload_file(self, file: File[UploadFile]):\n        return {\"filename\": file.filename}\n</code></pre> <p>Using <code>UploadFile</code> has several advantages over <code>bytes</code>:</p> <ul> <li>It uses a \"spooled\" file:<ul> <li>A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.</li> </ul> </li> <li>This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.</li> <li>You can get metadata from the uploaded file.</li> <li>It has a file-like <code>async</code> interface.</li> <li>It exposes an actual Python <code>SpooledTemporaryFile</code> object that you can pass directly to other libraries that expect a file-like object.</li> </ul>"},{"location":"techniques/validations/file-params/#uploadfile","title":"<code>UploadFile</code>","text":"<p><code>UploadFile</code> has the following attributes:</p> <ul> <li><code>filename</code>: A <code>str</code> with the original file name that was uploaded (e.g. <code>myimage.jpg</code>).</li> <li><code>content_type</code>: A <code>str</code> with the content type (MIME type / media type) (e.g. <code>image/jpeg</code>).</li> <li><code>file</code>: A <code>SpooledTemporaryFile</code> (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object.</li> </ul> <p><code>UploadFile</code> has the following <code>async</code> methods. They all call the corresponding file methods underneath (using the internal <code>SpooledTemporaryFile</code>).</p> <ul> <li><code>write(data)</code>: Writes <code>data</code> (<code>str</code> or <code>bytes</code>) to the file.</li> <li><code>read(size)</code>: Reads <code>size</code> (<code>int</code>) bytes/characters of the file.</li> <li><code>seek(offset)</code>: Goes to the byte position <code>offset</code> (<code>int</code>) in the file.<ul> <li>E.g., <code>await myfile.seek(0)</code> would go to the start of the file.</li> <li>This is especially useful if you run <code>await myfile.read()</code> once and then need to read the contents again.</li> </ul> </li> <li><code>close()</code>: Closes the file.</li> </ul> <p>As all these methods are <code>async</code> methods, you need to \"await\" them.</p> <p>For example, inside an <code>async</code> path operation function you can get the contents with:</p> <pre><code>contents = await myfile.read()\n</code></pre> <p>If you are inside of a normal <code>def</code> path operation function, you can access the <code>UploadFile.file</code> directly, for example:</p> <pre><code>contents = myfile.file.read()\n</code></pre> <p><code>async</code> Technical Details</p> <p>When you use the <code>async</code> methods, Ellar runs the file methods in a threadpool and awaits for them.</p> <p>Starlette Technical Details</p> <p>Ellar's <code>UploadFile</code> inherits directly from Starlette's <code>UploadFile</code>, but adds some necessary parts to make it compatible with Pydantic and the other parts of Ellar.</p>"},{"location":"techniques/validations/file-params/#uploading-array-of-files","title":"Uploading array of files","text":"<p>To upload several files at the same time, just declare a <code>List</code> of <code>UploadFile</code>:</p> <pre><code># project_name/apps/items/controllers.py\nfrom typing import List\nfrom ellar.common import File, UploadFile, Controller, post, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/upload-many\")\n    def upload_many(self, files: File[List[UploadFile]]):\n        return [f.filename for f in files]\n</code></pre>"},{"location":"techniques/validations/file-params/#uploading-files-with-extra-fields","title":"Uploading files with extra fields","text":"<p>Note: HTTP protocol does not allow you to send files in application/json format by default (unless you encode it somehow to JSON on client side)</p> <p>To send files along with some extra attributes you need to send bodies in multipart/form-data encoding. You can do it by simply marking fields with <code>Form</code>:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, Form, File, UploadFile, post, ControllerBase\nfrom datetime import date\n\n\nclass UserDetails(Serializer):\n    first_name: str\n    last_name: str\n    birthdate: date\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post('/user')\n    def create_user(self, details: UserDetails = Form(), file: UploadFile = File()):\n        return [details.dict(), file.filename]\n</code></pre> <p>Note: in this case all fields should be sent as form fields</p> <p>You can as well send payload in single field as JSON - just remove the Form mark from:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, File, UploadFile, post, ControllerBase\nfrom datetime import date\n\n\nclass UserDetails(Serializer):\n    first_name: str\n    last_name: str\n    birthdate: date\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post('/user')\n    def create_user(self, details: UserDetails, file: UploadFile = File()):\n        return [details.dict(), file.filename]\n</code></pre> <p>this will expect from client side to send data as multipart/form-data with 2 fields:</p> <ul> <li>details: Json as string</li> <li>file: file</li> </ul>"},{"location":"techniques/validations/form-params/","title":"Form Data","text":"<p>Ellar also allows you to parse and validate <code>request.POST</code> data (aka <code>application x-www-form-urlencoded</code> or <code>multipart/form-data</code>). When you need to receive form fields instead of JSON, you can use <code>Form</code>.</p> <p>Info</p> <p>To use forms, first install python-multipart.</p> <p>E.g. <code>pip install python-multipart</code>.</p>"},{"location":"techniques/validations/form-params/#form-data-as-params","title":"Form Data as params","text":"<pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, Form, post, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/login\")\n    def login(self, username: str = Form(), password: str = Form()):\n        return {'username': username, 'password': '*****'}\n</code></pre> <p>Note the following:</p> <p>1) You need to import the <code>Form</code> class from <code>ninja</code> <pre><code>from ellar.common import Form\n</code></pre></p> <p>2) Use <code>Form</code> as default value for your parameter: <pre><code>from ellar.common import Form\n\nusername: str = Form()\n</code></pre></p>"},{"location":"techniques/validations/form-params/#using-a-schema","title":"Using a Schema","text":"<p>In a similar manner to Body, you can use a Schema to organize your parameters.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, post, Form, ControllerBase\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item = Form()):\n        return item\n</code></pre> <p></p>"},{"location":"techniques/validations/form-params/#request-form-path-query-parameters","title":"Request form + path + query parameters","text":"<p>In a similar manner to Body, you can use Form data in combination with other parameter sources.</p> <p>You can declare query and path and form field, and etc... parameters at the same time.</p> <p>Ellar will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared with <code>Form(...)</code> should be taken from the request form fields, etc.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, Form, post, put, ControllerBase\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: float\n    quantity: int\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item = Form()):\n        return item\n\n    @put(\"/{item_id}\")\n    def update(self, item_id: int, q: str, item: Item=Form()):\n        return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n</code></pre>"},{"location":"techniques/validations/form-params/#mapping-empty-form-field-to-default","title":"Mapping Empty Form Field to Default","text":"<p>Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as <code>int</code> or <code>bool</code>.</p> <p>This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Serializer, Controller, Form, post, put, ControllerBase\nfrom pydantic.fields import ModelField\nfrom typing import Generic, TypeVar\n\nPydanticField = TypeVar(\"PydanticField\")\n\n\nclass EmptyStrToDefault(Generic[PydanticField]):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: PydanticField, field: ModelField) -&gt; PydanticField:\n        if value == \"\":\n            return field.default\n        return value\n\n\nclass Item(Serializer):\n    name: str\n    description: str = None\n    price: EmptyStrToDefault[float] = 0.0\n    quantity: EmptyStrToDefault[int] = 0\n    in_stock: EmptyStrToDefault[bool] = True\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @post(\"/\")\n    def create(self, item: Item = Form()):\n        return item\n\n    @put(\"/{item_id}\")\n    def update(self, item_id: int, q: str, item: Item=Form()):\n        return {\"item_id\": item_id, \"item\": item.dict(), \"q\": q}\n\n    @put(\"/items-blank-default\")\n    def update(self, item: Item=Form()):\n        return item.dict()\n</code></pre>"},{"location":"techniques/validations/header-params/","title":"Header Parameters","text":"<p>You can define Header parameters the same way you define <code>Query</code>, <code>Path</code> and <code>Cookie</code> parameters.</p> <p>To query this operation, you use a URL like:</p>"},{"location":"techniques/validations/header-params/#import-header","title":"Import <code>Header</code>","text":"<p>First import <code>Header</code> from <code>ellar.common</code> module</p>"},{"location":"techniques/validations/header-params/#declare-header-parameters","title":"Declare <code>Header</code> parameters","text":"<p>Then declare the header parameters using the same structure as with <code>Path</code>, <code>Query</code> and <code>Cookie</code>.</p> <p>The first value is the default value, you can pass all the extra validation or annotation parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Header, ControllerBase\nfrom typing import Optional\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/\")\n    async def read_items(self, user_agent: Header[Optional[str], Header.P(default=None)]):\n        return {\"User-Agent\": user_agent}\n</code></pre> <p>Info</p> <p>To declare headers, you need to use <code>Header</code>, because otherwise the parameters would be interpreted as query parameters.</p>"},{"location":"techniques/validations/header-params/#automatic-conversion","title":"Automatic conversion","text":"<p><code>Header</code> has a little extra functionality.</p> <p>Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" (<code>-</code>).</p> <p>But a variable like <code>user-agent</code> is not valid in Python.</p> <p>By default, <code>Header</code> will convert the parameter names characters from underscore (<code>_</code>) to hyphen (<code>-</code>) to extract and document the headers.</p> <p>Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake_case\").</p> <p>So, you can use <code>user_agent</code> as you normally would in Python code, instead of needing to capitalize the first letters as <code>User_Agent</code> or something similar.</p> <p>If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter <code>convert_underscores</code> of <code>Header</code> to <code>False</code>:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Header, ControllerBase\nfrom typing import Optional\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/\")\n    async def read_items(\n        self, strange_header:Header[Optional[str], Header.P(default=None, convert_underscores=False)]\n    ):\n        return {\"strange_header\": strange_header}\n</code></pre> <p>Warning</p> <p>Before setting <code>convert_underscores</code> to <code>False</code>, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.</p>"},{"location":"techniques/validations/header-params/#duplicate-headers","title":"Duplicate headers","text":"<p>It is possible to receive duplicate headers. That means, the same header with multiple values.</p> <p>You can define those cases using a list in the type declaration.</p> <p>You will receive all the values from the duplicate header as a Python <code>list</code>.</p> <p>For example, to declare a header of <code>X-Token</code> that can appear more than once, you can write:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import Controller, get, Header, ControllerBase\nfrom typing import Optional, List\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/\")\n    async def read_items(self, x_token: Optional[List[str]] = Header(default=None)):\n        return {\"X-Token values\": x_token}\n</code></pre> <p>If you communicate with that path operation sending two HTTP headers like:</p> <pre><code>X-Token: foo\nX-Token: bar\n</code></pre> <p>The response would be like:</p> <pre><code>{\n    \"X-Token values\": [\n        \"bar\",\n        \"foo\"\n    ]\n}\n</code></pre>"},{"location":"techniques/validations/header-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate <code>Header</code> parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom typing import List\nfrom ellar.common import Serializer, get, Controller, Header, ControllerBase\n\n\n\nclass HeaderSchema(Serializer):\n    version: int = 1\n    x_token: List[str] = None # similar to x_token: Optional[List[str]]\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/header-as-schema')\n    def header_as_schema(self, headers: HeaderSchema = Header()):\n        return {\"headers\": headers.dict()}\n</code></pre>"},{"location":"techniques/validations/path-params/","title":"Path Parameters","text":"<p>You can declare path \"parameters\" with the same syntax used by Python format-strings  which is similar to OpenAPI path parameters</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/{item_id}\")\n    def read_item(self, item_id):\n        return {\"item_id\": item_id}\n</code></pre> <p>The value of the path parameter <code>item_id</code> will be passed to your function as the argument <code>item_id</code>.</p> <p>So, if you run this example and go to http://localhost:8000/items/foo, you will see this response:</p> <pre><code>{\n  \"item_id\":\"foo\"\n}\n</code></pre>"},{"location":"techniques/validations/path-params/#path-parameters-with-types","title":"Path parameters with types","text":"<p>You can declare the type of path parameter in the function using standard Python type annotations:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/items/{item_id}\")\n    def read_item(self, item_id: int):\n        return {\"item_id\": item_id}\n</code></pre> <p>In this case,<code>item_id</code> is declared to be an <code>int</code>. This will give you editor and linter support for error checks, completion, etc.</p> <p>If you run this in your browser with http://localhost:8000/api/items/3, you will see this response: <pre><code>{\n  \"item_id\":3\n}\n</code></pre></p> <p>Tip</p> <p>Notice that the value your function received (and returned) is 3, as a Python <code>int</code> - not a string <code>\"3\"</code>. So, with just that type declaration, Ellar gives you automatic request \"parsing\" and validation.</p>"},{"location":"techniques/validations/path-params/#data-validation","title":"Data validation","text":"<p>On the other hand, if you go to the browser at http://localhost:8000/items/foo, you will see an HTTP error like this:</p> <p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                \"path\",\n                \"item_id\"\n            ],\n            \"msg\": \"value is not a valid integer\",\n            \"type\": \"type_error.integer\"\n        }\n    ]\n}\n</code></pre> that is because the path parameter <code>item_id</code> had a value of <code>\"foo\"</code>, which is not an <code>int</code>.</p> <p>The same error would appear if you provided a <code>float</code> instead of an <code>int</code>, as in: http://localhost:8000/items/4.2</p>"},{"location":"techniques/validations/path-params/#path-converters","title":"Path Converters","text":"<p>You can use Starlette Path Converters to help parse the path:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/{item_id:int}\")\n    def read_item(self, item_id):\n        return {\"item_id\": item_id}\n</code></pre> <p>In this case,<code>item_id</code> will be parsed as an <code>int</code>. If <code>item_id</code> is not a valid <code>int</code>, the url will not match.  (e.g. if no other path matches, a 404 Not Found will be returned)</p> <p>Tip</p> <p>Notice that, since Ellar uses a default type of <code>str</code> for unannotated parameters, the value the function above received (and returned) is <code>\"3\"</code>, as a Python <code>str</code> - not an integer 3. To receive an <code>int</code>, simply declare <code>item_id</code> as an <code>int</code> type annotation in the function definition as normal:</p> <pre><code>...\n@get(\"/items/{int:item_id}\")\ndef read_item(self, item_id:int):\n    return {\"item_id\": item_id}\n</code></pre>"},{"location":"techniques/validations/path-params/#path-params-with-slashes","title":"Path params with slashes","text":"<p>Starlette <code>path</code> converter allows you to handle path-like parameters:</p> <p>For example, lets another route handler <code>some_view</code> and give it a path <code>/dir/{value:path}</code>. What this means is that the parameter is <code>value</code>, and the last part, <code>:path</code>, tells it that the parameter should match any path.</p> <p><pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/dir/{value:path}')\n    def some_view(self, value: str):\n        return value\n</code></pre> You can query this operation with http://localhost:8000/items/dir/some/path/with-slashes  and your <code>value</code> will be equal to <code>\"some/path/with-slashes\"</code></p>"},{"location":"techniques/validations/path-params/#multiple-parameters","title":"Multiple parameters","text":"<p>You can pass as many variables as you want into <code>path</code>, just remember to have unique names and don't forget to use the same names in the function arguments.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/events/{year}/{month}/{day}\")\n    def events(self, year: int, month: int, day: int):\n        return {\"date\": [year, month, day]}\n</code></pre>"},{"location":"techniques/validations/path-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group):</p> <pre><code># project_name/apps/items/controllers.py\n\nimport datetime\nfrom ellar.common import Serializer, get, Controller, Path, ControllerBase\n\n\nclass PathDate(Serializer):\n    year: int\n    month: int\n    day: int\n\n    def value(self):\n        return datetime.date(self.year, self.month, self.day)\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/events/{year}/{month}/{day}\")\n    def events(self, date: PathDate = Path()):\n        return {\"date\": date.value()}\n</code></pre> <p>Note</p> <p>Notice that here we used a <code>Path</code> source hint to let Ellar know that this schema will be applied to path parameters.</p>"},{"location":"techniques/validations/path-params/#documentation","title":"Documentation","text":"<p>Now, when you open your browser at http://localhost:8000/docs, you will see the automatic, interactive, API documentation. </p>"},{"location":"techniques/validations/path-params/#using-enum","title":"Using Enum","text":"<p>If you have a path operation that receives a path parameter,  but you want the possible valid path parameter values to be predefined, you can use a standard Python <code>Enum</code>.</p> <p>For an example:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\nfrom enum import Enum\n\nclass ModelName(str, Enum):\n    alexnet = \"alexnet\"\n    resnet = \"resnet\"\n    lenet = \"lenet\"\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/models/{model_name}\")\n    async def get_model(self, model_name: ModelName):\n        if model_name is ModelName.alexnet:\n            return {\"model_name\": model_name, \"message\": \"Deep Learning FTW!\"}\n\n        if model_name.value == \"lenet\":\n            return {\"model_name\": model_name, \"message\": \"LeCNN all the images\"}\n\n        return {\"model_name\": model_name, \"message\": \"Have some residuals\"}\n</code></pre>"},{"location":"techniques/validations/path-params/#check-the-docs","title":"Check the docs","text":"<p>Because the available values for the path parameter are predefined, the interactive docs can show them nicely:</p> <p></p>"},{"location":"techniques/validations/query-params/","title":"Query Parameters","text":"<p>When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters.</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\nfake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/weapons')\n    def list_weapons(self, limit: int = 10, offset: int = 0):\n        return fake_items_db[offset: offset + limit]\n</code></pre> <p>To query this operation, you use a URL like:</p> <p><pre><code>http://localhost:8000/api/weapons?offset=0&amp;limit=10\n</code></pre> By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it.</p> <p>The same benefits that apply to path parameters also apply to query parameters:</p> <ul> <li>Editor support (obviously)</li> <li>Data \"parsing\"</li> <li>Data validation</li> <li>Automatic documentation</li> </ul> <p>Note: if you do not annotate your arguments, they will be treated as <code>str</code> types:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\nfake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/weapons')\n    def list_weapons(self, limit, offset):\n        assert type(limit) == str\n        assert type(offset) == str\n        return fake_items_db[offset: int(offset) + int(limit)]\n</code></pre>"},{"location":"techniques/validations/query-params/#defaults","title":"Defaults","text":"<p>As query parameters are not a fixed part of a path, they are optional and can have default values:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\nfake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/weapons')\n    def list_weapons(self, limit: int = 10, offset: int = 0):\n        return fake_items_db[offset: offset + limit]\n</code></pre> <p>In the example above we set default values of <code>offset=0</code> and <code>limit=10</code>.</p> <p>So, going to the URL: <pre><code>http://localhost:8000/items/weapons\n</code></pre> would be the same as going to: <pre><code>http://localhost:8000/items/weapons?offset=0&amp;limit=10\n</code></pre> If you go to, for example: <pre><code>http://localhost:8000/items/weapons?offset=20\n</code></pre></p> <p>the parameter values in your function will be:</p> <ul> <li><code>offset=20</code>  (because you set it in the URL)</li> <li><code>limit=10</code>  (because that was the default value)</li> </ul>"},{"location":"techniques/validations/query-params/#required-and-optional-parameters","title":"Required and optional parameters","text":"<p>You can declare required or optional GET parameters in the same way as declaring Python function arguments:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\n\nweapons = [\"Ninjato\", \"Shuriken\", \"Katana\", \"Kama\", \"Kunai\", \"Naginata\", \"Yari\"]\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/weapons/search\")\n    def search_weapons(self, q: str, offset: int = 0):\n        results = [w for w in weapons if q in w.lower()]\n        print(q, results)\n        return results[offset: offset + 10]\n</code></pre> <p>In this case, Ellar will always validate that you pass the <code>q</code> param in the GET, and the <code>offset</code> param is an optional integer.</p>"},{"location":"techniques/validations/query-params/#get-parameters-type-conversion","title":"GET parameters type conversion","text":"<p>Let's declare multiple type arguments: <pre><code># project_name/apps/items/controllers.py\n\nfrom ellar.common import get, Controller, ControllerBase\nfrom datetime import date\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get(\"/example\")\n    def example(self, s: str = None, b: bool = None, d: date = None, i: int = None):\n        return [s, b, d, i]\n</code></pre> The <code>str</code> type is passed as is.</p> <p>For the <code>bool</code> type, all the following: <pre><code>http://localhost:8000/items/example?b=1\nhttp://localhost:8000/items/example?b=True\nhttp://localhost:8000/items/example?b=true\nhttp://localhost:8000/items/example?b=on\nhttp://localhost:8000/items/example?b=yes\n</code></pre> or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter <code>b</code> with a <code>bool</code> value of <code>True</code>, otherwise as <code>False</code>.</p> <p>Date can be both date string and integer (unix timestamp): <pre><code>http://localhost:8000/items/example?d=1672286800\n# same as 2022-12-29\n\nhttp://localhost:8000/items/example?d=2022-12-29\n</code></pre></p>"},{"location":"techniques/validations/query-params/#using-schema","title":"Using Schema","text":"<p>You can also use Schema to encapsulate GET parameters:</p> <pre><code># project_name/apps/items/controllers.py\n\nfrom typing import List\nfrom pydantic import Field\nfrom ellar.common import Serializer, get, Controller, Query, ControllerBase\n\n\n\nclass Filters(Serializer):\n    limit: int = 100\n    offset: int = None\n    query: str = None\n    category__in: List[str] = Field(None, alias=\"categories\")\n\n\n@Controller\nclass ItemsController(ControllerBase):\n    @get('/query-as-schema')\n    def query_as_schema(self, filters:Query[Filters]):\n        return {\"filters\": filters.dict()}\n</code></pre> <p></p>"},{"location":"websockets/socketio/","title":"Socket IO - python-socketio","text":"<p>Ellar integration with python-socketio, a library that enables real-time, bidirectional and event-based communication between the browser and the server. </p>"},{"location":"websockets/socketio/#gateways","title":"Gateways","text":"<p>A class annotated with <code>WebSocketGateway</code> decorator is like a controller that creates a compatibles with python-socketio, ellar and websocket.  A gateway class also supports dependency injection and guards.</p> <pre><code>from ellar.socket_io import WebSocketGateway\n\n\n@WebSocketGateway(path='/events-ws', name='event-gateway')\nclass EventGateway:\n    pass\n</code></pre>"},{"location":"websockets/socketio/#installation","title":"Installation","text":"<p>To start building Socket.IO webSockets-based applications, first install the required package: <pre><code>$(venv) pip install python-socketio\n</code></pre></p>"},{"location":"websockets/socketio/#overview","title":"Overview","text":"<p>In general, each gateway is listening on the same port as the HTTP server and has a path <code>/socket.io</code> unless changed manually.  This default behavior can be modified by passing an argument to the <code>@WebSocketGateway(path='/event-ws')</code>.  You can also set a namespace used by the gateway as shown below:</p> <pre><code># project_name/events/gateway.py\nfrom ellar.socket_io import WebSocketGateway\n\n\n@WebSocketGateway(path='/socket.io', namespace='events')\nclass EventGateway:\n    pass\n</code></pre> <p>Warning</p> <p>Gateways are not instantiated until they are referenced in the <code>controllers</code> array of an existing module.</p> <p>You can pass any supported option to the socket constructor with the second argument to the <code>@WebSocketGateway()</code> decorator, as shown below:</p> <pre><code># project_name/events/gateway.py\nfrom ellar.socket_io import WebSocketGateway, GatewayBase\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    pass\n</code></pre> <p>The gateway is now listening, but we have not yet subscribed to any incoming messages.  Let's create a handler that will subscribe to the <code>events</code> messages and respond to the user with the exact same data. <pre><code># project_name/events/gateway.py\nfrom ellar.socket_io import WebSocketGateway, subscribe_message, GatewayBase\nfrom ellar.common import WsBody\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @subscribe_message('events')\n    async def handle_event(self, data: str = WsBody()):\n        return data\n</code></pre></p> <p>You can also define schema for the data receive, for example: <pre><code># project_name/events/gateway.py\nfrom ellar.socket_io import WebSocketGateway, subscribe_message, GatewayBase\nfrom ellar.common import WsBody\nfrom pydantic import BaseModel\n\n\nclass MessageBody(BaseModel):\n    data: str\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @subscribe_message('events')\n    async def handle_event(self, data: MessageBody = WsBody()):\n        return data.dict()\n</code></pre></p> <p>Once the gateway is created, we can register it in our module. <pre><code># project_name/events/module.py\n\nfrom ellar.common import Module\nfrom .gateway import EventGateway\n\n@Module(controllers=[EventGateway])\nclass EventsModule:\n    pass\n</code></pre></p> <p><code>WebSocketGateway</code> decorated class comes with a different context that providers extra information/access to <code>server</code>, <code>sid</code> and current message <code>environment</code>. <pre><code>from ellar.socket_io import GatewayBase\nfrom socketio import AsyncServer\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @subscribe_message('events')\n    async def handle_event(self, data: MessageBody = WsBody()):\n        assert isinstance(self.context.server, AsyncServer)\n        assert isinstance(self.context.sid, str)\n        assert isinstance(self.context.environment, dict)\n\n        await self.context.server.emit('my_custom_event', data.dict(), room=None)\n</code></pre></p>"},{"location":"websockets/socketio/#wsresponse","title":"WsResponse","text":"<p>You may return a <code>WsResponse</code> object and supply two properties. The <code>event</code> which is a name of the emitted event and the <code>data</code> that has to be forwarded to the client. <pre><code>from ellar.socket_io import GatewayBase\nfrom ellar.socket_io import WsResponse\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @subscribe_message('events')\n    async def handle_event(self, data: MessageBody = WsBody()):\n        return WsResponse('events', data.dict())\n</code></pre></p> <p>Hint</p> <p>The <code>WsResponse</code> class is imported from <code>ellar.socketio</code> package. And its has similar interface as <code>AsyncServer().emit</code></p> <p>Warning</p> <p>If you return a response that is not a <code>WsResponse</code> object, ellar will assume handler as the <code>event</code> to emit the response. Or you can use <code>self.context.server.emit</code> to send the message back to the client.</p> <p>In order to listen for the incoming response(s), the client has to apply another event listener.</p> <pre><code>socket.on('events', (data) =&gt; console.log(data));\n</code></pre>"},{"location":"websockets/socketio/#gateway-connection-and-disconnection-handling","title":"Gateway Connection and Disconnection Handling","text":"<p><code>on_connected</code> and <code>on_disconnected</code> can be used to define <code>on_connect</code> and <code>on_disconnect</code> handler in your gateway controller.</p> <p>For example, <pre><code>from ellar.socket_io import GatewayBase, WebSocketGateway, subscribe_message, on_connected, on_disconnected\nfrom ellar.socket_io import WsResponse\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @on_connected()\n    async def connect(self):\n        await self.context.server.emit(\n            \"my_response\", {\"data\": \"Connected\", \"count\": 0}, room=self.context.sid\n        )\n\n    @on_disconnected()\n    async def disconnect(self):\n        print(\"Client disconnected\")\n\n    @subscribe_message('events')\n    async def handle_event(self, data: MessageBody = WsBody()):\n        return WsResponse('events', data.dict())\n</code></pre></p> <p>Info</p> <p><code>@on_connected</code> and <code>@on_disconnected()</code> handlers doesn't take any argument because all its arguments are already available in the <code>self.context</code></p>"},{"location":"websockets/socketio/#exceptions","title":"Exceptions","text":"<p>All exceptions that happens on the server in a gateway controller after successful handshake between the server and client are sent to the client through <code>error</code> event. This is a standard practice when working socketio client. The client is required to subscribe to <code>error</code> event inorder to receive error message from the server.</p> <p>for example: <pre><code>from ellar.socket_io import GatewayBase, WebSocketGateway, subscribe_message\nfrom ellar.common.exceptions import WebSocketException\nfrom starlette import status\n\n\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @subscribe_message('events')\n    async def handle_event(self, data: MessageBody = WsBody()):\n        raise WebSocketException(status.WS_1009_MESSAGE_TOO_BIG, reason='Message is too big')\n</code></pre> When client sends message to <code>events</code>, an exception will be raised. And the client will receive the error message if it subscribed to <code>error</code> events. </p> <p>For example:</p> <pre><code>const socket = io.connect()\n\nsocket.on('error', (error) =&gt; {\n    console.error(error)\n})\n</code></pre>"},{"location":"websockets/socketio/#guards","title":"Guards","text":"<p>There is no fundamental difference between web sockets guards and regular HTTP application guards.  The only difference is that instead of throwing <code>HttpException</code>, you should use <code>WebSocketException</code></p> <p>Hint</p> <p><code>WebSocketException</code> is an exception class located in <code>ellar.common.exceptions</code></p> <pre><code>from ellar.common import Guards\n\n...\n@Guards(MyCustomGuards)\n@subscribe_message('events')\nasync def handle_event(self, data: MessageBody = WsBody()):\n    return WsResponse('events', data.dict())\n...\n</code></pre> <p><code>@Guards</code> can be applied at handler level as shown in the last construct or at class level as shown below:</p> <pre><code>...\n\n@Guards(MyGuard)\n@WebSocketGateway(path='/socket.io', transports=['websocket'])\nclass EventGateway(GatewayBase):\n    @on_connected()\n    async def connect(self):\n        await self.context.server.emit(\n            \"my_response\", {\"data\": \"Connected\", \"count\": 0}, room=self.context.sid\n        )\n    ...\n</code></pre>"},{"location":"websockets/socketio/#testing","title":"Testing","text":"<p>Gateway can be unit tested just like regular ellar controllers. But for integration testing, a separate testing module, <code>TestGateway</code>, is needed  to set up a socketio client to simulation activity between server and client.</p> <p>Hint</p> <p><code>TestGateway</code> class is located at <code>ellar.socket_io.testing</code></p> <p>For example:</p> <p><pre><code>@WebSocketGateway(path=\"/ws\", async_mode=\"asgi\", cors_allowed_origins=\"*\")\nclass EventGateway:\n    @subscribe_message(\"my_event\")\n    async def my_event(self, message: MessageData = WsBody()):\n        return WsResponse(\"my_response\", {\"data\": message.data}, room=self.context.sid)\n\n    @subscribe_message\n    async def my_broadcast_event(self, message: MessageData = WsBody()):\n        await self.context.server.emit(\"my_response\", {\"data\": message.data})\n\n    @on_connected()\n    async def connect(self):\n        await self.context.server.emit(\n            \"my_response\", {\"data\": \"Connected\", \"count\": 0}, room=self.context.sid\n        )\n\n    @on_disconnected()\n    async def disconnect(self):\n        print(\"Client disconnected\")\n</code></pre> The above gateway construct integration testing can be done as shown below:</p> <p><pre><code>import pytest\nfrom ellar.socket_io.testing import TestGateway\n\n@pytest.mark.asyncio\nclass TestEventGateway:\n    test_client = TestGateway.create_test_module(controllers=[EventGateway])\n\n    async def test_socket_connection_work(self):\n        my_response_message = []\n        connected_called = False\n        disconnected_called = False\n\n        async with self.test_client.run_with_server() as ctx:\n\n            @ctx.sio.event\n            async def my_response(message):\n                my_response_message.append(message)\n\n            @ctx.sio.event\n            async def disconnect():\n                nonlocal disconnected_called\n                disconnected_called = True\n\n            @ctx.sio.event\n            async def connect(*args):\n                nonlocal connected_called\n                await ctx.sio.emit(\"my_event\", {\"data\": \"I'm connected!\"})\n                connected_called = True\n\n            await ctx.connect(socketio_path=\"/ws/\")\n            await ctx.wait()\n\n        assert len(my_response_message) == 2\n        assert my_response_message == [\n            {\"data\": \"Connected\", \"count\": 0},\n            {\"data\": \"I'm connected!\"},\n        ]\n        assert disconnected_called and connected_called\n\n    async def test_broadcast_work(self):\n        sio_1_response_message = []\n        sio_2_response_message = []\n\n        async with self.test_client.run_with_server() as ctx:\n            ctx_2 = ctx.new_socket_client_context()\n\n            @ctx.sio.event\n            async def my_response(message):\n                sio_1_response_message.append(message)\n\n            @ctx_2.sio.event\n            async def my_response(message):\n                sio_2_response_message.append(message)\n\n            await ctx.connect(socketio_path=\"/ws/\")\n            await ctx_2.connect(socketio_path=\"/ws/\")\n\n            await ctx.sio.emit(\n                \"my_broadcast_event\", {\"data\": \"Testing Broadcast\"}\n            )  # both sio_1 and sio_2 would receive this message\n\n            await ctx.wait()\n            await ctx_2.wait()\n\n        assert len(sio_1_response_message) == 2\n        assert sio_1_response_message == [\n            {\"data\": \"Connected\", \"count\": 0},\n            {\"data\": \"Testing Broadcast\"},\n        ]\n\n        assert len(sio_2_response_message) == 2\n        assert sio_2_response_message == [\n            {\"data\": \"Connected\", \"count\": 0},\n            {\"data\": \"Testing Broadcast\"},\n        ]\n</code></pre> <code>self.test_client.run_with_server()</code> setup a server and returns <code>RunWithServerContext</code> object. The <code>RunWithServerContext</code> contains a socket io client and created server url.  And with the client(<code>sio</code>) returned, you can subscribe to events and send messages as shown in the above construct.</p> <p>Warning</p> <p>It is important to have all the event subscription written before calling <code>ctx.connect</code></p> <p>Also, it is possible to test with more than one client as you can see in <code>test_broadcast_work</code> in construct above. We created another instance of RunWithServerContext as <code>ctx_2</code> from the already existing <code>ctx</code> with <code>ctx.new_socket_client_context()</code>.  And both were used to test for message broadcast.</p>"},{"location":"websockets/socketio/#socketio-ellar-example","title":"SocketIO Ellar Example","text":"<p>python-socketio provided a sample project on how to integrate python-socketio with django. The sample project was converted to ellar gateway and it can find it here</p> <p></p>"},{"location":"websockets/websockets/","title":"Websocket","text":"<p>WebSocket is a powerful communication protocol that allows for two-way communication between a client and a server over a single,  long-lived connection, making it an ideal tool for building real-time applications.</p>"},{"location":"websockets/websockets/#creating-a-websocket-route","title":"Creating a WebSocket Route","text":"<p>In Ellar, you create websocket route using <code>ws_route</code> decorator.</p> <pre><code># project_name/apps/car/controller.py\n\nfrom ellar.common import Controller, ControllerBase, ws_route\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @ws_route('/live-support')\n    async def live_support(self):\n        pass\n</code></pre> <p>Let's go deep with a more practical example. First we need to create a html with some javascript scripts that will connect to our websocket. </p> <pre><code>&lt;!--project_name/apps/car/templates/ws-index.html ---&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Ellar Chat Demo&lt;/title&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css\"\n              rel=\"stylesheet\" integrity=\"sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ\"\n              crossorigin=\"anonymous\"&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js\"\n                integrity=\"sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe\"\n                crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"container\" style=\"max-width: 40rem\"&gt;\n            &lt;div class=\"mt-3 text-center\"&gt;\n               &lt;h2&gt;Support Live Support&lt;/h2&gt;\n            &lt;/div&gt;\n            &lt;hr&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;form action=\"\" onsubmit=\"sendMessage(event)\"&gt;\n                    &lt;textarea type=\"text\" class=\"form-control\" id=\"messageText\" rows=\"4\"&gt;&lt;/textarea&gt;\n                    &lt;button class=\"btn btn-primary mt-2\"&gt;Send Message&lt;/button&gt;\n                &lt;/form&gt;\n            &lt;/div&gt;\n            &lt;hr&gt;\n            &lt;ul id='messages' class=\"mx-auto list-unstyled\"&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;script&gt;\n            let ws = new WebSocket(\"ws://localhost:8000/car/live-support\");\n            ws.onmessage = function(event) {\n                addMessage(event.data)\n            };\n            function sendMessage(event) {\n                let input = document.getElementById(\"messageText\")\n                addMessage(input.value, true)\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n\n            function addMessage(data, inBound = false) {\n                let messages = document.getElementById('messages')\n                let container_message = document.createElement('li')\n                let message = document.createElement('p')\n                if (inBound) {\n                    container_message.classList.add('d-flex', 'justify-content-end')\n                    message.classList.add(...['p-2','rounded-2','bg-danger-subtle', 'my-1'])\n                }else {\n                    container_message.classList.add('d-flex')\n                    message.classList.add(...[ 'p-2', 'rounded-2', 'bg-primary-subtle', 'my-1'])\n                }\n                message.innerHTML = data\n                container_message.appendChild(message)\n                messages.appendChild(container_message)\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Next, we add some code to the <code>live-feed</code> websocket route we created initially to accept connection and send messages to the client once there is a successful handshake.</p> <p><pre><code>@Controller('/car')\nclass CarController(ControllerBase):\n    @get('/ws-index')\n    @render(template_name='ws-index.html')\n    async def ws_index(self):\n        return {}\n\n    @ws_route('/live-support')\n    async def live_support(self):\n        ws = self.context.switch_to_websocket().get_client()\n        await ws.accept()\n        await ws.send_text('Welcome to our live support room!\\nHow can we help you?')\n\n        while True:\n            try:\n                data = await ws.receive_text()\n                await ws.send_text(f'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"{data}\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.')\n            except Exception as ex:\n                assert ws.close()\n                break\n</code></pre> In example, we added <code>/ws-index</code>, to fetch the html file that has some javascript websocket connection to <code>/live-support</code> websocket route. </p> <p>So, when we visit the route below http://127.0.0.1:8000/car/ws-index, you will have an interacting screen as shown below</p> <p></p> <p>In above example, <code>ws.receive_text()</code> was used to receive messages sent from the websocket client.  Also messages can be received in json(<code>ws.receive_json()</code>), text(<code>ws.receive_text()</code>) and in bytes(<code>ws.receive_bytes()</code>)</p> <p>In the same other, messages can be sent back in the same forms; text(<code>ws.send_text()</code>), json(<code>ws.send_json()</code>) and bytes(<code>ws.send_bytes()</code>)</p>"},{"location":"websockets/websockets/#guards-on-websockets","title":"Guards on websockets","text":"<p>Guards works exactly as described earlier for a normal HTTP request. In the case of websocket, Guards are only active when a client is about to  connect to the server. After a successful handshake between the server and the client, the guards actions are no longer involved in server to client communication and vice versa.</p> <p><pre><code>from ellar.di import injectable\nfrom ellar.common import Query, Guards, GuardCanActivate, IExecutionContext, ws_route\n\n...\n@injectable\nclass MyGuard(GuardCanActivate):\n    async def can_activate(self, context: IExecutionContext) -&gt; bool:\n        print('MyGuard was called.')\n        return False\n\n...\n@ws_route('/live-support')\n@Guards(MyGuard)\nasync def live_support(self, name: str = Query('John')):\n    ws = self.context.switch_to_websocket().get_client()\n    await ws.accept()\n    await ws.send_text(f'Welcome {name} to our live support room!\\nHow can we help you?')\n\n    while True:\n        try:\n            data = await ws.receive_text()\n            await ws.send_text(f'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"{data}\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.')\n        except Exception as ex:\n            assert ws.close()\n            break\n</code></pre> In the construction above, we applied <code>MyGuard</code> to <code>/live-suport</code> route function.  And for a connection to <code>/live-suport</code> to be successful, <code>MyGuard</code> can_activate must return <code>True</code>.</p>"},{"location":"websockets/websockets/#websocket-handler-dependencies","title":"Websocket handler Dependencies","text":"<p>Websocket handler supports all route handler parameters except <code>Body</code> and <code>Forms</code>. </p> <p>Let's use a <code>Query</code> parameter on the <code>/live-feed</code> WebSocket route. <pre><code>from ellar.common import Query, ws_route\n...\n@ws_route('/live-support')\nasync def live_support(self, name: str = Query('John')):\n    ws = self.context.switch_to_websocket().get_client()\n    await ws.accept()\n    await ws.send_text(f'Welcome {name} to our live support room!\\nHow can we help you?')\n\n    while True:\n        try:\n            data = await ws.receive_text()\n            await ws.send_text(f'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"{data}\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.')\n        except Exception as ex:\n            assert ws.close()\n            break\n</code></pre> Now, when you visit this endpoint http://127.0.0.1:8000/car/ws-index again, you will see a name query parameter attached to the welcome message.</p>"},{"location":"websockets/websockets/#advance-websocket-usage","title":"Advance websocket usage","text":"<p>The <code>ws_route</code> offers more than just defining a websocket route. It can also be used to define handlers for different sessions of a websocket route. By setting <code>use_extra_handler=True</code> in <code>ws_route</code> decorator, we activate an in-built handler that gives the ability to  manage different sessions of websocket differently like <code>on_connect</code>, <code>on_message</code> and <code>on_disconnect</code></p> <ul> <li><code>on_connect(websocket, **kwargs)</code>: handles client connection with the server.</li> <li><code>on_message(websocket, data)</code>: handles messages sent from the client</li> <li><code>on_disconnect(websocket, close_code)</code>: handles server disconnecting from client</li> </ul> <p>Info</p> <p>This approach also enables message data type validation using <code>WsBody</code>.  <code>WsBody</code> is similar to <code>Body</code> but for websockets.</p> <p>Let's rewrite the previous example, <code>/live-support</code> websocket route. <pre><code># project_name/apps/car/controller.py\n\nfrom ellar.common import Controller, ControllerBase, ws_route, get, render, WsBody, Guards\nfrom starlette.websockets import WebSocket\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get('/ws-index')\n    @render(template_name='ws-index.html')\n    async def ws_index(self):\n        return {}\n\n    @ws_route('/live-support', use_extra_handler=True, encoding='text')\n    @Guards(MyGuard)\n    async def live_support(self, data: str = WsBody()):\n        ws = self.context.switch_to_websocket().get_client()\n        await ws.send_text(f'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"{data}\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.')\n\n    @ws_route.connect(live_support)\n    async def live_support_connect(self, websocket: WebSocket):\n        await websocket.accept()\n        await websocket.send_text('Welcome to our live support room!\\nHow can we help you?')\n\n    @ws_route.disconnect(live_support)\n    async def live_support_disconnect(self, websocket: WebSocket, code: int):\n        await websocket.close(code)\n</code></pre> In the construct above, we created <code>def live_support_connect</code> to handle connection to the <code>'/live-support'</code> websocket route and <code>def live_support_disconnect</code> to handle disconnection from it. <code>def live_support_connect</code> and <code>def live_support_disconnect</code>  takes <code>websocket</code> instance as only parameter and must be an asynchronous function.</p> <p>On the other hand,<code>def live_support</code> function is now a message receiver handler and so, there is need to define a parameter with <code>WsBody</code>,  in this case <code>data:str = WsBody()</code>. Message sent from client will be passed to <code>data</code> parameter after validation and procession by <code>WsBody</code>. If validation fails, an error will be sent to the client and connection will be destroyed.</p> <p>The <code>encoding</code> = 'text' states the message data structure that is required of the client when sending messages to the server. There are other <code>encoding</code> types supported:</p> <ul> <li><code>text</code>: allows only simple text messages as in the case above, e.g. <code>@ws_route('/path', use_extra_handler=True, encoding='text')</code> </li> <li><code>json</code>: allows json messages e.g. <code>@ws_route('/path', use_extra_handler=True, encoding='json')</code></li> <li><code>bytes</code>: allows byte messages e.g. <code>@ws_route('/path', use_extra_handler=True, encoding='bytes')</code></li> </ul> <p>Simplifying the example above</p> <p>We can further simplify the example above by getting rid of the <code>live_support_connect</code> and <code>live_support_disconnect</code> and let the inbuilt handler apply the default <code>connection</code> and <code>disconnection</code> actions. </p> <pre><code># project_name/apps/car/controller.py\n\nfrom ellar.common import ControllerBase, Controller, ws_route, get, render, WsBody\n\n\n@Controller('/car')\nclass CarController(ControllerBase):\n    @get('/ws-index')\n    @render(template_name='ws-index.html')\n    async def ws_index(self):\n        return {}\n\n    @ws_route('/live-support', use_extra_handler=True, encoding='text')\n    async def live_support(self, data: str = WsBody()):\n        ws = self.context.switch_to_websocket().get_client()\n        await ws.send_text(f'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"{data}\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.')\n</code></pre>"},{"location":"websockets/websockets/#testing-a-websocket-route","title":"Testing a Websocket Route","text":"<p>You can use the same TestClient to test WebSockets.</p> <p>For this, you use the TestClient in a <code>with</code> statement, connecting to the WebSocket:</p> <pre><code># project_name/car/tests/test_controllers.py\nfrom project_name.apps.car.controllers import CarController\nfrom ellar.testing import Test, TestClient\n\n\nclass TestCarController:\n    def setup(self):\n        test_module = Test.create_test_module(\n            controllers=[CarController,],\n            config_module=dict(\n                REDIRECT_SLASHES=True\n            )\n        )\n        self.client: TestClient = test_module.get_test_client()\n\n    def test_live_support_works(self):\n        with self.client.websocket_connect('/car/live-support') as websocket_client:\n            data = websocket_client.receive_text()\n            assert data == 'Welcome to our live support room!\\nHow can we help you?'\n\n            websocket_client.send_text('Message from client')\n            data = websocket_client.receive_text()\n            assert data == 'We have received you complain:&lt;br&gt;&lt;br&gt;&lt;strong&gt;\"Message from client\"&lt;/strong&gt;&lt;br&gt;&lt;br&gt;We shall get back to you.'\n</code></pre>"}]}